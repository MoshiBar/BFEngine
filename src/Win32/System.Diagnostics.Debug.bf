using System;
using static Win32.System.Com.StructuredStorage;
using static Win32.System.Threading;
using static Win32.System.Time;
using static Win32.Security.WinTrust;
using static Win32.Win32;
using static Win32.System.Com;
using static System.Windows;
using static System.Windows.COM_IUnknown;

// namespace System.Diagnostics.Debug
namespace Win32.Diagnostics
{
	static class Debug
	{
		// --- Constants ---
		
		public const uint32 WOW64_CONTEXT_i386 = 65536;
		public const uint32 WOW64_CONTEXT_i486 = 65536;
		public const uint32 WOW64_CONTEXT_EXCEPTION_ACTIVE = 134217728;
		public const uint32 WOW64_CONTEXT_SERVICE_ACTIVE = 268435456;
		public const uint32 WOW64_CONTEXT_EXCEPTION_REQUEST = 1073741824;
		public const uint32 WOW64_CONTEXT_EXCEPTION_REPORTING = 2147483648;
		public const uint32 WOW64_SIZE_OF_80387_REGISTERS = 80;
		public const uint32 WOW64_MAXIMUM_SUPPORTED_EXTENSION = 512;
		public const uint32 ERROR_DBG_CANCELLED = 3221226695;
		public const uint32 ERROR_DBG_TIMEOUT = 3221226932;
		public const uint32 DEBUG_GET_TEXT_COMPLETIONS_NO_DOT_COMMANDS = 1;
		public const uint32 DEBUG_GET_TEXT_COMPLETIONS_NO_EXTENSION_COMMANDS = 2;
		public const uint32 DEBUG_GET_TEXT_COMPLETIONS_NO_SYMBOLS = 4;
		public const uint32 DEBUG_GET_TEXT_COMPLETIONS_IS_DOT_COMMAND = 1;
		public const uint32 DEBUG_GET_TEXT_COMPLETIONS_IS_EXTENSION_COMMAND = 2;
		public const uint32 DEBUG_GET_TEXT_COMPLETIONS_IS_SYMBOL = 4;
		public const uint32 DEBUG_REQUEST_SOURCE_PATH_HAS_SOURCE_SERVER = 0;
		public const uint32 DEBUG_REQUEST_TARGET_EXCEPTION_CONTEXT = 1;
		public const uint32 DEBUG_REQUEST_TARGET_EXCEPTION_THREAD = 2;
		public const uint32 DEBUG_REQUEST_TARGET_EXCEPTION_RECORD = 3;
		public const uint32 DEBUG_REQUEST_GET_ADDITIONAL_CREATE_OPTIONS = 4;
		public const uint32 DEBUG_REQUEST_SET_ADDITIONAL_CREATE_OPTIONS = 5;
		public const uint32 DEBUG_REQUEST_GET_WIN32_MAJOR_MINOR_VERSIONS = 6;
		public const uint32 DEBUG_REQUEST_READ_USER_MINIDUMP_STREAM = 7;
		public const uint32 DEBUG_REQUEST_TARGET_CAN_DETACH = 8;
		public const uint32 DEBUG_REQUEST_SET_LOCAL_IMPLICIT_COMMAND_LINE = 9;
		public const uint32 DEBUG_REQUEST_GET_CAPTURED_EVENT_CODE_OFFSET = 10;
		public const uint32 DEBUG_REQUEST_READ_CAPTURED_EVENT_CODE_STREAM = 11;
		public const uint32 DEBUG_REQUEST_EXT_TYPED_DATA_ANSI = 12;
		public const uint32 DEBUG_REQUEST_GET_EXTENSION_SEARCH_PATH_WIDE = 13;
		public const uint32 DEBUG_REQUEST_GET_TEXT_COMPLETIONS_WIDE = 14;
		public const uint32 DEBUG_REQUEST_GET_CACHED_SYMBOL_INFO = 15;
		public const uint32 DEBUG_REQUEST_ADD_CACHED_SYMBOL_INFO = 16;
		public const uint32 DEBUG_REQUEST_REMOVE_CACHED_SYMBOL_INFO = 17;
		public const uint32 DEBUG_REQUEST_GET_TEXT_COMPLETIONS_ANSI = 18;
		public const uint32 DEBUG_REQUEST_CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE = 19;
		public const uint32 DEBUG_REQUEST_GET_OFFSET_UNWIND_INFORMATION = 20;
		public const uint32 DEBUG_REQUEST_GET_DUMP_HEADER = 21;
		public const uint32 DEBUG_REQUEST_SET_DUMP_HEADER = 22;
		public const uint32 DEBUG_REQUEST_MIDORI = 23;
		public const uint32 DEBUG_REQUEST_PROCESS_DESCRIPTORS = 24;
		public const uint32 DEBUG_REQUEST_MISC_INFORMATION = 25;
		public const uint32 DEBUG_REQUEST_OPEN_PROCESS_TOKEN = 26;
		public const uint32 DEBUG_REQUEST_OPEN_THREAD_TOKEN = 27;
		public const uint32 DEBUG_REQUEST_DUPLICATE_TOKEN = 28;
		public const uint32 DEBUG_REQUEST_QUERY_INFO_TOKEN = 29;
		public const uint32 DEBUG_REQUEST_CLOSE_TOKEN = 30;
		public const uint32 DEBUG_REQUEST_WOW_PROCESS = 31;
		public const uint32 DEBUG_REQUEST_WOW_MODULE = 32;
		public const uint32 DEBUG_LIVE_USER_NON_INVASIVE = 33;
		public const uint32 DEBUG_REQUEST_RESUME_THREAD = 34;
		public const uint32 DEBUG_REQUEST_INLINE_QUERY = 35;
		public const uint32 DEBUG_REQUEST_TL_INSTRUMENTATION_AWARE = 36;
		public const uint32 DEBUG_REQUEST_GET_INSTRUMENTATION_VERSION = 37;
		public const uint32 DEBUG_REQUEST_GET_MODULE_ARCHITECTURE = 38;
		public const uint32 DEBUG_SRCFILE_SYMBOL_TOKEN = 0;
		public const uint32 DEBUG_SRCFILE_SYMBOL_TOKEN_SOURCE_COMMAND_WIDE = 1;
		public const uint32 DEBUG_SRCFILE_SYMBOL_CHECKSUMINFO = 2;
		public const uint32 DEBUG_SYMINFO_BREAKPOINT_SOURCE_LINE = 0;
		public const uint32 DEBUG_SYMINFO_IMAGEHLP_MODULEW64 = 1;
		public const uint32 DEBUG_SYMINFO_GET_SYMBOL_NAME_BY_OFFSET_AND_TAG_WIDE = 2;
		public const uint32 DEBUG_SYMINFO_GET_MODULE_SYMBOL_NAMES_AND_OFFSETS = 3;
		public const uint32 DEBUG_SYSOBJINFO_THREAD_BASIC_INFORMATION = 0;
		public const uint32 DEBUG_SYSOBJINFO_THREAD_NAME_WIDE = 1;
		public const uint32 DEBUG_SYSOBJINFO_CURRENT_PROCESS_COOKIE = 2;
		public const uint32 DEBUG_TBINFO_EXIT_STATUS = 1;
		public const uint32 DEBUG_TBINFO_PRIORITY_CLASS = 2;
		public const uint32 DEBUG_TBINFO_PRIORITY = 4;
		public const uint32 DEBUG_TBINFO_TIMES = 8;
		public const uint32 DEBUG_TBINFO_START_OFFSET = 16;
		public const uint32 DEBUG_TBINFO_AFFINITY = 32;
		public const uint32 DEBUG_TBINFO_ALL = 63;
		public const uint32 DEBUG_BREAKPOINT_CODE = 0;
		public const uint32 DEBUG_BREAKPOINT_DATA = 1;
		public const uint32 DEBUG_BREAKPOINT_TIME = 2;
		public const uint32 DEBUG_BREAKPOINT_INLINE = 3;
		public const uint32 DEBUG_BREAKPOINT_GO_ONLY = 1;
		public const uint32 DEBUG_BREAKPOINT_DEFERRED = 2;
		public const uint32 DEBUG_BREAKPOINT_ENABLED = 4;
		public const uint32 DEBUG_BREAKPOINT_ADDER_ONLY = 8;
		public const uint32 DEBUG_BREAKPOINT_ONE_SHOT = 16;
		public const uint32 DEBUG_BREAK_READ = 1;
		public const uint32 DEBUG_BREAK_WRITE = 2;
		public const uint32 DEBUG_BREAK_EXECUTE = 4;
		public const uint32 DEBUG_BREAK_IO = 8;
		public const uint32 DEBUG_ATTACH_KERNEL_CONNECTION = 0;
		public const uint32 DEBUG_ATTACH_LOCAL_KERNEL = 1;
		public const uint32 DEBUG_ATTACH_EXDI_DRIVER = 2;
		public const uint32 DEBUG_ATTACH_INSTALL_DRIVER = 4;
		public const uint32 DEBUG_GET_PROC_DEFAULT = 0;
		public const uint32 DEBUG_GET_PROC_FULL_MATCH = 1;
		public const uint32 DEBUG_GET_PROC_ONLY_MATCH = 2;
		public const uint32 DEBUG_GET_PROC_SERVICE_NAME = 4;
		public const uint32 DEBUG_PROC_DESC_DEFAULT = 0;
		public const uint32 DEBUG_PROC_DESC_NO_PATHS = 1;
		public const uint32 DEBUG_PROC_DESC_NO_SERVICES = 2;
		public const uint32 DEBUG_PROC_DESC_NO_MTS_PACKAGES = 4;
		public const uint32 DEBUG_PROC_DESC_NO_COMMAND_LINE = 8;
		public const uint32 DEBUG_PROC_DESC_NO_SESSION_ID = 16;
		public const uint32 DEBUG_PROC_DESC_NO_USER_NAME = 32;
		public const uint32 DEBUG_PROC_DESC_WITH_PACKAGEFAMILY = 64;
		public const uint32 DEBUG_ATTACH_DEFAULT = 0;
		public const uint32 DEBUG_ATTACH_NONINVASIVE = 1;
		public const uint32 DEBUG_ATTACH_EXISTING = 2;
		public const uint32 DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND = 4;
		public const uint32 DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK = 8;
		public const uint32 DEBUG_ATTACH_INVASIVE_RESUME_PROCESS = 16;
		public const uint32 DEBUG_ATTACH_NONINVASIVE_ALLOW_PARTIAL = 32;
		public const uint32 DEBUG_ECREATE_PROCESS_DEFAULT = 0;
		public const uint32 DEBUG_ECREATE_PROCESS_INHERIT_HANDLES = 1;
		public const uint32 DEBUG_ECREATE_PROCESS_USE_VERIFIER_FLAGS = 2;
		public const uint32 DEBUG_ECREATE_PROCESS_USE_IMPLICIT_COMMAND_LINE = 4;
		public const uint32 DEBUG_PROCESS_DETACH_ON_EXIT = 1;
		public const uint32 DEBUG_PROCESS_ONLY_THIS_PROCESS = 2;
		public const uint32 DEBUG_CONNECT_SESSION_DEFAULT = 0;
		public const uint32 DEBUG_CONNECT_SESSION_NO_VERSION = 1;
		public const uint32 DEBUG_CONNECT_SESSION_NO_ANNOUNCE = 2;
		public const uint32 DEBUG_SERVERS_DEBUGGER = 1;
		public const uint32 DEBUG_SERVERS_PROCESS = 2;
		public const uint32 DEBUG_SERVERS_ALL = 3;
		public const uint32 DEBUG_END_PASSIVE = 0;
		public const uint32 DEBUG_END_ACTIVE_TERMINATE = 1;
		public const uint32 DEBUG_END_ACTIVE_DETACH = 2;
		public const uint32 DEBUG_END_REENTRANT = 3;
		public const uint32 DEBUG_END_DISCONNECT = 4;
		public const uint32 DEBUG_OUTPUT_NORMAL = 1;
		public const uint32 DEBUG_OUTPUT_ERROR = 2;
		public const uint32 DEBUG_OUTPUT_WARNING = 4;
		public const uint32 DEBUG_OUTPUT_VERBOSE = 8;
		public const uint32 DEBUG_OUTPUT_PROMPT = 16;
		public const uint32 DEBUG_OUTPUT_PROMPT_REGISTERS = 32;
		public const uint32 DEBUG_OUTPUT_EXTENSION_WARNING = 64;
		public const uint32 DEBUG_OUTPUT_DEBUGGEE = 128;
		public const uint32 DEBUG_OUTPUT_DEBUGGEE_PROMPT = 256;
		public const uint32 DEBUG_OUTPUT_SYMBOLS = 512;
		public const uint32 DEBUG_OUTPUT_STATUS = 1024;
		public const uint32 DEBUG_OUTPUT_XML = 2048;
		public const uint32 DEBUG_IOUTPUT_KD_PROTOCOL = 2147483648;
		public const uint32 DEBUG_IOUTPUT_REMOTING = 1073741824;
		public const uint32 DEBUG_IOUTPUT_BREAKPOINT = 536870912;
		public const uint32 DEBUG_IOUTPUT_EVENT = 268435456;
		public const uint32 DEBUG_IOUTPUT_ADDR_TRANSLATE = 134217728;
		public const uint32 DEBUG_OUTPUT_IDENTITY_DEFAULT = 0;
		public const uint32 DEBUG_CLIENT_UNKNOWN = 0;
		public const uint32 DEBUG_CLIENT_VSINT = 1;
		public const uint32 DEBUG_CLIENT_NTSD = 2;
		public const uint32 DEBUG_CLIENT_NTKD = 3;
		public const uint32 DEBUG_CLIENT_CDB = 4;
		public const uint32 DEBUG_CLIENT_KD = 5;
		public const uint32 DEBUG_CLIENT_WINDBG = 6;
		public const uint32 DEBUG_CLIENT_WINIDE = 7;
		public const uint32 DEBUG_FORMAT_DEFAULT = 0;
		public const uint32 DEBUG_FORMAT_CAB_SECONDARY_ALL_IMAGES = 268435456;
		public const uint32 DEBUG_FORMAT_WRITE_CAB = 536870912;
		public const uint32 DEBUG_FORMAT_CAB_SECONDARY_FILES = 1073741824;
		public const uint32 DEBUG_FORMAT_NO_OVERWRITE = 2147483648;
		public const uint32 DEBUG_FORMAT_USER_SMALL_FULL_MEMORY = 1;
		public const uint32 DEBUG_FORMAT_USER_SMALL_HANDLE_DATA = 2;
		public const uint32 DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES = 4;
		public const uint32 DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY = 8;
		public const uint32 DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS = 16;
		public const uint32 DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY = 32;
		public const uint32 DEBUG_FORMAT_USER_SMALL_FILTER_PATHS = 64;
		public const uint32 DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA = 128;
		public const uint32 DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY = 256;
		public const uint32 DEBUG_FORMAT_USER_SMALL_NO_OPTIONAL_DATA = 512;
		public const uint32 DEBUG_FORMAT_USER_SMALL_FULL_MEMORY_INFO = 1024;
		public const uint32 DEBUG_FORMAT_USER_SMALL_THREAD_INFO = 2048;
		public const uint32 DEBUG_FORMAT_USER_SMALL_CODE_SEGMENTS = 4096;
		public const uint32 DEBUG_FORMAT_USER_SMALL_NO_AUXILIARY_STATE = 8192;
		public const uint32 DEBUG_FORMAT_USER_SMALL_FULL_AUXILIARY_STATE = 16384;
		public const uint32 DEBUG_FORMAT_USER_SMALL_MODULE_HEADERS = 32768;
		public const uint32 DEBUG_FORMAT_USER_SMALL_FILTER_TRIAGE = 65536;
		public const uint32 DEBUG_FORMAT_USER_SMALL_ADD_AVX_XSTATE_CONTEXT = 131072;
		public const uint32 DEBUG_FORMAT_USER_SMALL_IPT_TRACE = 262144;
		public const uint32 DEBUG_FORMAT_USER_SMALL_IGNORE_INACCESSIBLE_MEM = 134217728;
		public const uint32 DEBUG_FORMAT_USER_SMALL_SCAN_PARTIAL_PAGES = 268435456;
		public const uint32 DEBUG_DUMP_FILE_BASE = 4294967295;
		public const uint32 DEBUG_DUMP_FILE_PAGE_FILE_DUMP = 0;
		public const uint32 DEBUG_DUMP_FILE_LOAD_FAILED_INDEX = 4294967295;
		public const uint32 DEBUG_DUMP_FILE_ORIGINAL_CAB_INDEX = 4294967294;
		public const uint32 DEBUG_STATUS_NO_CHANGE = 0;
		public const uint32 DEBUG_STATUS_GO = 1;
		public const uint32 DEBUG_STATUS_GO_HANDLED = 2;
		public const uint32 DEBUG_STATUS_GO_NOT_HANDLED = 3;
		public const uint32 DEBUG_STATUS_STEP_OVER = 4;
		public const uint32 DEBUG_STATUS_STEP_INTO = 5;
		public const uint32 DEBUG_STATUS_BREAK = 6;
		public const uint32 DEBUG_STATUS_NO_DEBUGGEE = 7;
		public const uint32 DEBUG_STATUS_STEP_BRANCH = 8;
		public const uint32 DEBUG_STATUS_IGNORE_EVENT = 9;
		public const uint32 DEBUG_STATUS_RESTART_REQUESTED = 10;
		public const uint32 DEBUG_STATUS_REVERSE_GO = 11;
		public const uint32 DEBUG_STATUS_REVERSE_STEP_BRANCH = 12;
		public const uint32 DEBUG_STATUS_REVERSE_STEP_OVER = 13;
		public const uint32 DEBUG_STATUS_REVERSE_STEP_INTO = 14;
		public const uint32 DEBUG_STATUS_OUT_OF_SYNC = 15;
		public const uint32 DEBUG_STATUS_WAIT_INPUT = 16;
		public const uint32 DEBUG_STATUS_TIMEOUT = 17;
		public const uint32 DEBUG_STATUS_MASK = 31;
		public const uint64 DEBUG_STATUS_INSIDE_WAIT = 4294967296uL;
		public const uint64 DEBUG_STATUS_WAIT_TIMEOUT = 8589934592uL;
		public const uint32 DEBUG_OUTCTL_THIS_CLIENT = 0;
		public const uint32 DEBUG_OUTCTL_ALL_CLIENTS = 1;
		public const uint32 DEBUG_OUTCTL_ALL_OTHER_CLIENTS = 2;
		public const uint32 DEBUG_OUTCTL_IGNORE = 3;
		public const uint32 DEBUG_OUTCTL_LOG_ONLY = 4;
		public const uint32 DEBUG_OUTCTL_SEND_MASK = 7;
		public const uint32 DEBUG_OUTCTL_NOT_LOGGED = 8;
		public const uint32 DEBUG_OUTCTL_OVERRIDE_MASK = 16;
		public const uint32 DEBUG_OUTCTL_DML = 32;
		public const uint32 DEBUG_OUTCTL_AMBIENT_DML = 4294967294;
		public const uint32 DEBUG_OUTCTL_AMBIENT_TEXT = 4294967295;
		public const uint32 DEBUG_OUTCTL_AMBIENT = 4294967295;
		public const uint32 DEBUG_INTERRUPT_ACTIVE = 0;
		public const uint32 DEBUG_INTERRUPT_PASSIVE = 1;
		public const uint32 DEBUG_INTERRUPT_EXIT = 2;
		public const uint32 DEBUG_CURRENT_DEFAULT = 15;
		public const uint32 DEBUG_CURRENT_SYMBOL = 1;
		public const uint32 DEBUG_CURRENT_DISASM = 2;
		public const uint32 DEBUG_CURRENT_REGISTERS = 4;
		public const uint32 DEBUG_CURRENT_SOURCE_LINE = 8;
		public const uint32 DEBUG_DISASM_EFFECTIVE_ADDRESS = 1;
		public const uint32 DEBUG_DISASM_MATCHING_SYMBOLS = 2;
		public const uint32 DEBUG_DISASM_SOURCE_LINE_NUMBER = 4;
		public const uint32 DEBUG_DISASM_SOURCE_FILE_NAME = 8;
		public const uint32 DEBUG_LEVEL_SOURCE = 0;
		public const uint32 DEBUG_LEVEL_ASSEMBLY = 1;
		public const uint32 DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION = 1;
		public const uint32 DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS = 2;
		public const uint32 DEBUG_ENGOPT_ALLOW_NETWORK_PATHS = 4;
		public const uint32 DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS = 8;
		public const uint32 DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS = 16;
		public const uint32 DEBUG_ENGOPT_INITIAL_BREAK = 32;
		public const uint32 DEBUG_ENGOPT_INITIAL_MODULE_BREAK = 64;
		public const uint32 DEBUG_ENGOPT_FINAL_BREAK = 128;
		public const uint32 DEBUG_ENGOPT_NO_EXECUTE_REPEAT = 256;
		public const uint32 DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION = 512;
		public const uint32 DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS = 1024;
		public const uint32 DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS = 2048;
		public const uint32 DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS = 4096;
		public const uint32 DEBUG_ENGOPT_KD_QUIET_MODE = 8192;
		public const uint32 DEBUG_ENGOPT_DISABLE_MANAGED_SUPPORT = 16384;
		public const uint32 DEBUG_ENGOPT_DISABLE_MODULE_SYMBOL_LOAD = 32768;
		public const uint32 DEBUG_ENGOPT_DISABLE_EXECUTION_COMMANDS = 65536;
		public const uint32 DEBUG_ENGOPT_DISALLOW_IMAGE_FILE_MAPPING = 131072;
		public const uint32 DEBUG_ENGOPT_PREFER_DML = 262144;
		public const uint32 DEBUG_ENGOPT_DISABLESQM = 524288;
		public const uint32 DEBUG_ENGOPT_DISABLE_STEPLINES_OPTIONS = 2097152;
		public const uint32 DEBUG_ENGOPT_DEBUGGING_SENSITIVE_DATA = 4194304;
		public const uint32 DEBUG_ENGOPT_PREFER_TRACE_FILES = 8388608;
		public const uint32 DEBUG_ENGOPT_ALL = 15728639;
		public const uint32 DEBUG_ANY_ID = 4294967295;
		public const uint32 DBG_FRAME_DEFAULT = 0;
		public const uint32 DBG_FRAME_IGNORE_INLINE = 4294967295;
		public const uint32 STACK_FRAME_TYPE_INIT = 0;
		public const uint32 STACK_FRAME_TYPE_STACK = 1;
		public const uint32 STACK_FRAME_TYPE_INLINE = 2;
		public const uint32 STACK_FRAME_TYPE_RA = 128;
		public const uint32 STACK_FRAME_TYPE_IGNORE = 255;
		public const uint32 DEBUG_STACK_ARGUMENTS = 1;
		public const uint32 DEBUG_STACK_FUNCTION_INFO = 2;
		public const uint32 DEBUG_STACK_SOURCE_LINE = 4;
		public const uint32 DEBUG_STACK_FRAME_ADDRESSES = 8;
		public const uint32 DEBUG_STACK_COLUMN_NAMES = 16;
		public const uint32 DEBUG_STACK_NONVOLATILE_REGISTERS = 32;
		public const uint32 DEBUG_STACK_FRAME_NUMBERS = 64;
		public const uint32 DEBUG_STACK_PARAMETERS = 128;
		public const uint32 DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY = 256;
		public const uint32 DEBUG_STACK_FRAME_MEMORY_USAGE = 512;
		public const uint32 DEBUG_STACK_PARAMETERS_NEWLINE = 1024;
		public const uint32 DEBUG_STACK_DML = 2048;
		public const uint32 DEBUG_STACK_FRAME_OFFSETS = 4096;
		public const uint32 DEBUG_STACK_PROVIDER = 8192;
		public const uint32 DEBUG_STACK_FRAME_ARCH = 16384;
		public const uint32 DEBUG_CLASS_UNINITIALIZED = 0;
		public const uint32 DEBUG_CLASS_KERNEL = 1;
		public const uint32 DEBUG_CLASS_USER_WINDOWS = 2;
		public const uint32 DEBUG_CLASS_IMAGE_FILE = 3;
		public const uint32 DEBUG_DUMP_SMALL = 1024;
		public const uint32 DEBUG_DUMP_DEFAULT = 1025;
		public const uint32 DEBUG_DUMP_FULL = 1026;
		public const uint32 DEBUG_DUMP_IMAGE_FILE = 1027;
		public const uint32 DEBUG_DUMP_TRACE_LOG = 1028;
		public const uint32 DEBUG_DUMP_WINDOWS_CE = 1029;
		public const uint32 DEBUG_DUMP_ACTIVE = 1030;
		public const uint32 DEBUG_KERNEL_CONNECTION = 0;
		public const uint32 DEBUG_KERNEL_LOCAL = 1;
		public const uint32 DEBUG_KERNEL_EXDI_DRIVER = 2;
		public const uint32 DEBUG_KERNEL_IDNA = 3;
		public const uint32 DEBUG_KERNEL_INSTALL_DRIVER = 4;
		public const uint32 DEBUG_KERNEL_REPT = 5;
		public const uint32 DEBUG_KERNEL_SMALL_DUMP = 1024;
		public const uint32 DEBUG_KERNEL_DUMP = 1025;
		public const uint32 DEBUG_KERNEL_ACTIVE_DUMP = 1030;
		public const uint32 DEBUG_KERNEL_FULL_DUMP = 1026;
		public const uint32 DEBUG_KERNEL_TRACE_LOG = 1028;
		public const uint32 DEBUG_USER_WINDOWS_PROCESS = 0;
		public const uint32 DEBUG_USER_WINDOWS_PROCESS_SERVER = 1;
		public const uint32 DEBUG_USER_WINDOWS_IDNA = 2;
		public const uint32 DEBUG_USER_WINDOWS_REPT = 3;
		public const uint32 DEBUG_USER_WINDOWS_SMALL_DUMP = 1024;
		public const uint32 DEBUG_USER_WINDOWS_DUMP = 1025;
		public const uint32 DEBUG_USER_WINDOWS_DUMP_WINDOWS_CE = 1029;
		public const uint32 DEBUG_EXTENSION_AT_ENGINE = 0;
		public const uint32 DEBUG_EXECUTE_DEFAULT = 0;
		public const uint32 DEBUG_EXECUTE_ECHO = 1;
		public const uint32 DEBUG_EXECUTE_NOT_LOGGED = 2;
		public const uint32 DEBUG_EXECUTE_NO_REPEAT = 4;
		public const uint32 DEBUG_EXECUTE_USER_TYPED = 8;
		public const uint32 DEBUG_EXECUTE_USER_CLICKED = 16;
		public const uint32 DEBUG_EXECUTE_EXTENSION = 32;
		public const uint32 DEBUG_EXECUTE_INTERNAL = 64;
		public const uint32 DEBUG_EXECUTE_SCRIPT = 128;
		public const uint32 DEBUG_EXECUTE_TOOLBAR = 256;
		public const uint32 DEBUG_EXECUTE_MENU = 512;
		public const uint32 DEBUG_EXECUTE_HOTKEY = 1024;
		public const uint32 DEBUG_EXECUTE_EVENT = 2048;
		public const uint32 DEBUG_FILTER_CREATE_THREAD = 0;
		public const uint32 DEBUG_FILTER_EXIT_THREAD = 1;
		public const uint32 DEBUG_FILTER_CREATE_PROCESS = 2;
		public const uint32 DEBUG_FILTER_EXIT_PROCESS = 3;
		public const uint32 DEBUG_FILTER_LOAD_MODULE = 4;
		public const uint32 DEBUG_FILTER_UNLOAD_MODULE = 5;
		public const uint32 DEBUG_FILTER_SYSTEM_ERROR = 6;
		public const uint32 DEBUG_FILTER_INITIAL_BREAKPOINT = 7;
		public const uint32 DEBUG_FILTER_INITIAL_MODULE_LOAD = 8;
		public const uint32 DEBUG_FILTER_DEBUGGEE_OUTPUT = 9;
		public const uint32 DEBUG_FILTER_BREAK = 0;
		public const uint32 DEBUG_FILTER_SECOND_CHANCE_BREAK = 1;
		public const uint32 DEBUG_FILTER_OUTPUT = 2;
		public const uint32 DEBUG_FILTER_IGNORE = 3;
		public const uint32 DEBUG_FILTER_REMOVE = 4;
		public const uint32 DEBUG_FILTER_GO_HANDLED = 0;
		public const uint32 DEBUG_FILTER_GO_NOT_HANDLED = 1;
		public const uint32 DEBUG_WAIT_DEFAULT = 0;
		public const uint32 DEBUG_VALUE_INVALID = 0;
		public const uint32 DEBUG_VALUE_INT8 = 1;
		public const uint32 DEBUG_VALUE_INT16 = 2;
		public const uint32 DEBUG_VALUE_INT32 = 3;
		public const uint32 DEBUG_VALUE_INT64 = 4;
		public const uint32 DEBUG_VALUE_FLOAT32 = 5;
		public const uint32 DEBUG_VALUE_FLOAT64 = 6;
		public const uint32 DEBUG_VALUE_FLOAT80 = 7;
		public const uint32 DEBUG_VALUE_FLOAT82 = 8;
		public const uint32 DEBUG_VALUE_FLOAT128 = 9;
		public const uint32 DEBUG_VALUE_VECTOR64 = 10;
		public const uint32 DEBUG_VALUE_VECTOR128 = 11;
		public const uint32 DEBUG_VALUE_TYPES = 12;
		public const uint32 DEBUG_OUT_TEXT_REPL_DEFAULT = 0;
		public const uint32 DEBUG_ASMOPT_DEFAULT = 0;
		public const uint32 DEBUG_ASMOPT_VERBOSE = 1;
		public const uint32 DEBUG_ASMOPT_NO_CODE_BYTES = 2;
		public const uint32 DEBUG_ASMOPT_IGNORE_OUTPUT_WIDTH = 4;
		public const uint32 DEBUG_ASMOPT_SOURCE_LINE_NUMBER = 8;
		public const uint32 DEBUG_EXPR_MASM = 0;
		public const uint32 DEBUG_EXPR_CPLUSPLUS = 1;
		public const uint32 DEBUG_EINDEX_NAME = 0;
		public const uint32 DEBUG_EINDEX_FROM_START = 0;
		public const uint32 DEBUG_EINDEX_FROM_END = 1;
		public const uint32 DEBUG_EINDEX_FROM_CURRENT = 2;
		public const uint32 DEBUG_LOG_DEFAULT = 0;
		public const uint32 DEBUG_LOG_APPEND = 1;
		public const uint32 DEBUG_LOG_UNICODE = 2;
		public const uint32 DEBUG_LOG_DML = 4;
		public const uint32 DEBUG_SYSVERSTR_SERVICE_PACK = 0;
		public const uint32 DEBUG_SYSVERSTR_BUILD = 1;
		public const uint32 DEBUG_MANAGED_DISABLED = 0;
		public const uint32 DEBUG_MANAGED_ALLOWED = 1;
		public const uint32 DEBUG_MANAGED_DLL_LOADED = 2;
		public const uint32 DEBUG_MANSTR_NONE = 0;
		public const uint32 DEBUG_MANSTR_LOADED_SUPPORT_DLL = 1;
		public const uint32 DEBUG_MANSTR_LOAD_STATUS = 2;
		public const uint32 DEBUG_MANRESET_DEFAULT = 0;
		public const uint32 DEBUG_MANRESET_LOAD_DLL = 1;
		public const uint32 DEBUG_EXEC_FLAGS_NONBLOCK = 1;
		public const uint32 DEBUG_DATA_SPACE_VIRTUAL = 0;
		public const uint32 DEBUG_DATA_SPACE_PHYSICAL = 1;
		public const uint32 DEBUG_DATA_SPACE_CONTROL = 2;
		public const uint32 DEBUG_DATA_SPACE_IO = 3;
		public const uint32 DEBUG_DATA_SPACE_MSR = 4;
		public const uint32 DEBUG_DATA_SPACE_BUS_DATA = 5;
		public const uint32 DEBUG_DATA_SPACE_DEBUGGER_DATA = 6;
		public const uint32 DEBUG_DATA_SPACE_COUNT = 7;
		public const uint32 DEBUG_DATA_KernBase = 24;
		public const uint32 DEBUG_DATA_BreakpointWithStatusAddr = 32;
		public const uint32 DEBUG_DATA_SavedContextAddr = 40;
		public const uint32 DEBUG_DATA_KiCallUserModeAddr = 56;
		public const uint32 DEBUG_DATA_KeUserCallbackDispatcherAddr = 64;
		public const uint32 DEBUG_DATA_PsLoadedModuleListAddr = 72;
		public const uint32 DEBUG_DATA_PsActiveProcessHeadAddr = 80;
		public const uint32 DEBUG_DATA_PspCidTableAddr = 88;
		public const uint32 DEBUG_DATA_ExpSystemResourcesListAddr = 96;
		public const uint32 DEBUG_DATA_ExpPagedPoolDescriptorAddr = 104;
		public const uint32 DEBUG_DATA_ExpNumberOfPagedPoolsAddr = 112;
		public const uint32 DEBUG_DATA_KeTimeIncrementAddr = 120;
		public const uint32 DEBUG_DATA_KeBugCheckCallbackListHeadAddr = 128;
		public const uint32 DEBUG_DATA_KiBugcheckDataAddr = 136;
		public const uint32 DEBUG_DATA_IopErrorLogListHeadAddr = 144;
		public const uint32 DEBUG_DATA_ObpRootDirectoryObjectAddr = 152;
		public const uint32 DEBUG_DATA_ObpTypeObjectTypeAddr = 160;
		public const uint32 DEBUG_DATA_MmSystemCacheStartAddr = 168;
		public const uint32 DEBUG_DATA_MmSystemCacheEndAddr = 176;
		public const uint32 DEBUG_DATA_MmSystemCacheWsAddr = 184;
		public const uint32 DEBUG_DATA_MmPfnDatabaseAddr = 192;
		public const uint32 DEBUG_DATA_MmSystemPtesStartAddr = 200;
		public const uint32 DEBUG_DATA_MmSystemPtesEndAddr = 208;
		public const uint32 DEBUG_DATA_MmSubsectionBaseAddr = 216;
		public const uint32 DEBUG_DATA_MmNumberOfPagingFilesAddr = 224;
		public const uint32 DEBUG_DATA_MmLowestPhysicalPageAddr = 232;
		public const uint32 DEBUG_DATA_MmHighestPhysicalPageAddr = 240;
		public const uint32 DEBUG_DATA_MmNumberOfPhysicalPagesAddr = 248;
		public const uint32 DEBUG_DATA_MmMaximumNonPagedPoolInBytesAddr = 256;
		public const uint32 DEBUG_DATA_MmNonPagedSystemStartAddr = 264;
		public const uint32 DEBUG_DATA_MmNonPagedPoolStartAddr = 272;
		public const uint32 DEBUG_DATA_MmNonPagedPoolEndAddr = 280;
		public const uint32 DEBUG_DATA_MmPagedPoolStartAddr = 288;
		public const uint32 DEBUG_DATA_MmPagedPoolEndAddr = 296;
		public const uint32 DEBUG_DATA_MmPagedPoolInformationAddr = 304;
		public const uint32 DEBUG_DATA_MmPageSize = 312;
		public const uint32 DEBUG_DATA_MmSizeOfPagedPoolInBytesAddr = 320;
		public const uint32 DEBUG_DATA_MmTotalCommitLimitAddr = 328;
		public const uint32 DEBUG_DATA_MmTotalCommittedPagesAddr = 336;
		public const uint32 DEBUG_DATA_MmSharedCommitAddr = 344;
		public const uint32 DEBUG_DATA_MmDriverCommitAddr = 352;
		public const uint32 DEBUG_DATA_MmProcessCommitAddr = 360;
		public const uint32 DEBUG_DATA_MmPagedPoolCommitAddr = 368;
		public const uint32 DEBUG_DATA_MmExtendedCommitAddr = 376;
		public const uint32 DEBUG_DATA_MmZeroedPageListHeadAddr = 384;
		public const uint32 DEBUG_DATA_MmFreePageListHeadAddr = 392;
		public const uint32 DEBUG_DATA_MmStandbyPageListHeadAddr = 400;
		public const uint32 DEBUG_DATA_MmModifiedPageListHeadAddr = 408;
		public const uint32 DEBUG_DATA_MmModifiedNoWritePageListHeadAddr = 416;
		public const uint32 DEBUG_DATA_MmAvailablePagesAddr = 424;
		public const uint32 DEBUG_DATA_MmResidentAvailablePagesAddr = 432;
		public const uint32 DEBUG_DATA_PoolTrackTableAddr = 440;
		public const uint32 DEBUG_DATA_NonPagedPoolDescriptorAddr = 448;
		public const uint32 DEBUG_DATA_MmHighestUserAddressAddr = 456;
		public const uint32 DEBUG_DATA_MmSystemRangeStartAddr = 464;
		public const uint32 DEBUG_DATA_MmUserProbeAddressAddr = 472;
		public const uint32 DEBUG_DATA_KdPrintCircularBufferAddr = 480;
		public const uint32 DEBUG_DATA_KdPrintCircularBufferEndAddr = 488;
		public const uint32 DEBUG_DATA_KdPrintWritePointerAddr = 496;
		public const uint32 DEBUG_DATA_KdPrintRolloverCountAddr = 504;
		public const uint32 DEBUG_DATA_MmLoadedUserImageListAddr = 512;
		public const uint32 DEBUG_DATA_NtBuildLabAddr = 520;
		public const uint32 DEBUG_DATA_KiNormalSystemCall = 528;
		public const uint32 DEBUG_DATA_KiProcessorBlockAddr = 536;
		public const uint32 DEBUG_DATA_MmUnloadedDriversAddr = 544;
		public const uint32 DEBUG_DATA_MmLastUnloadedDriverAddr = 552;
		public const uint32 DEBUG_DATA_MmTriageActionTakenAddr = 560;
		public const uint32 DEBUG_DATA_MmSpecialPoolTagAddr = 568;
		public const uint32 DEBUG_DATA_KernelVerifierAddr = 576;
		public const uint32 DEBUG_DATA_MmVerifierDataAddr = 584;
		public const uint32 DEBUG_DATA_MmAllocatedNonPagedPoolAddr = 592;
		public const uint32 DEBUG_DATA_MmPeakCommitmentAddr = 600;
		public const uint32 DEBUG_DATA_MmTotalCommitLimitMaximumAddr = 608;
		public const uint32 DEBUG_DATA_CmNtCSDVersionAddr = 616;
		public const uint32 DEBUG_DATA_MmPhysicalMemoryBlockAddr = 624;
		public const uint32 DEBUG_DATA_MmSessionBase = 632;
		public const uint32 DEBUG_DATA_MmSessionSize = 640;
		public const uint32 DEBUG_DATA_MmSystemParentTablePage = 648;
		public const uint32 DEBUG_DATA_MmVirtualTranslationBase = 656;
		public const uint32 DEBUG_DATA_OffsetKThreadNextProcessor = 664;
		public const uint32 DEBUG_DATA_OffsetKThreadTeb = 666;
		public const uint32 DEBUG_DATA_OffsetKThreadKernelStack = 668;
		public const uint32 DEBUG_DATA_OffsetKThreadInitialStack = 670;
		public const uint32 DEBUG_DATA_OffsetKThreadApcProcess = 672;
		public const uint32 DEBUG_DATA_OffsetKThreadState = 674;
		public const uint32 DEBUG_DATA_OffsetKThreadBStore = 676;
		public const uint32 DEBUG_DATA_OffsetKThreadBStoreLimit = 678;
		public const uint32 DEBUG_DATA_SizeEProcess = 680;
		public const uint32 DEBUG_DATA_OffsetEprocessPeb = 682;
		public const uint32 DEBUG_DATA_OffsetEprocessParentCID = 684;
		public const uint32 DEBUG_DATA_OffsetEprocessDirectoryTableBase = 686;
		public const uint32 DEBUG_DATA_SizePrcb = 688;
		public const uint32 DEBUG_DATA_OffsetPrcbDpcRoutine = 690;
		public const uint32 DEBUG_DATA_OffsetPrcbCurrentThread = 692;
		public const uint32 DEBUG_DATA_OffsetPrcbMhz = 694;
		public const uint32 DEBUG_DATA_OffsetPrcbCpuType = 696;
		public const uint32 DEBUG_DATA_OffsetPrcbVendorString = 698;
		public const uint32 DEBUG_DATA_OffsetPrcbProcessorState = 700;
		public const uint32 DEBUG_DATA_OffsetPrcbNumber = 702;
		public const uint32 DEBUG_DATA_SizeEThread = 704;
		public const uint32 DEBUG_DATA_KdPrintCircularBufferPtrAddr = 712;
		public const uint32 DEBUG_DATA_KdPrintBufferSizeAddr = 720;
		public const uint32 DEBUG_DATA_MmBadPagesDetected = 800;
		public const uint32 DEBUG_DATA_EtwpDebuggerData = 816;
		public const uint32 DEBUG_DATA_PteBase = 864;
		public const uint32 DEBUG_DATA_PaeEnabled = 100000;
		public const uint32 DEBUG_DATA_SharedUserData = 100008;
		public const uint32 DEBUG_DATA_ProductType = 100016;
		public const uint32 DEBUG_DATA_SuiteMask = 100024;
		public const uint32 DEBUG_DATA_DumpWriterStatus = 100032;
		public const uint32 DEBUG_DATA_DumpFormatVersion = 100040;
		public const uint32 DEBUG_DATA_DumpWriterVersion = 100048;
		public const uint32 DEBUG_DATA_DumpPowerState = 100056;
		public const uint32 DEBUG_DATA_DumpMmStorage = 100064;
		public const uint32 DEBUG_DATA_DumpAttributes = 100072;
		public const uint32 DEBUG_DATA_KPCR_OFFSET = 0;
		public const uint32 DEBUG_DATA_KPRCB_OFFSET = 1;
		public const uint32 DEBUG_DATA_KTHREAD_OFFSET = 2;
		public const uint32 DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET = 3;
		public const uint32 DEBUG_DATA_PROCESSOR_IDENTIFICATION = 4;
		public const uint32 DEBUG_DATA_PROCESSOR_SPEED = 5;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_BASIC = 0;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_TYPE_NAME = 1;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME = 2;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT = 3;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE = 4;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE = 5;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_MINI_THREAD_1 = 6;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_1 = 7;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_2 = 8;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_PER_HANDLE_OPERATIONS = 9;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_ALL_HANDLE_OPERATIONS = 10;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_1 = 11;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_2 = 12;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_MINI_EVENT_1 = 13;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_MINI_SECTION_1 = 14;
		public const uint32 DEBUG_HANDLE_DATA_TYPE_MINI_SEMAPHORE_1 = 15;
		public const uint32 DEBUG_OFFSINFO_VIRTUAL_SOURCE = 1;
		public const uint32 DEBUG_VSOURCE_INVALID = 0;
		public const uint32 DEBUG_VSOURCE_DEBUGGEE = 1;
		public const uint32 DEBUG_VSOURCE_MAPPED_IMAGE = 2;
		public const uint32 DEBUG_VSOURCE_DUMP_WITHOUT_MEMINFO = 3;
		public const uint32 DEBUG_VSEARCH_DEFAULT = 0;
		public const uint32 DEBUG_VSEARCH_WRITABLE_ONLY = 1;
		public const uint32 DEBUG_PHYSICAL_DEFAULT = 0;
		public const uint32 DEBUG_PHYSICAL_CACHED = 1;
		public const uint32 DEBUG_PHYSICAL_UNCACHED = 2;
		public const uint32 DEBUG_PHYSICAL_WRITE_COMBINED = 3;
		public const uint32 DEBUG_EVENT_BREAKPOINT = 1;
		public const uint32 DEBUG_EVENT_EXCEPTION = 2;
		public const uint32 DEBUG_EVENT_CREATE_THREAD = 4;
		public const uint32 DEBUG_EVENT_EXIT_THREAD = 8;
		public const uint32 DEBUG_EVENT_CREATE_PROCESS = 16;
		public const uint32 DEBUG_EVENT_EXIT_PROCESS = 32;
		public const uint32 DEBUG_EVENT_LOAD_MODULE = 64;
		public const uint32 DEBUG_EVENT_UNLOAD_MODULE = 128;
		public const uint32 DEBUG_EVENT_SYSTEM_ERROR = 256;
		public const uint32 DEBUG_EVENT_SESSION_STATUS = 512;
		public const uint32 DEBUG_EVENT_CHANGE_DEBUGGEE_STATE = 1024;
		public const uint32 DEBUG_EVENT_CHANGE_ENGINE_STATE = 2048;
		public const uint32 DEBUG_EVENT_CHANGE_SYMBOL_STATE = 4096;
		public const uint32 DEBUG_EVENT_SERVICE_EXCEPTION = 8192;
		public const uint32 DEBUG_SESSION_ACTIVE = 0;
		public const uint32 DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE = 1;
		public const uint32 DEBUG_SESSION_END_SESSION_ACTIVE_DETACH = 2;
		public const uint32 DEBUG_SESSION_END_SESSION_PASSIVE = 3;
		public const uint32 DEBUG_SESSION_END = 4;
		public const uint32 DEBUG_SESSION_REBOOT = 5;
		public const uint32 DEBUG_SESSION_HIBERNATE = 6;
		public const uint32 DEBUG_SESSION_FAILURE = 7;
		public const uint32 DEBUG_CDS_ALL = 4294967295;
		public const uint32 DEBUG_CDS_REGISTERS = 1;
		public const uint32 DEBUG_CDS_DATA = 2;
		public const uint32 DEBUG_CDS_REFRESH = 4;
		public const uint32 DEBUG_CDS_REFRESH_EVALUATE = 1;
		public const uint32 DEBUG_CDS_REFRESH_EXECUTE = 2;
		public const uint32 DEBUG_CDS_REFRESH_EXECUTECOMMANDFILE = 3;
		public const uint32 DEBUG_CDS_REFRESH_ADDBREAKPOINT = 4;
		public const uint32 DEBUG_CDS_REFRESH_REMOVEBREAKPOINT = 5;
		public const uint32 DEBUG_CDS_REFRESH_WRITEVIRTUAL = 6;
		public const uint32 DEBUG_CDS_REFRESH_WRITEVIRTUALUNCACHED = 7;
		public const uint32 DEBUG_CDS_REFRESH_WRITEPHYSICAL = 8;
		public const uint32 DEBUG_CDS_REFRESH_WRITEPHYSICAL2 = 9;
		public const uint32 DEBUG_CDS_REFRESH_SETVALUE = 10;
		public const uint32 DEBUG_CDS_REFRESH_SETVALUE2 = 11;
		public const uint32 DEBUG_CDS_REFRESH_SETSCOPE = 12;
		public const uint32 DEBUG_CDS_REFRESH_SETSCOPEFRAMEBYINDEX = 13;
		public const uint32 DEBUG_CDS_REFRESH_SETSCOPEFROMJITDEBUGINFO = 14;
		public const uint32 DEBUG_CDS_REFRESH_SETSCOPEFROMSTOREDEVENT = 15;
		public const uint32 DEBUG_CDS_REFRESH_INLINESTEP = 16;
		public const uint32 DEBUG_CDS_REFRESH_INLINESTEP_PSEUDO = 17;
		public const uint32 DEBUG_CES_ALL = 4294967295;
		public const uint32 DEBUG_CES_CURRENT_THREAD = 1;
		public const uint32 DEBUG_CES_EFFECTIVE_PROCESSOR = 2;
		public const uint32 DEBUG_CES_BREAKPOINTS = 4;
		public const uint32 DEBUG_CES_CODE_LEVEL = 8;
		public const uint32 DEBUG_CES_EXECUTION_STATUS = 16;
		public const uint32 DEBUG_CES_ENGINE_OPTIONS = 32;
		public const uint32 DEBUG_CES_LOG_FILE = 64;
		public const uint32 DEBUG_CES_RADIX = 128;
		public const uint32 DEBUG_CES_EVENT_FILTERS = 256;
		public const uint32 DEBUG_CES_PROCESS_OPTIONS = 512;
		public const uint32 DEBUG_CES_EXTENSIONS = 1024;
		public const uint32 DEBUG_CES_SYSTEMS = 2048;
		public const uint32 DEBUG_CES_ASSEMBLY_OPTIONS = 4096;
		public const uint32 DEBUG_CES_EXPRESSION_SYNTAX = 8192;
		public const uint32 DEBUG_CES_TEXT_REPLACEMENTS = 16384;
		public const uint32 DEBUG_CSS_ALL = 4294967295;
		public const uint32 DEBUG_CSS_LOADS = 1;
		public const uint32 DEBUG_CSS_UNLOADS = 2;
		public const uint32 DEBUG_CSS_SCOPE = 4;
		public const uint32 DEBUG_CSS_PATHS = 8;
		public const uint32 DEBUG_CSS_SYMBOL_OPTIONS = 16;
		public const uint32 DEBUG_CSS_TYPE_OPTIONS = 32;
		public const uint32 DEBUG_CSS_COLLAPSE_CHILDREN = 64;
		public const uint32 DEBUG_OUTCBI_EXPLICIT_FLUSH = 1;
		public const uint32 DEBUG_OUTCBI_TEXT = 2;
		public const uint32 DEBUG_OUTCBI_DML = 4;
		public const uint32 DEBUG_OUTCBI_ANY_FORMAT = 6;
		public const uint32 DEBUG_OUTCB_TEXT = 0;
		public const uint32 DEBUG_OUTCB_DML = 1;
		public const uint32 DEBUG_OUTCB_EXPLICIT_FLUSH = 2;
		public const uint32 DEBUG_OUTCBF_COMBINED_EXPLICIT_FLUSH = 1;
		public const uint32 DEBUG_OUTCBF_DML_HAS_TAGS = 2;
		public const uint32 DEBUG_OUTCBF_DML_HAS_SPECIAL_CHARACTERS = 4;
		public const uint32 DEBUG_REGISTERS_DEFAULT = 0;
		public const uint32 DEBUG_REGISTERS_INT32 = 1;
		public const uint32 DEBUG_REGISTERS_INT64 = 2;
		public const uint32 DEBUG_REGISTERS_FLOAT = 4;
		public const uint32 DEBUG_REGISTERS_ALL = 7;
		public const uint32 DEBUG_REGISTER_SUB_REGISTER = 1;
		public const uint32 DEBUG_REGSRC_DEBUGGEE = 0;
		public const uint32 DEBUG_REGSRC_EXPLICIT = 1;
		public const uint32 DEBUG_REGSRC_FRAME = 2;
		public const uint32 DEBUG_OUTPUT_SYMBOLS_DEFAULT = 0;
		public const uint32 DEBUG_OUTPUT_SYMBOLS_NO_NAMES = 1;
		public const uint32 DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS = 2;
		public const uint32 DEBUG_OUTPUT_SYMBOLS_NO_VALUES = 4;
		public const uint32 DEBUG_OUTPUT_SYMBOLS_NO_TYPES = 16;
		public const uint32 DEBUG_SYMBOL_EXPANSION_LEVEL_MASK = 15;
		public const uint32 DEBUG_SYMBOL_EXPANDED = 16;
		public const uint32 DEBUG_SYMBOL_READ_ONLY = 32;
		public const uint32 DEBUG_SYMBOL_IS_ARRAY = 64;
		public const uint32 DEBUG_SYMBOL_IS_FLOAT = 128;
		public const uint32 DEBUG_SYMBOL_IS_ARGUMENT = 256;
		public const uint32 DEBUG_SYMBOL_IS_LOCAL = 512;
		public const uint32 DEBUG_SYMENT_IS_CODE = 1;
		public const uint32 DEBUG_SYMENT_IS_DATA = 2;
		public const uint32 DEBUG_SYMENT_IS_PARAMETER = 4;
		public const uint32 DEBUG_SYMENT_IS_LOCAL = 8;
		public const uint32 DEBUG_SYMENT_IS_MANAGED = 16;
		public const uint32 DEBUG_SYMENT_IS_SYNTHETIC = 32;
		public const uint32 DEBUG_MODULE_LOADED = 0;
		public const uint32 DEBUG_MODULE_UNLOADED = 1;
		public const uint32 DEBUG_MODULE_USER_MODE = 2;
		public const uint32 DEBUG_MODULE_EXE_MODULE = 4;
		public const uint32 DEBUG_MODULE_EXPLICIT = 8;
		public const uint32 DEBUG_MODULE_SECONDARY = 16;
		public const uint32 DEBUG_MODULE_SYNTHETIC = 32;
		public const uint32 DEBUG_MODULE_SYM_BAD_CHECKSUM = 65536;
		public const uint32 DEBUG_SYMTYPE_NONE = 0;
		public const uint32 DEBUG_SYMTYPE_COFF = 1;
		public const uint32 DEBUG_SYMTYPE_CODEVIEW = 2;
		public const uint32 DEBUG_SYMTYPE_PDB = 3;
		public const uint32 DEBUG_SYMTYPE_EXPORT = 4;
		public const uint32 DEBUG_SYMTYPE_DEFERRED = 5;
		public const uint32 DEBUG_SYMTYPE_SYM = 6;
		public const uint32 DEBUG_SYMTYPE_DIA = 7;
		public const uint32 DEBUG_SCOPE_GROUP_ARGUMENTS = 1;
		public const uint32 DEBUG_SCOPE_GROUP_LOCALS = 2;
		public const uint32 DEBUG_SCOPE_GROUP_ALL = 3;
		public const uint32 DEBUG_SCOPE_GROUP_BY_DATAMODEL = 4;
		public const uint32 DEBUG_OUTTYPE_DEFAULT = 0;
		public const uint32 DEBUG_OUTTYPE_NO_INDENT = 1;
		public const uint32 DEBUG_OUTTYPE_NO_OFFSET = 2;
		public const uint32 DEBUG_OUTTYPE_VERBOSE = 4;
		public const uint32 DEBUG_OUTTYPE_COMPACT_OUTPUT = 8;
		public const uint32 DEBUG_OUTTYPE_ADDRESS_OF_FIELD = 65536;
		public const uint32 DEBUG_OUTTYPE_ADDRESS_AT_END = 131072;
		public const uint32 DEBUG_OUTTYPE_BLOCK_RECURSE = 2097152;
		public const uint32 DEBUG_FIND_SOURCE_DEFAULT = 0;
		public const uint32 DEBUG_FIND_SOURCE_FULL_PATH = 1;
		public const uint32 DEBUG_FIND_SOURCE_BEST_MATCH = 2;
		public const uint32 DEBUG_FIND_SOURCE_NO_SRCSRV = 4;
		public const uint32 DEBUG_FIND_SOURCE_TOKEN_LOOKUP = 8;
		public const uint32 DEBUG_FIND_SOURCE_WITH_CHECKSUM = 16;
		public const uint32 DEBUG_FIND_SOURCE_WITH_CHECKSUM_STRICT = 32;
		public const uint32 MODULE_ORDERS_MASK = 4026531840;
		public const uint32 MODULE_ORDERS_LOADTIME = 268435456;
		public const uint32 MODULE_ORDERS_MODULENAME = 536870912;
		public const uint32 DEBUG_MODNAME_IMAGE = 0;
		public const uint32 DEBUG_MODNAME_MODULE = 1;
		public const uint32 DEBUG_MODNAME_LOADED_IMAGE = 2;
		public const uint32 DEBUG_MODNAME_SYMBOL_FILE = 3;
		public const uint32 DEBUG_MODNAME_MAPPED_IMAGE = 4;
		public const uint32 DEBUG_TYPEOPTS_UNICODE_DISPLAY = 1;
		public const uint32 DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY = 2;
		public const uint32 DEBUG_TYPEOPTS_FORCERADIX_OUTPUT = 4;
		public const uint32 DEBUG_TYPEOPTS_MATCH_MAXSIZE = 8;
		public const uint32 DEBUG_GETMOD_DEFAULT = 0;
		public const uint32 DEBUG_GETMOD_NO_LOADED_MODULES = 1;
		public const uint32 DEBUG_GETMOD_NO_UNLOADED_MODULES = 2;
		public const uint32 DEBUG_ADDSYNTHMOD_DEFAULT = 0;
		public const uint32 DEBUG_ADDSYNTHMOD_ZEROBASE = 1;
		public const uint32 DEBUG_ADDSYNTHSYM_DEFAULT = 0;
		public const uint32 DEBUG_OUTSYM_DEFAULT = 0;
		public const uint32 DEBUG_OUTSYM_FORCE_OFFSET = 1;
		public const uint32 DEBUG_OUTSYM_SOURCE_LINE = 2;
		public const uint32 DEBUG_OUTSYM_ALLOW_DISPLACEMENT = 4;
		public const uint32 DEBUG_GETFNENT_DEFAULT = 0;
		public const uint32 DEBUG_GETFNENT_RAW_ENTRY_ONLY = 1;
		public const uint32 DEBUG_SOURCE_IS_STATEMENT = 1;
		public const uint32 DEBUG_GSEL_DEFAULT = 0;
		public const uint32 DEBUG_GSEL_NO_SYMBOL_LOADS = 1;
		public const uint32 DEBUG_GSEL_ALLOW_LOWER = 2;
		public const uint32 DEBUG_GSEL_ALLOW_HIGHER = 4;
		public const uint32 DEBUG_GSEL_NEAREST_ONLY = 8;
		public const uint32 DEBUG_GSEL_INLINE_CALLSITE = 16;
		public const uint32 DEBUG_FRAME_DEFAULT = 0;
		public const uint32 DEBUG_FRAME_IGNORE_INLINE = 1;
		public const uint32 DEBUG_COMMAND_EXCEPTION_ID = 3688893886;
		public const uint32 DEBUG_CMDEX_INVALID = 0;
		public const uint32 DEBUG_CMDEX_ADD_EVENT_STRING = 1;
		public const uint32 DEBUG_CMDEX_RESET_EVENT_STRINGS = 2;
		public const uint32 DEBUG_EXTINIT_HAS_COMMAND_HELP = 1;
		public const uint32 DEBUG_NOTIFY_SESSION_ACTIVE = 0;
		public const uint32 DEBUG_NOTIFY_SESSION_INACTIVE = 1;
		public const uint32 DEBUG_NOTIFY_SESSION_ACCESSIBLE = 2;
		public const uint32 DEBUG_NOTIFY_SESSION_INACCESSIBLE = 3;
		public const uint32 DEBUG_KNOWN_STRUCT_GET_NAMES = 1;
		public const uint32 DEBUG_KNOWN_STRUCT_GET_SINGLE_LINE_OUTPUT = 2;
		public const uint32 DEBUG_KNOWN_STRUCT_SUPPRESS_TYPE_NAME = 3;
		public const uint32 DEBUG_EXT_QVALUE_DEFAULT = 0;
		public const uint32 DEBUG_EXT_PVALUE_DEFAULT = 0;
		public const uint32 DEBUG_EXT_PVTYPE_IS_VALUE = 0;
		public const uint32 DEBUG_EXT_PVTYPE_IS_POINTER = 1;
		public const uint32 CROSS_PLATFORM_MAXIMUM_PROCESSORS = 2048;
		public const uint32 EXT_API_VERSION_NUMBER = 5;
		public const uint32 EXT_API_VERSION_NUMBER32 = 5;
		public const uint32 EXT_API_VERSION_NUMBER64 = 6;
		public const uint32 IG_KD_CONTEXT = 1;
		public const uint32 IG_READ_CONTROL_SPACE = 2;
		public const uint32 IG_WRITE_CONTROL_SPACE = 3;
		public const uint32 IG_READ_IO_SPACE = 4;
		public const uint32 IG_WRITE_IO_SPACE = 5;
		public const uint32 IG_READ_PHYSICAL = 6;
		public const uint32 IG_WRITE_PHYSICAL = 7;
		public const uint32 IG_READ_IO_SPACE_EX = 8;
		public const uint32 IG_WRITE_IO_SPACE_EX = 9;
		public const uint32 IG_KSTACK_HELP = 10;
		public const uint32 IG_SET_THREAD = 11;
		public const uint32 IG_READ_MSR = 12;
		public const uint32 IG_WRITE_MSR = 13;
		public const uint32 IG_GET_DEBUGGER_DATA = 14;
		public const uint32 IG_GET_KERNEL_VERSION = 15;
		public const uint32 IG_RELOAD_SYMBOLS = 16;
		public const uint32 IG_GET_SET_SYMPATH = 17;
		public const uint32 IG_GET_EXCEPTION_RECORD = 18;
		public const uint32 IG_IS_PTR64 = 19;
		public const uint32 IG_GET_BUS_DATA = 20;
		public const uint32 IG_SET_BUS_DATA = 21;
		public const uint32 IG_DUMP_SYMBOL_INFO = 22;
		public const uint32 IG_LOWMEM_CHECK = 23;
		public const uint32 IG_SEARCH_MEMORY = 24;
		public const uint32 IG_GET_CURRENT_THREAD = 25;
		public const uint32 IG_GET_CURRENT_PROCESS = 26;
		public const uint32 IG_GET_TYPE_SIZE = 27;
		public const uint32 IG_GET_CURRENT_PROCESS_HANDLE = 28;
		public const uint32 IG_GET_INPUT_LINE = 29;
		public const uint32 IG_GET_EXPRESSION_EX = 30;
		public const uint32 IG_TRANSLATE_VIRTUAL_TO_PHYSICAL = 31;
		public const uint32 IG_GET_CACHE_SIZE = 32;
		public const uint32 IG_READ_PHYSICAL_WITH_FLAGS = 33;
		public const uint32 IG_WRITE_PHYSICAL_WITH_FLAGS = 34;
		public const uint32 IG_POINTER_SEARCH_PHYSICAL = 35;
		public const uint32 IG_OBSOLETE_PLACEHOLDER_36 = 36;
		public const uint32 IG_GET_THREAD_OS_INFO = 37;
		public const uint32 IG_GET_CLR_DATA_INTERFACE = 38;
		public const uint32 IG_MATCH_PATTERN_A = 39;
		public const uint32 IG_FIND_FILE = 40;
		public const uint32 IG_TYPED_DATA_OBSOLETE = 41;
		public const uint32 IG_QUERY_TARGET_INTERFACE = 42;
		public const uint32 IG_TYPED_DATA = 43;
		public const uint32 IG_DISASSEMBLE_BUFFER = 44;
		public const uint32 IG_GET_ANY_MODULE_IN_RANGE = 45;
		public const uint32 IG_VIRTUAL_TO_PHYSICAL = 46;
		public const uint32 IG_PHYSICAL_TO_VIRTUAL = 47;
		public const uint32 IG_GET_CONTEXT_EX = 48;
		public const uint32 IG_GET_TEB_ADDRESS = 128;
		public const uint32 IG_GET_PEB_ADDRESS = 129;
		public const uint32 PHYS_FLAG_DEFAULT = 0;
		public const uint32 PHYS_FLAG_CACHED = 1;
		public const uint32 PHYS_FLAG_UNCACHED = 2;
		public const uint32 PHYS_FLAG_WRITE_COMBINED = 3;
		public const uint32 PTR_SEARCH_PHYS_ALL_HITS = 1;
		public const uint32 PTR_SEARCH_PHYS_PTE = 2;
		public const uint32 PTR_SEARCH_PHYS_RANGE_CHECK_ONLY = 4;
		public const uint32 PTR_SEARCH_PHYS_SIZE_SHIFT = 3;
		public const uint32 PTR_SEARCH_NO_SYMBOL_CHECK = 2147483648;
		public const uint32 EXT_FIND_FILE_ALLOW_GIVEN_PATH = 1;
		public const uint32 DEBUG_TYPED_DATA_IS_IN_MEMORY = 1;
		public const uint32 DEBUG_TYPED_DATA_PHYSICAL_DEFAULT = 2;
		public const uint32 DEBUG_TYPED_DATA_PHYSICAL_CACHED = 4;
		public const uint32 DEBUG_TYPED_DATA_PHYSICAL_UNCACHED = 6;
		public const uint32 DEBUG_TYPED_DATA_PHYSICAL_WRITE_COMBINED = 8;
		public const uint32 DEBUG_TYPED_DATA_PHYSICAL_MEMORY = 14;
		public const uint32 EXT_TDF_PHYSICAL_DEFAULT = 2;
		public const uint32 EXT_TDF_PHYSICAL_CACHED = 4;
		public const uint32 EXT_TDF_PHYSICAL_UNCACHED = 6;
		public const uint32 EXT_TDF_PHYSICAL_WRITE_COMBINED = 8;
		public const uint32 EXT_TDF_PHYSICAL_MEMORY = 14;
		public const uint32 WDBGEXTS_ADDRESS_DEFAULT = 0;
		public const uint32 WDBGEXTS_ADDRESS_SEG16 = 1;
		public const uint32 WDBGEXTS_ADDRESS_SEG32 = 2;
		public const uint32 WDBGEXTS_ADDRESS_RESERVED0 = 2147483648;
		public const uint32 DBGKD_VERS_FLAG_MP = 1;
		public const uint32 DBGKD_VERS_FLAG_DATA = 2;
		public const uint32 DBGKD_VERS_FLAG_PTR64 = 4;
		public const uint32 DBGKD_VERS_FLAG_NOMM = 8;
		public const uint32 DBGKD_VERS_FLAG_HSS = 16;
		public const uint32 DBGKD_VERS_FLAG_PARTITIONS = 32;
		public const uint32 DBGKD_VERS_FLAG_HAL_IN_NTOS = 64;
		public const uint32 KD_SECONDARY_VERSION_DEFAULT = 0;
		public const uint32 KD_SECONDARY_VERSION_AMD64_OBSOLETE_CONTEXT_1 = 0;
		public const uint32 KD_SECONDARY_VERSION_AMD64_OBSOLETE_CONTEXT_2 = 1;
		public const uint32 KD_SECONDARY_VERSION_AMD64_CONTEXT = 2;
		public const uint32 CURRENT_KD_SECONDARY_VERSION = 2;
		public const uint32 DBG_DUMP_NO_INDENT = 1;
		public const uint32 DBG_DUMP_NO_OFFSET = 2;
		public const uint32 DBG_DUMP_VERBOSE = 4;
		public const uint32 DBG_DUMP_CALL_FOR_EACH = 8;
		public const uint32 DBG_DUMP_LIST = 32;
		public const uint32 DBG_DUMP_NO_PRINT = 64;
		public const uint32 DBG_DUMP_GET_SIZE_ONLY = 128;
		public const uint32 DBG_DUMP_COMPACT_OUT = 8192;
		public const uint32 DBG_DUMP_ARRAY = 32768;
		public const uint32 DBG_DUMP_ADDRESS_OF_FIELD = 65536;
		public const uint32 DBG_DUMP_ADDRESS_AT_END = 131072;
		public const uint32 DBG_DUMP_COPY_TYPE_DATA = 262144;
		public const uint32 DBG_DUMP_READ_PHYSICAL = 524288;
		public const uint32 DBG_DUMP_FUNCTION_FORMAT = 1048576;
		public const uint32 DBG_DUMP_BLOCK_RECURSE = 2097152;
		public const uint32 DBG_DUMP_MATCH_SIZE = 4194304;
		public const uint32 DBG_RETURN_TYPE = 0;
		public const uint32 DBG_RETURN_SUBTYPES = 0;
		public const uint32 DBG_RETURN_TYPE_VALUES = 0;
		public const uint32 DBG_DUMP_FIELD_CALL_BEFORE_PRINT = 1;
		public const uint32 DBG_DUMP_FIELD_NO_CALLBACK_REQ = 2;
		public const uint32 DBG_DUMP_FIELD_RECUR_ON_THIS = 4;
		public const uint32 DBG_DUMP_FIELD_FULL_NAME = 8;
		public const uint32 DBG_DUMP_FIELD_ARRAY = 16;
		public const uint32 DBG_DUMP_FIELD_COPY_FIELD_DATA = 32;
		public const uint32 DBG_DUMP_FIELD_RETURN_ADDRESS = 4096;
		public const uint32 DBG_DUMP_FIELD_SIZE_IN_BITS = 8192;
		public const uint32 DBG_DUMP_FIELD_NO_PRINT = 16384;
		public const uint32 DBG_DUMP_FIELD_DEFAULT_STRING = 65536;
		public const uint32 DBG_DUMP_FIELD_WCHAR_STRING = 131072;
		public const uint32 DBG_DUMP_FIELD_MULTI_STRING = 262144;
		public const uint32 DBG_DUMP_FIELD_GUID_STRING = 524288;
		public const uint32 DBG_DUMP_FIELD_UTF32_STRING = 1048576;
		public const uint32 MEMORY_READ_ERROR = 1;
		public const uint32 SYMBOL_TYPE_INDEX_NOT_FOUND = 2;
		public const uint32 SYMBOL_TYPE_INFO_NOT_FOUND = 3;
		public const uint32 FIELDS_DID_NOT_MATCH = 4;
		public const uint32 NULL_SYM_DUMP_PARAM = 5;
		public const uint32 NULL_FIELD_NAME = 6;
		public const uint32 INCORRECT_VERSION_INFO = 7;
		public const uint32 EXIT_ON_CONTROLC = 8;
		public const uint32 CANNOT_ALLOCATE_MEMORY = 9;
		public const uint32 INSUFFICIENT_SPACE_TO_COPY = 10;
		public const uint32 ADDRESS_TYPE_INDEX_NOT_FOUND = 11;
		public const uint32 UNAVAILABLE_ERROR = 12;
		public const Guid CATID_ActiveScript = .(0xf0b7a1a1, 0x9847, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
		public const Guid CATID_ActiveScriptParse = .(0xf0b7a1a2, 0x9847, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
		public const Guid CATID_ActiveScriptEncode = .(0xf0b7a1a3, 0x9847, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
		public const Guid OID_VBSSIP = .(0x1629f04e, 0x2799, 0x4db5, 0x8f, 0xe5, 0xac, 0xe1, 0x0f, 0x17, 0xeb, 0xab);
		public const Guid OID_JSSIP = .(0x06c9e010, 0x38ce, 0x11d4, 0xa2, 0xa3, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);
		public const Guid OID_WSFSIP = .(0x1a610570, 0x38ce, 0x11d4, 0xa2, 0xa3, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);
		public const uint32 SCRIPTITEM_ISVISIBLE = 2;
		public const uint32 SCRIPTITEM_ISSOURCE = 4;
		public const uint32 SCRIPTITEM_GLOBALMEMBERS = 8;
		public const uint32 SCRIPTITEM_ISPERSISTENT = 64;
		public const uint32 SCRIPTITEM_CODEONLY = 512;
		public const uint32 SCRIPTITEM_NOCODE = 1024;
		public const uint32 SCRIPTTYPELIB_ISCONTROL = 16;
		public const uint32 SCRIPTTYPELIB_ISPERSISTENT = 64;
		public const uint32 SCRIPTTEXT_DELAYEXECUTION = 1;
		public const uint32 SCRIPTTEXT_ISVISIBLE = 2;
		public const uint32 SCRIPTTEXT_ISEXPRESSION = 32;
		public const uint32 SCRIPTTEXT_ISPERSISTENT = 64;
		public const uint32 SCRIPTTEXT_HOSTMANAGESSOURCE = 128;
		public const uint32 SCRIPTTEXT_ISXDOMAIN = 256;
		public const uint32 SCRIPTTEXT_ISNONUSERCODE = 512;
		public const uint32 SCRIPTPROC_ISEXPRESSION = 32;
		public const uint32 SCRIPTPROC_HOSTMANAGESSOURCE = 128;
		public const uint32 SCRIPTPROC_IMPLICIT_THIS = 256;
		public const uint32 SCRIPTPROC_IMPLICIT_PARENTS = 512;
		public const uint32 SCRIPTPROC_ISXDOMAIN = 1024;
		public const uint32 SCRIPTINFO_IUNKNOWN = 1;
		public const uint32 SCRIPTINFO_ITYPEINFO = 2;
		public const uint32 SCRIPTINTERRUPT_DEBUG = 1;
		public const uint32 SCRIPTINTERRUPT_RAISEEXCEPTION = 2;
		public const uint32 SCRIPTSTAT_STATEMENT_COUNT = 1;
		public const uint32 SCRIPTSTAT_INSTRUCTION_COUNT = 2;
		public const uint32 SCRIPTSTAT_INTSTRUCTION_TIME = 3;
		public const uint32 SCRIPTSTAT_TOTAL_TIME = 4;
		public const uint32 SCRIPT_ENCODE_SECTION = 1;
		public const uint32 SCRIPT_ENCODE_DEFAULT_LANGUAGE = 1;
		public const uint32 SCRIPT_ENCODE_NO_ASP_LANGUAGE = 2;
		public const uint32 SCRIPTPROP_NAME = 0;
		public const uint32 SCRIPTPROP_MAJORVERSION = 1;
		public const uint32 SCRIPTPROP_MINORVERSION = 2;
		public const uint32 SCRIPTPROP_BUILDNUMBER = 3;
		public const uint32 SCRIPTPROP_DELAYEDEVENTSINKING = 4096;
		public const uint32 SCRIPTPROP_CATCHEXCEPTION = 4097;
		public const uint32 SCRIPTPROP_CONVERSIONLCID = 4098;
		public const uint32 SCRIPTPROP_HOSTSTACKREQUIRED = 4099;
		public const uint32 SCRIPTPROP_SCRIPTSAREFULLYTRUSTED = 4100;
		public const uint32 SCRIPTPROP_DEBUGGER = 4352;
		public const uint32 SCRIPTPROP_JITDEBUG = 4353;
		public const uint32 SCRIPTPROP_GCCONTROLSOFTCLOSE = 8192;
		public const uint32 SCRIPTPROP_INTEGERMODE = 12288;
		public const uint32 SCRIPTPROP_STRINGCOMPAREINSTANCE = 12289;
		public const uint32 SCRIPTPROP_INVOKEVERSIONING = 16384;
		public const uint32 SCRIPTPROP_HACK_FIBERSUPPORT = 1879048192;
		public const uint32 SCRIPTPROP_HACK_TRIDENTEVENTSINK = 1879048193;
		public const uint32 SCRIPTPROP_ABBREVIATE_GLOBALNAME_RESOLUTION = 1879048194;
		public const uint32 SCRIPTPROP_HOSTKEEPALIVE = 1879048196;
		public const int32 SCRIPT_E_RECORDED = -2040119292;
		public const int32 SCRIPT_E_REPORTED = -2147352319;
		public const int32 SCRIPT_E_PROPAGATE = -2147352318;
		public const uint32 MINIDUMP_VERSION = 42899;
		public const uint32 MINIDUMP_MISC1_PROCESSOR_POWER_INFO = 4;
		public const uint32 MINIDUMP_MISC3_PROCESS_INTEGRITY = 16;
		public const uint32 MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS = 32;
		public const uint32 MINIDUMP_MISC3_TIMEZONE = 64;
		public const uint32 MINIDUMP_MISC3_PROTECTED_PROCESS = 128;
		public const uint32 MINIDUMP_MISC4_BUILDSTRING = 256;
		public const uint32 MINIDUMP_MISC5_PROCESS_COOKIE = 512;
		public const uint32 MINIDUMP_SYSMEMINFO1_FILECACHE_TRANSITIONREPURPOSECOUNT_FLAGS = 1;
		public const uint32 MINIDUMP_SYSMEMINFO1_BASICPERF = 2;
		public const uint32 MINIDUMP_SYSMEMINFO1_PERF_CCTOTALDIRTYPAGES_CCDIRTYPAGETHRESHOLD = 4;
		public const uint32 MINIDUMP_SYSMEMINFO1_PERF_RESIDENTAVAILABLEPAGES_SHAREDCOMMITPAGES = 8;
		public const uint32 MINIDUMP_PROCESS_VM_COUNTERS = 1;
		public const uint32 MINIDUMP_PROCESS_VM_COUNTERS_VIRTUALSIZE = 2;
		public const uint32 MINIDUMP_PROCESS_VM_COUNTERS_EX = 4;
		public const uint32 MINIDUMP_PROCESS_VM_COUNTERS_EX2 = 8;
		public const uint32 MINIDUMP_PROCESS_VM_COUNTERS_JOB = 16;
		public const uint32 MAX_SYM_NAME = 2000;
		public const uint32 BIND_NO_BOUND_IMPORTS = 1;
		public const uint32 BIND_NO_UPDATE = 2;
		public const uint32 BIND_ALL_IMAGES = 4;
		public const uint32 BIND_CACHE_IMPORT_DLLS = 8;
		public const uint32 BIND_REPORT_64BIT_VA = 16;
		public const uint32 CHECKSUM_SUCCESS = 0;
		public const uint32 CHECKSUM_OPEN_FAILURE = 1;
		public const uint32 CHECKSUM_MAP_FAILURE = 2;
		public const uint32 CHECKSUM_MAPVIEW_FAILURE = 3;
		public const uint32 CHECKSUM_UNICODE_FAILURE = 4;
		public const uint32 SPLITSYM_REMOVE_PRIVATE = 1;
		public const uint32 SPLITSYM_EXTRACT_ALL = 2;
		public const uint32 SPLITSYM_SYMBOLPATH_IS_SRC = 4;
		public const uint32 CERT_PE_IMAGE_DIGEST_DEBUG_INFO = 1;
		public const uint32 CERT_PE_IMAGE_DIGEST_RESOURCES = 2;
		public const uint32 CERT_PE_IMAGE_DIGEST_ALL_IMPORT_INFO = 4;
		public const uint32 CERT_PE_IMAGE_DIGEST_NON_PE_INFO = 8;
		public const uint32 CERT_SECTION_TYPE_ANY = 255;
		public const uint32 ERROR_IMAGE_NOT_STRIPPED = 34816;
		public const uint32 ERROR_NO_DBG_POINTER = 34817;
		public const uint32 ERROR_NO_PDB_POINTER = 34818;
		public const uint32 UNDNAME_COMPLETE = 0;
		public const uint32 UNDNAME_NO_LEADING_UNDERSCORES = 1;
		public const uint32 UNDNAME_NO_MS_KEYWORDS = 2;
		public const uint32 UNDNAME_NO_FUNCTION_RETURNS = 4;
		public const uint32 UNDNAME_NO_ALLOCATION_MODEL = 8;
		public const uint32 UNDNAME_NO_ALLOCATION_LANGUAGE = 16;
		public const uint32 UNDNAME_NO_MS_THISTYPE = 32;
		public const uint32 UNDNAME_NO_CV_THISTYPE = 64;
		public const uint32 UNDNAME_NO_THISTYPE = 96;
		public const uint32 UNDNAME_NO_ACCESS_SPECIFIERS = 128;
		public const uint32 UNDNAME_NO_THROW_SIGNATURES = 256;
		public const uint32 UNDNAME_NO_MEMBER_TYPE = 512;
		public const uint32 UNDNAME_NO_RETURN_UDT_MODEL = 1024;
		public const uint32 UNDNAME_32_BIT_DECODE = 2048;
		public const uint32 UNDNAME_NAME_ONLY = 4096;
		public const uint32 UNDNAME_NO_ARGUMENTS = 8192;
		public const uint32 UNDNAME_NO_SPECIAL_SYMS = 16384;
		public const uint32 DBHHEADER_PDBGUID = 3;
		public const uint32 INLINE_FRAME_CONTEXT_INIT = 0;
		public const uint32 INLINE_FRAME_CONTEXT_IGNORE = 4294967295;
		public const uint32 SYM_STKWALK_DEFAULT = 0;
		public const uint32 SYM_STKWALK_FORCE_FRAMEPTR = 1;
		public const uint32 SYM_STKWALK_ZEROEXTEND_PTRS = 2;
		public const uint32 API_VERSION_NUMBER = 12;
		public const uint32 SYMFLAG_NULL = 524288;
		public const uint32 SYMFLAG_FUNC_NO_RETURN = 1048576;
		public const uint32 SYMFLAG_SYNTHETIC_ZEROBASE = 2097152;
		public const uint32 SYMFLAG_PUBLIC_CODE = 4194304;
		public const uint32 SYMFLAG_REGREL_ALIASINDIR = 8388608;
		public const uint32 SYMFLAG_FIXUP_ARM64X = 16777216;
		public const uint32 SYMFLAG_GLOBAL = 33554432;
		public const uint32 SYMFLAG_RESET = 2147483648;
		public const uint32 IMAGEHLP_MODULE_REGION_DLLBASE = 1;
		public const uint32 IMAGEHLP_MODULE_REGION_DLLRANGE = 2;
		public const uint32 IMAGEHLP_MODULE_REGION_ADDITIONAL = 4;
		public const uint32 IMAGEHLP_MODULE_REGION_JIT = 8;
		public const uint32 IMAGEHLP_MODULE_REGION_ALL = 255;
		public const uint32 CBA_DEFERRED_SYMBOL_LOAD_START = 1;
		public const uint32 CBA_DEFERRED_SYMBOL_LOAD_COMPLETE = 2;
		public const uint32 CBA_DEFERRED_SYMBOL_LOAD_FAILURE = 3;
		public const uint32 CBA_SYMBOLS_UNLOADED = 4;
		public const uint32 CBA_DUPLICATE_SYMBOL = 5;
		public const uint32 CBA_READ_MEMORY = 6;
		public const uint32 CBA_DEFERRED_SYMBOL_LOAD_CANCEL = 7;
		public const uint32 CBA_SET_OPTIONS = 8;
		public const uint32 CBA_EVENT = 16;
		public const uint32 CBA_DEFERRED_SYMBOL_LOAD_PARTIAL = 32;
		public const uint32 CBA_DEBUG_INFO = 268435456;
		public const uint32 CBA_SRCSRV_INFO = 536870912;
		public const uint32 CBA_SRCSRV_EVENT = 1073741824;
		public const uint32 CBA_UPDATE_STATUS_BAR = 1342177280;
		public const uint32 CBA_ENGINE_PRESENT = 1610612736;
		public const uint32 CBA_CHECK_ENGOPT_DISALLOW_NETWORK_PATHS = 1879048192;
		public const uint32 CBA_CHECK_ARM_MACHINE_THUMB_TYPE_OVERRIDE = 2147483648;
		public const uint32 CBA_XML_LOG = 2415919104;
		public const uint32 CBA_MAP_JIT_SYMBOL = 2684354560;
		public const uint32 EVENT_SRCSPEW_START = 100;
		public const uint32 EVENT_SRCSPEW = 100;
		public const uint32 EVENT_SRCSPEW_END = 199;
		public const uint32 DSLFLAG_MISMATCHED_PDB = 1;
		public const uint32 DSLFLAG_MISMATCHED_DBG = 2;
		public const uint32 FLAG_ENGINE_PRESENT = 4;
		public const uint32 FLAG_ENGOPT_DISALLOW_NETWORK_PATHS = 8;
		public const uint32 FLAG_OVERRIDE_ARM_MACHINE_TYPE = 16;
		public const uint32 SYMOPT_CASE_INSENSITIVE = 1;
		public const uint32 SYMOPT_UNDNAME = 2;
		public const uint32 SYMOPT_DEFERRED_LOADS = 4;
		public const uint32 SYMOPT_NO_CPP = 8;
		public const uint32 SYMOPT_LOAD_LINES = 16;
		public const uint32 SYMOPT_OMAP_FIND_NEAREST = 32;
		public const uint32 SYMOPT_LOAD_ANYTHING = 64;
		public const uint32 SYMOPT_IGNORE_CVREC = 128;
		public const uint32 SYMOPT_NO_UNQUALIFIED_LOADS = 256;
		public const uint32 SYMOPT_FAIL_CRITICAL_ERRORS = 512;
		public const uint32 SYMOPT_EXACT_SYMBOLS = 1024;
		public const uint32 SYMOPT_ALLOW_ABSOLUTE_SYMBOLS = 2048;
		public const uint32 SYMOPT_IGNORE_NT_SYMPATH = 4096;
		public const uint32 SYMOPT_INCLUDE_32BIT_MODULES = 8192;
		public const uint32 SYMOPT_PUBLICS_ONLY = 16384;
		public const uint32 SYMOPT_NO_PUBLICS = 32768;
		public const uint32 SYMOPT_AUTO_PUBLICS = 65536;
		public const uint32 SYMOPT_NO_IMAGE_SEARCH = 131072;
		public const uint32 SYMOPT_SECURE = 262144;
		public const uint32 SYMOPT_NO_PROMPTS = 524288;
		public const uint32 SYMOPT_OVERWRITE = 1048576;
		public const uint32 SYMOPT_IGNORE_IMAGEDIR = 2097152;
		public const uint32 SYMOPT_FLAT_DIRECTORY = 4194304;
		public const uint32 SYMOPT_FAVOR_COMPRESSED = 8388608;
		public const uint32 SYMOPT_ALLOW_ZERO_ADDRESS = 16777216;
		public const uint32 SYMOPT_DISABLE_SYMSRV_AUTODETECT = 33554432;
		public const uint32 SYMOPT_READONLY_CACHE = 67108864;
		public const uint32 SYMOPT_SYMPATH_LAST = 134217728;
		public const uint32 SYMOPT_DISABLE_FAST_SYMBOLS = 268435456;
		public const uint32 SYMOPT_DISABLE_SYMSRV_TIMEOUT = 536870912;
		public const uint32 SYMOPT_DISABLE_SRVSTAR_ON_STARTUP = 1073741824;
		public const uint32 SYMOPT_DEBUG = 2147483648;
		public const uint32 SYM_INLINE_COMP_ERROR = 0;
		public const uint32 SYM_INLINE_COMP_IDENTICAL = 1;
		public const uint32 SYM_INLINE_COMP_STEPIN = 2;
		public const uint32 SYM_INLINE_COMP_STEPOUT = 3;
		public const uint32 SYM_INLINE_COMP_STEPOVER = 4;
		public const uint32 SYM_INLINE_COMP_DIFFERENT = 5;
		public const uint32 ESLFLAG_FULLPATH = 1;
		public const uint32 ESLFLAG_NEAREST = 2;
		public const uint32 ESLFLAG_PREV = 4;
		public const uint32 ESLFLAG_NEXT = 8;
		public const uint32 ESLFLAG_INLINE_SITE = 16;
		public const uint32 SYMENUM_OPTIONS_DEFAULT = 1;
		public const uint32 SYMENUM_OPTIONS_INLINE = 2;
		public const uint32 SYMSEARCH_MASKOBJS = 1;
		public const uint32 SYMSEARCH_RECURSE = 2;
		public const uint32 SYMSEARCH_GLOBALSONLY = 4;
		public const uint32 SYMSEARCH_ALLITEMS = 8;
		public const uint32 EXT_OUTPUT_VER = 1;
		public const uint32 SYMSRV_VERSION = 2;
		public const uint32 SSRVOPT_CALLBACK = 1;
		public const uint32 SSRVOPT_OLDGUIDPTR = 16;
		public const uint32 SSRVOPT_UNATTENDED = 32;
		public const uint32 SSRVOPT_NOCOPY = 64;
		public const uint32 SSRVOPT_GETPATH = 64;
		public const uint32 SSRVOPT_PARENTWIN = 128;
		public const uint32 SSRVOPT_PARAMTYPE = 256;
		public const uint32 SSRVOPT_SECURE = 512;
		public const uint32 SSRVOPT_TRACE = 1024;
		public const uint32 SSRVOPT_SETCONTEXT = 2048;
		public const uint32 SSRVOPT_PROXY = 4096;
		public const uint32 SSRVOPT_DOWNSTREAM_STORE = 8192;
		public const uint32 SSRVOPT_OVERWRITE = 16384;
		public const uint32 SSRVOPT_RESETTOU = 32768;
		public const uint32 SSRVOPT_CALLBACKW = 65536;
		public const uint32 SSRVOPT_FLAT_DEFAULT_STORE = 131072;
		public const uint32 SSRVOPT_PROXYW = 262144;
		public const uint32 SSRVOPT_MESSAGE = 524288;
		public const uint32 SSRVOPT_SERVICE = 1048576;
		public const uint32 SSRVOPT_FAVOR_COMPRESSED = 2097152;
		public const uint32 SSRVOPT_STRING = 4194304;
		public const uint32 SSRVOPT_WINHTTP = 8388608;
		public const uint32 SSRVOPT_WININET = 16777216;
		public const uint32 SSRVOPT_DONT_UNCOMPRESS = 33554432;
		public const uint32 SSRVOPT_DISABLE_PING_HOST = 67108864;
		public const uint32 SSRVOPT_DISABLE_TIMEOUT = 134217728;
		public const uint32 SSRVOPT_ENABLE_COMM_MSG = 268435456;
		public const uint32 SSRVOPT_URI_FILTER = 536870912;
		public const uint32 SSRVOPT_URI_TIERS = 1073741824;
		public const uint32 SSRVOPT_RETRY_APP_HANG = 2147483648;
		public const uint32 SSRVOPT_MAX = 2147483648;
		public const uint32 NUM_SSRVOPTS = 32;
		public const uint32 SSRVURI_HTTP_NORMAL = 1;
		public const uint32 SSRVURI_HTTP_COMPRESSED = 2;
		public const uint32 SSRVURI_HTTP_FILEPTR = 4;
		public const uint32 SSRVURI_UNC_NORMAL = 16;
		public const uint32 SSRVURI_UNC_COMPRESSED = 32;
		public const uint32 SSRVURI_UNC_FILEPTR = 64;
		public const uint32 SSRVURI_HTTP_MASK = 15;
		public const uint32 SSRVURI_UNC_MASK = 240;
		public const uint32 SSRVURI_ALL = 255;
		public const uint32 SSRVURI_NORMAL = 1;
		public const uint32 SSRVURI_COMPRESSED = 2;
		public const uint32 SSRVURI_FILEPTR = 4;
		public const uint32 SSRVACTION_TRACE = 1;
		public const uint32 SSRVACTION_QUERYCANCEL = 2;
		public const uint32 SSRVACTION_EVENT = 3;
		public const uint32 SSRVACTION_EVENTW = 4;
		public const uint32 SSRVACTION_SIZE = 5;
		public const uint32 SSRVACTION_HTTPSTATUS = 6;
		public const uint32 SSRVACTION_XMLOUTPUT = 7;
		public const uint32 SSRVACTION_CHECKSUMSTATUS = 8;
		public const uint32 SYMSTOREOPT_ALT_INDEX = 16;
		public const uint32 SYMSTOREOPT_UNICODE = 32;
		public const uint32 SYMF_OMAP_GENERATED = 1;
		public const uint32 SYMF_OMAP_MODIFIED = 2;
		public const uint32 SYMF_REGISTER = 8;
		public const uint32 SYMF_REGREL = 16;
		public const uint32 SYMF_FRAMEREL = 32;
		public const uint32 SYMF_PARAMETER = 64;
		public const uint32 SYMF_LOCAL = 128;
		public const uint32 SYMF_CONSTANT = 256;
		public const uint32 SYMF_EXPORT = 512;
		public const uint32 SYMF_FORWARDER = 1024;
		public const uint32 SYMF_FUNCTION = 2048;
		public const uint32 SYMF_VIRTUAL = 4096;
		public const uint32 SYMF_THUNK = 8192;
		public const uint32 SYMF_TLSREL = 16384;
		public const uint32 IMAGEHLP_SYMBOL_INFO_VALUEPRESENT = 1;
		public const uint32 IMAGEHLP_SYMBOL_INFO_REGISTER = 8;
		public const uint32 IMAGEHLP_SYMBOL_INFO_REGRELATIVE = 16;
		public const uint32 IMAGEHLP_SYMBOL_INFO_FRAMERELATIVE = 32;
		public const uint32 IMAGEHLP_SYMBOL_INFO_PARAMETER = 64;
		public const uint32 IMAGEHLP_SYMBOL_INFO_LOCAL = 128;
		public const uint32 IMAGEHLP_SYMBOL_INFO_CONSTANT = 256;
		public const uint32 IMAGEHLP_SYMBOL_FUNCTION = 2048;
		public const uint32 IMAGEHLP_SYMBOL_VIRTUAL = 4096;
		public const uint32 IMAGEHLP_SYMBOL_THUNK = 8192;
		public const uint32 IMAGEHLP_SYMBOL_INFO_TLSRELATIVE = 16384;
		public const uint32 IMAGEHLP_RMAP_MAPPED_FLAT = 1;
		public const uint32 IMAGEHLP_RMAP_BIG_ENDIAN = 2;
		public const uint32 IMAGEHLP_RMAP_IGNORE_MISCOMPARE = 4;
		public const uint32 IMAGEHLP_RMAP_FIXUP_ARM64X = 268435456;
		public const uint32 IMAGEHLP_RMAP_LOAD_RW_DATA_SECTIONS = 536870912;
		public const uint32 IMAGEHLP_RMAP_OMIT_SHARED_RW_DATA_SECTIONS = 1073741824;
		public const uint32 IMAGEHLP_RMAP_FIXUP_IMAGEBASE = 2147483648;
		public const uint32 WCT_MAX_NODE_COUNT = 16;
		public const uint32 WCT_OBJNAME_LENGTH = 128;
		public const uint32 WCT_NETWORK_IO_FLAG = 8;
		public const uint32 APPBREAKFLAG_DEBUGGER_BLOCK = 1;
		public const uint32 APPBREAKFLAG_DEBUGGER_HALT = 2;
		public const uint32 APPBREAKFLAG_STEP = 65536;
		public const uint32 APPBREAKFLAG_NESTED = 131072;
		public const uint32 APPBREAKFLAG_STEPTYPE_SOURCE = 0;
		public const uint32 APPBREAKFLAG_STEPTYPE_BYTECODE = 1048576;
		public const uint32 APPBREAKFLAG_STEPTYPE_MACHINE = 2097152;
		public const uint32 APPBREAKFLAG_STEPTYPE_MASK = 15728640;
		public const uint32 APPBREAKFLAG_IN_BREAKPOINT = 2147483648;
		public const uint32 SOURCETEXT_ATTR_KEYWORD = 1;
		public const uint32 SOURCETEXT_ATTR_COMMENT = 2;
		public const uint32 SOURCETEXT_ATTR_NONSOURCE = 4;
		public const uint32 SOURCETEXT_ATTR_OPERATOR = 8;
		public const uint32 SOURCETEXT_ATTR_NUMBER = 16;
		public const uint32 SOURCETEXT_ATTR_STRING = 32;
		public const uint32 SOURCETEXT_ATTR_FUNCTION_START = 64;
		public const uint32 TEXT_DOC_ATTR_READONLY = 1;
		public const uint32 TEXT_DOC_ATTR_TYPE_PRIMARY = 2;
		public const uint32 TEXT_DOC_ATTR_TYPE_WORKER = 4;
		public const uint32 TEXT_DOC_ATTR_TYPE_SCRIPT = 8;
		public const uint32 DEBUG_TEXT_ISEXPRESSION = 1;
		public const uint32 DEBUG_TEXT_RETURNVALUE = 2;
		public const uint32 DEBUG_TEXT_NOSIDEEFFECTS = 4;
		public const uint32 DEBUG_TEXT_ALLOWBREAKPOINTS = 8;
		public const uint32 DEBUG_TEXT_ALLOWERRORREPORT = 16;
		public const uint32 DEBUG_TEXT_EVALUATETOCODECONTEXT = 32;
		public const uint32 DEBUG_TEXT_ISNONUSERCODE = 64;
		public const uint32 THREAD_STATE_RUNNING = 1;
		public const uint32 THREAD_STATE_SUSPENDED = 2;
		public const uint32 THREAD_BLOCKED = 4;
		public const uint32 THREAD_OUT_OF_CONTEXT = 8;
		public const Guid CATID_ActiveScriptAuthor = .(0x0aee2a92, 0xbcbb, 0x11d0, 0x8c, 0x72, 0x00, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);
		public const uint32 FACILITY_JsDEBUG = 3527;
		public const HResult E_JsDEBUG_MISMATCHED_RUNTIME = (.)-1916338175;
		public const HResult E_JsDEBUG_UNKNOWN_THREAD = (.)-1916338174;
		public const HResult E_JsDEBUG_OUTSIDE_OF_VM = (.)-1916338172;
		public const HResult E_JsDEBUG_INVALID_MEMORY_ADDRESS = (.)-1916338171;
		public const HResult E_JsDEBUG_SOURCE_LOCATION_NOT_FOUND = (.)-1916338170;
		public const HResult E_JsDEBUG_RUNTIME_NOT_IN_DEBUG_MODE = (.)-1916338169;
		public const uint32 DMP_PHYSICAL_MEMORY_BLOCK_SIZE_32 = 700;
		public const uint32 DMP_CONTEXT_RECORD_SIZE_32 = 1200;
		public const uint32 DMP_RESERVED_0_SIZE_32 = 1760;
		public const uint32 DMP_RESERVED_2_SIZE_32 = 16;
		public const uint32 DMP_RESERVED_3_SIZE_32 = 56;
		public const uint32 DMP_PHYSICAL_MEMORY_BLOCK_SIZE_64 = 700;
		public const uint32 DMP_CONTEXT_RECORD_SIZE_64 = 3000;
		public const uint32 DMP_RESERVED_0_SIZE_64 = 4008;
		public const uint32 DMP_HEADER_COMMENT_SIZE = 128;
		public const uint32 DUMP_SUMMARY_VALID_KERNEL_VA = 1;
		public const uint32 DUMP_SUMMARY_VALID_CURRENT_USER_VA = 2;
		public const uint32 INTERFACESAFE_FOR_UNTRUSTED_CALLER = 1;
		public const uint32 INTERFACESAFE_FOR_UNTRUSTED_DATA = 2;
		public const uint32 INTERFACE_USES_DISPEX = 4;
		public const uint32 INTERFACE_USES_SECURITY_MANAGER = 8;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_10 = 10;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_VERSION_11 = 11;
		public const uint32 WHEA_MAX_MC_BANKS = 32;
		public const uint32 WHEA_ERROR_SOURCE_FLAG_FIRMWAREFIRST = 1;
		public const uint32 WHEA_ERROR_SOURCE_FLAG_GLOBAL = 2;
		public const uint32 WHEA_ERROR_SOURCE_FLAG_GHES_ASSIST = 4;
		public const uint32 WHEA_ERROR_SOURCE_FLAG_DEFAULTSOURCE = 2147483648;
		public const uint32 WHEA_ERROR_SOURCE_INVALID_RELATED_SOURCE = 65535;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFMCE = 0;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFCMC = 1;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_XPFNMI = 2;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFMCA = 3;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCMC = 4;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_IPFCPE = 5;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERROOTPORT = 6;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERENDPOINT = 7;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_AERBRIDGE = 8;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC = 9;
		public const uint32 WHEA_ERROR_SOURCE_DESCRIPTOR_TYPE_GENERIC_V2 = 10;
		public const uint32 WHEA_XPF_MC_BANK_STATUSFORMAT_IA32MCA = 0;
		public const uint32 WHEA_XPF_MC_BANK_STATUSFORMAT_Intel64MCA = 1;
		public const uint32 WHEA_XPF_MC_BANK_STATUSFORMAT_AMD64MCA = 2;
		public const uint32 WHEA_NOTIFICATION_TYPE_POLLED = 0;
		public const uint32 WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT = 1;
		public const uint32 WHEA_NOTIFICATION_TYPE_LOCALINTERRUPT = 2;
		public const uint32 WHEA_NOTIFICATION_TYPE_SCI = 3;
		public const uint32 WHEA_NOTIFICATION_TYPE_NMI = 4;
		public const uint32 WHEA_NOTIFICATION_TYPE_CMCI = 5;
		public const uint32 WHEA_NOTIFICATION_TYPE_MCE = 6;
		public const uint32 WHEA_NOTIFICATION_TYPE_GPIO_SIGNAL = 7;
		public const uint32 WHEA_NOTIFICATION_TYPE_ARMV8_SEA = 8;
		public const uint32 WHEA_NOTIFICATION_TYPE_ARMV8_SEI = 9;
		public const uint32 WHEA_NOTIFICATION_TYPE_EXTERNALINTERRUPT_GSIV = 10;
		public const uint32 WHEA_NOTIFICATION_TYPE_SDEI = 11;
		public const uint32 WHEA_DEVICE_DRIVER_CONFIG_V1 = 1;
		public const uint32 WHEA_DEVICE_DRIVER_CONFIG_V2 = 2;
		public const uint32 WHEA_DEVICE_DRIVER_CONFIG_MIN = 1;
		public const uint32 WHEA_DEVICE_DRIVER_CONFIG_MAX = 2;
		public const uint32 WHEA_DEVICE_DRIVER_BUFFER_SET_V1 = 1;
		public const uint32 WHEA_DEVICE_DRIVER_BUFFER_SET_MIN = 1;
		public const uint32 WHEA_DEVICE_DRIVER_BUFFER_SET_MAX = 1;
		public const uint32 WHEA_DISABLE_OFFLINE = 0;
		public const uint32 WHEA_MEM_PERSISTOFFLINE = 1;
		public const uint32 WHEA_MEM_PFA_DISABLE = 2;
		public const uint32 WHEA_MEM_PFA_PAGECOUNT = 3;
		public const uint32 WHEA_MEM_PFA_THRESHOLD = 4;
		public const uint32 WHEA_MEM_PFA_TIMEOUT = 5;
		public const uint32 WHEA_DISABLE_DUMMY_WRITE = 6;
		public const uint32 WHEA_RESTORE_CMCI_ENABLED = 7;
		public const uint32 WHEA_RESTORE_CMCI_ATTEMPTS = 8;
		public const uint32 WHEA_RESTORE_CMCI_ERR_LIMIT = 9;
		public const uint32 WHEA_CMCI_THRESHOLD_COUNT = 10;
		public const uint32 WHEA_CMCI_THRESHOLD_TIME = 11;
		public const uint32 WHEA_CMCI_THRESHOLD_POLL_COUNT = 12;
		public const uint32 WHEA_PENDING_PAGE_LIST_SZ = 13;
		public const uint32 WHEA_BAD_PAGE_LIST_MAX_SIZE = 14;
		public const uint32 WHEA_BAD_PAGE_LIST_LOCATION = 15;
		public const uint32 WHEA_NOTIFY_ALL_OFFLINES = 16;
		public const uint32 IPMI_OS_SEL_RECORD_VERSION_1 = 1;
		public const uint32 IPMI_OS_SEL_RECORD_VERSION = 1;
		public const uint32 IPMI_IOCTL_INDEX = 1024;
		public const uint32 IOCTL_IPMI_INTERNAL_RECORD_SEL_EVENT = 2232320;
		public const uint32 IPMI_OS_SEL_RECORD_MASK = 65535;
		public const int32 DBGKD_SIMULATION_NONE = 0;
		public const int32 DBGKD_SIMULATION_EXDI = 1;
		public const HResult ACTIVPROF_E_PROFILER_PRESENT = (.)-2147220992;
		public const HResult ACTIVPROF_E_PROFILER_ABSENT = (.)-2147220991;
		public const HResult ACTIVPROF_E_UNABLE_TO_APPLY_ACTION = (.)-2147220990;
		public const uint32 PROFILER_HEAP_OBJECT_NAME_ID_UNAVAILABLE = 4294967295;
		public const int32 sevMax = 4;
		public const uint32 fasaPreferInternalHandler = 1;
		public const uint32 fasaSupportInternalHandler = 2;
		public const uint32 fasaCaseSensitive = 4;
		public const uint32 SCRIPT_CMPL_NOLIST = 0;
		public const uint32 SCRIPT_CMPL_MEMBERLIST = 1;
		public const uint32 SCRIPT_CMPL_ENUMLIST = 2;
		public const uint32 SCRIPT_CMPL_PARAMTIP = 4;
		public const uint32 SCRIPT_CMPL_GLOBALLIST = 8;
		public const uint32 SCRIPT_CMPL_ENUM_TRIGGER = 1;
		public const uint32 SCRIPT_CMPL_MEMBER_TRIGGER = 2;
		public const uint32 SCRIPT_CMPL_PARAM_TRIGGER = 3;
		public const uint32 SCRIPT_CMPL_COMMIT = 4;
		public const uint32 GETATTRTYPE_NORMAL = 0;
		public const uint32 GETATTRTYPE_DEPSCAN = 1;
		public const uint32 GETATTRFLAG_THIS = 256;
		public const uint32 GETATTRFLAG_HUMANTEXT = 32768;
		public const uint32 SOURCETEXT_ATTR_HUMANTEXT = 32768;
		public const uint32 SOURCETEXT_ATTR_IDENTIFIER = 256;
		public const uint32 SOURCETEXT_ATTR_MEMBERLOOKUP = 512;
		public const uint32 SOURCETEXT_ATTR_THIS = 1024;
		
		// --- Enums ---
		
		public enum SYM_LOAD_FLAGS : uint32
		{
			NONE = 0,
			VIRTUAL = 1,
			ALT_INDEX = 2,
			NO_SYMBOLS = 4,
		}
		[AllowDuplicates]
		public enum IMAGE_SECTION_CHARACTERISTICS : uint32
		{
			TYPE_NO_PAD = 8,
			CNT_CODE = 32,
			CNT_INITIALIZED_DATA = 64,
			CNT_UNINITIALIZED_DATA = 128,
			LNK_OTHER = 256,
			LNK_INFO = 512,
			LNK_REMOVE = 2048,
			LNK_COMDAT = 4096,
			NO_DEFER_SPEC_EXC = 16384,
			GPREL = 32768,
			MEM_FARDATA = 32768,
			MEM_PURGEABLE = 131072,
			MEM_16BIT = 131072,
			MEM_LOCKED = 262144,
			MEM_PRELOAD = 524288,
			ALIGN_1BYTES = 1048576,
			ALIGN_2BYTES = 2097152,
			ALIGN_4BYTES = 3145728,
			ALIGN_8BYTES = 4194304,
			ALIGN_16BYTES = 5242880,
			ALIGN_32BYTES = 6291456,
			ALIGN_64BYTES = 7340032,
			ALIGN_128BYTES = 8388608,
			ALIGN_256BYTES = 9437184,
			ALIGN_512BYTES = 10485760,
			ALIGN_1024BYTES = 11534336,
			ALIGN_2048BYTES = 12582912,
			ALIGN_4096BYTES = 13631488,
			ALIGN_8192BYTES = 14680064,
			ALIGN_MASK = 15728640,
			LNK_NRELOC_OVFL = 16777216,
			MEM_DISCARDABLE = 33554432,
			MEM_NOT_CACHED = 67108864,
			MEM_NOT_PAGED = 134217728,
			MEM_SHARED = 268435456,
			MEM_EXECUTE = 536870912,
			MEM_READ = 1073741824,
			MEM_WRITE = 2147483648,
			SCALE_INDEX = 1,
		}
		[AllowDuplicates]
		public enum IMAGE_FILE_MACHINE : uint16
		{
			AXP64 = 644,
			I386 = 332,
			IA64 = 512,
			AMD64 = 34404,
			UNKNOWN = 0,
			TARGET_HOST = 1,
			R3000 = 354,
			R4000 = 358,
			R10000 = 360,
			WCEMIPSV2 = 361,
			ALPHA = 388,
			SH3 = 418,
			SH3DSP = 419,
			SH3E = 420,
			SH4 = 422,
			SH5 = 424,
			ARM = 448,
			THUMB = 450,
			ARMNT = 452,
			AM33 = 467,
			POWERPC = 496,
			POWERPCFP = 497,
			MIPS16 = 614,
			ALPHA64 = 644,
			MIPSFPU = 870,
			MIPSFPU16 = 1126,
			TRICORE = 1312,
			CEF = 3311,
			EBC = 3772,
			M32R = 36929,
			ARM64 = 43620,
			CEE = 49390,
		}
		public enum IMAGE_SUBSYSTEM : uint16
		{
			UNKNOWN = 0,
			NATIVE = 1,
			WINDOWS_GUI = 2,
			WINDOWS_CUI = 3,
			OS2_CUI = 5,
			POSIX_CUI = 7,
			NATIVE_WINDOWS = 8,
			WINDOWS_CE_GUI = 9,
			EFI_APPLICATION = 10,
			EFI_BOOT_SERVICE_DRIVER = 11,
			EFI_RUNTIME_DRIVER = 12,
			EFI_ROM = 13,
			XBOX = 14,
			WINDOWS_BOOT_APPLICATION = 16,
			XBOX_CODE_CATALOG = 17,
		}
		[AllowDuplicates]
		public enum IMAGE_DLL_CHARACTERISTICS : uint16
		{
			HIGH_ENTROPY_VA = 32,
			DYNAMIC_BASE = 64,
			FORCE_INTEGRITY = 128,
			NX_COMPAT = 256,
			NO_ISOLATION = 512,
			NO_SEH = 1024,
			NO_BIND = 2048,
			APPCONTAINER = 4096,
			WDM_DRIVER = 8192,
			GUARD_CF = 16384,
			TERMINAL_SERVER_AWARE = 32768,
			EX_CET_COMPAT = 1,
			EX_CET_COMPAT_STRICT_MODE = 2,
			EX_CET_SET_CONTEXT_IP_VALIDATION_RELAXED_MODE = 4,
			EX_CET_DYNAMIC_APIS_ALLOW_IN_PROC = 8,
			EX_CET_RESERVED_1 = 16,
			EX_CET_RESERVED_2 = 32,
		}
		[AllowDuplicates]
		public enum IMAGE_OPTIONAL_HEADER_MAGIC : uint16
		{
			NT_OPTIONAL_HDR_MAGIC = 523,
			NT_OPTIONAL_HDR32_MAGIC = 267,
			NT_OPTIONAL_HDR64_MAGIC = 523,
			ROM_OPTIONAL_HDR_MAGIC = 263,
		}
		public enum BUGCHECK_ERROR : uint32
		{
			HARDWARE_PROFILE_UNDOCKED_STRING = 1073807361,
			HARDWARE_PROFILE_DOCKED_STRING = 1073807362,
			HARDWARE_PROFILE_UNKNOWN_STRING = 1073807363,
			WINDOWS_NT_BANNER = 1073741950,
			WINDOWS_NT_CSD_STRING = 1073741959,
			WINDOWS_NT_INFO_STRING = 1073741960,
			WINDOWS_NT_MP_STRING = 1073741961,
			THREAD_TERMINATE_HELD_MUTEX = 1073741962,
			WINDOWS_NT_INFO_STRING_PLURAL = 1073741981,
			WINDOWS_NT_RC_STRING = 1073741982,
			APC_INDEX_MISMATCH = 1,
			DEVICE_QUEUE_NOT_BUSY = 2,
			INVALID_AFFINITY_SET = 3,
			INVALID_DATA_ACCESS_TRAP = 4,
			INVALID_PROCESS_ATTACH_ATTEMPT = 5,
			INVALID_PROCESS_DETACH_ATTEMPT = 6,
			INVALID_SOFTWARE_INTERRUPT = 7,
			IRQL_NOT_DISPATCH_LEVEL = 8,
			IRQL_NOT_GREATER_OR_EQUAL = 9,
			IRQL_NOT_LESS_OR_EQUAL = 10,
			NO_EXCEPTION_HANDLING_SUPPORT = 11,
			MAXIMUM_WAIT_OBJECTS_EXCEEDED = 12,
			MUTEX_LEVEL_NUMBER_VIOLATION = 13,
			NO_USER_MODE_CONTEXT = 14,
			SPIN_LOCK_ALREADY_OWNED = 15,
			SPIN_LOCK_NOT_OWNED = 16,
			THREAD_NOT_MUTEX_OWNER = 17,
			TRAP_CAUSE_UNKNOWN = 18,
			EMPTY_THREAD_REAPER_LIST = 19,
			CREATE_DELETE_LOCK_NOT_LOCKED = 20,
			LAST_CHANCE_CALLED_FROM_KMODE = 21,
			CID_HANDLE_CREATION = 22,
			CID_HANDLE_DELETION = 23,
			REFERENCE_BY_POINTER = 24,
			BAD_POOL_HEADER = 25,
			MEMORY_MANAGEMENT = 26,
			PFN_SHARE_COUNT = 27,
			PFN_REFERENCE_COUNT = 28,
			NO_SPIN_LOCK_AVAILABLE = 29,
			KMODE_EXCEPTION_NOT_HANDLED = 30,
			SHARED_RESOURCE_CONV_ERROR = 31,
			KERNEL_APC_PENDING_DURING_EXIT = 32,
			QUOTA_UNDERFLOW = 33,
			FILE_SYSTEM = 34,
			FAT_FILE_SYSTEM = 35,
			NTFS_FILE_SYSTEM = 36,
			NPFS_FILE_SYSTEM = 37,
			CDFS_FILE_SYSTEM = 38,
			RDR_FILE_SYSTEM = 39,
			CORRUPT_ACCESS_TOKEN = 40,
			SECURITY_SYSTEM = 41,
			INCONSISTENT_IRP = 42,
			PANIC_STACK_SWITCH = 43,
			PORT_DRIVER_INTERNAL = 44,
			SCSI_DISK_DRIVER_INTERNAL = 45,
			DATA_BUS_ERROR = 46,
			INSTRUCTION_BUS_ERROR = 47,
			SET_OF_INVALID_CONTEXT = 48,
			PHASE0_INITIALIZATION_FAILED = 49,
			PHASE1_INITIALIZATION_FAILED = 50,
			UNEXPECTED_INITIALIZATION_CALL = 51,
			CACHE_MANAGER = 52,
			NO_MORE_IRP_STACK_LOCATIONS = 53,
			DEVICE_REFERENCE_COUNT_NOT_ZERO = 54,
			FLOPPY_INTERNAL_ERROR = 55,
			SERIAL_DRIVER_INTERNAL = 56,
			SYSTEM_EXIT_OWNED_MUTEX = 57,
			SYSTEM_UNWIND_PREVIOUS_USER = 58,
			SYSTEM_SERVICE_EXCEPTION = 59,
			INTERRUPT_UNWIND_ATTEMPTED = 60,
			INTERRUPT_EXCEPTION_NOT_HANDLED = 61,
			MULTIPROCESSOR_CONFIGURATION_NOT_SUPPORTED = 62,
			NO_MORE_SYSTEM_PTES = 63,
			TARGET_MDL_TOO_SMALL = 64,
			MUST_SUCCEED_POOL_EMPTY = 65,
			ATDISK_DRIVER_INTERNAL = 66,
			NO_SUCH_PARTITION = 67,
			MULTIPLE_IRP_COMPLETE_REQUESTS = 68,
			INSUFFICIENT_SYSTEM_MAP_REGS = 69,
			DEREF_UNKNOWN_LOGON_SESSION = 70,
			REF_UNKNOWN_LOGON_SESSION = 71,
			CANCEL_STATE_IN_COMPLETED_IRP = 72,
			PAGE_FAULT_WITH_INTERRUPTS_OFF = 73,
			IRQL_GT_ZERO_AT_SYSTEM_SERVICE = 74,
			STREAMS_INTERNAL_ERROR = 75,
			FATAL_UNHANDLED_HARD_ERROR = 76,
			NO_PAGES_AVAILABLE = 77,
			PFN_LIST_CORRUPT = 78,
			NDIS_INTERNAL_ERROR = 79,
			PAGE_FAULT_IN_NONPAGED_AREA = 80,
			PAGE_FAULT_IN_NONPAGED_AREA_M = 268435536,
			REGISTRY_ERROR = 81,
			MAILSLOT_FILE_SYSTEM = 82,
			NO_BOOT_DEVICE = 83,
			LM_SERVER_INTERNAL_ERROR = 84,
			DATA_COHERENCY_EXCEPTION = 85,
			INSTRUCTION_COHERENCY_EXCEPTION = 86,
			XNS_INTERNAL_ERROR = 87,
			VOLMGRX_INTERNAL_ERROR = 88,
			PINBALL_FILE_SYSTEM = 89,
			CRITICAL_SERVICE_FAILED = 90,
			SET_ENV_VAR_FAILED = 91,
			HAL_INITIALIZATION_FAILED = 92,
			UNSUPPORTED_PROCESSOR = 93,
			OBJECT_INITIALIZATION_FAILED = 94,
			SECURITY_INITIALIZATION_FAILED = 95,
			PROCESS_INITIALIZATION_FAILED = 96,
			HAL1_INITIALIZATION_FAILED = 97,
			OBJECT1_INITIALIZATION_FAILED = 98,
			SECURITY1_INITIALIZATION_FAILED = 99,
			SYMBOLIC_INITIALIZATION_FAILED = 100,
			MEMORY1_INITIALIZATION_FAILED = 101,
			CACHE_INITIALIZATION_FAILED = 102,
			CONFIG_INITIALIZATION_FAILED = 103,
			FILE_INITIALIZATION_FAILED = 104,
			IO1_INITIALIZATION_FAILED = 105,
			LPC_INITIALIZATION_FAILED = 106,
			PROCESS1_INITIALIZATION_FAILED = 107,
			REFMON_INITIALIZATION_FAILED = 108,
			SESSION1_INITIALIZATION_FAILED = 109,
			BOOTPROC_INITIALIZATION_FAILED = 110,
			VSL_INITIALIZATION_FAILED = 111,
			SOFT_RESTART_FATAL_ERROR = 112,
			ASSIGN_DRIVE_LETTERS_FAILED = 114,
			CONFIG_LIST_FAILED = 115,
			BAD_SYSTEM_CONFIG_INFO = 116,
			CANNOT_WRITE_CONFIGURATION = 117,
			PROCESS_HAS_LOCKED_PAGES = 118,
			KERNEL_STACK_INPAGE_ERROR = 119,
			PHASE0_EXCEPTION = 120,
			MISMATCHED_HAL = 121,
			KERNEL_DATA_INPAGE_ERROR = 122,
			INACCESSIBLE_BOOT_DEVICE = 123,
			BUGCODE_NDIS_DRIVER = 124,
			INSTALL_MORE_MEMORY = 125,
			SYSTEM_THREAD_EXCEPTION_NOT_HANDLED = 126,
			SYSTEM_THREAD_EXCEPTION_NOT_HANDLED_M = 268435582,
			UNEXPECTED_KERNEL_MODE_TRAP = 127,
			UNEXPECTED_KERNEL_MODE_TRAP_M = 268435583,
			NMI_HARDWARE_FAILURE = 128,
			SPIN_LOCK_INIT_FAILURE = 129,
			DFS_FILE_SYSTEM = 130,
			OFS_FILE_SYSTEM = 131,
			RECOM_DRIVER = 132,
			SETUP_FAILURE = 133,
			AUDIT_FAILURE = 134,
			MBR_CHECKSUM_MISMATCH = 139,
			KERNEL_MODE_EXCEPTION_NOT_HANDLED = 142,
			KERNEL_MODE_EXCEPTION_NOT_HANDLED_M = 268435598,
			PP0_INITIALIZATION_FAILED = 143,
			PP1_INITIALIZATION_FAILED = 144,
			WIN32K_INIT_OR_RIT_FAILURE = 145,
			UP_DRIVER_ON_MP_SYSTEM = 146,
			INVALID_KERNEL_HANDLE = 147,
			KERNEL_STACK_LOCKED_AT_EXIT = 148,
			PNP_INTERNAL_ERROR = 149,
			INVALID_WORK_QUEUE_ITEM = 150,
			BOUND_IMAGE_UNSUPPORTED = 151,
			END_OF_NT_EVALUATION_PERIOD = 152,
			INVALID_REGION_OR_SEGMENT = 153,
			SYSTEM_LICENSE_VIOLATION = 154,
			UDFS_FILE_SYSTEM = 155,
			MACHINE_CHECK_EXCEPTION = 156,
			USER_MODE_HEALTH_MONITOR = 158,
			DRIVER_POWER_STATE_FAILURE = 159,
			INTERNAL_POWER_ERROR = 160,
			PCI_BUS_DRIVER_INTERNAL = 161,
			MEMORY_IMAGE_CORRUPT = 162,
			ACPI_DRIVER_INTERNAL = 163,
			CNSS_FILE_SYSTEM_FILTER = 164,
			ACPI_BIOS_ERROR = 165,
			FP_EMULATION_ERROR = 166,
			BAD_EXHANDLE = 167,
			BOOTING_IN_SAFEMODE_MINIMAL = 168,
			BOOTING_IN_SAFEMODE_NETWORK = 169,
			BOOTING_IN_SAFEMODE_DSREPAIR = 170,
			SESSION_HAS_VALID_POOL_ON_EXIT = 171,
			HAL_MEMORY_ALLOCATION = 172,
			VIDEO_DRIVER_DEBUG_REPORT_REQUEST = 1073741997,
			BGI_DETECTED_VIOLATION = 177,
			VIDEO_DRIVER_INIT_FAILURE = 180,
			BOOTLOG_LOADED = 181,
			BOOTLOG_NOT_LOADED = 182,
			BOOTLOG_ENABLED = 183,
			ATTEMPTED_SWITCH_FROM_DPC = 184,
			CHIPSET_DETECTED_ERROR = 185,
			SESSION_HAS_VALID_VIEWS_ON_EXIT = 186,
			NETWORK_BOOT_INITIALIZATION_FAILED = 187,
			NETWORK_BOOT_DUPLICATE_ADDRESS = 188,
			INVALID_HIBERNATED_STATE = 189,
			ATTEMPTED_WRITE_TO_READONLY_MEMORY = 190,
			MUTEX_ALREADY_OWNED = 191,
			PCI_CONFIG_SPACE_ACCESS_FAILURE = 192,
			SPECIAL_POOL_DETECTED_MEMORY_CORRUPTION = 193,
			BAD_POOL_CALLER = 194,
			SYSTEM_IMAGE_BAD_SIGNATURE = 195,
			DRIVER_VERIFIER_DETECTED_VIOLATION = 196,
			DRIVER_CORRUPTED_EXPOOL = 197,
			DRIVER_CAUGHT_MODIFYING_FREED_POOL = 198,
			TIMER_OR_DPC_INVALID = 199,
			IRQL_UNEXPECTED_VALUE = 200,
			DRIVER_VERIFIER_IOMANAGER_VIOLATION = 201,
			PNP_DETECTED_FATAL_ERROR = 202,
			DRIVER_LEFT_LOCKED_PAGES_IN_PROCESS = 203,
			PAGE_FAULT_IN_FREED_SPECIAL_POOL = 204,
			PAGE_FAULT_BEYOND_END_OF_ALLOCATION = 205,
			DRIVER_UNLOADED_WITHOUT_CANCELLING_PENDING_OPERATIONS = 206,
			TERMINAL_SERVER_DRIVER_MADE_INCORRECT_MEMORY_REFERENCE = 207,
			DRIVER_CORRUPTED_MMPOOL = 208,
			DRIVER_IRQL_NOT_LESS_OR_EQUAL = 209,
			BUGCODE_ID_DRIVER = 210,
			DRIVER_PORTION_MUST_BE_NONPAGED = 211,
			SYSTEM_SCAN_AT_RAISED_IRQL_CAUGHT_IMPROPER_DRIVER_UNLOAD = 212,
			DRIVER_PAGE_FAULT_IN_FREED_SPECIAL_POOL = 213,
			DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION = 214,
			DRIVER_PAGE_FAULT_BEYOND_END_OF_ALLOCATION_M = 268435670,
			DRIVER_UNMAPPING_INVALID_VIEW = 215,
			DRIVER_USED_EXCESSIVE_PTES = 216,
			LOCKED_PAGES_TRACKER_CORRUPTION = 217,
			SYSTEM_PTE_MISUSE = 218,
			DRIVER_CORRUPTED_SYSPTES = 219,
			DRIVER_INVALID_STACK_ACCESS = 220,
			POOL_CORRUPTION_IN_FILE_AREA = 222,
			IMPERSONATING_WORKER_THREAD = 223,
			ACPI_BIOS_FATAL_ERROR = 224,
			WORKER_THREAD_RETURNED_AT_BAD_IRQL = 225,
			MANUALLY_INITIATED_CRASH = 226,
			RESOURCE_NOT_OWNED = 227,
			WORKER_INVALID = 228,
			POWER_FAILURE_SIMULATE = 229,
			DRIVER_VERIFIER_DMA_VIOLATION = 230,
			INVALID_FLOATING_POINT_STATE = 231,
			INVALID_CANCEL_OF_FILE_OPEN = 232,
			ACTIVE_EX_WORKER_THREAD_TERMINATION = 233,
			SAVER_UNSPECIFIED = 61440,
			SAVER_BLANKSCREEN = 61442,
			SAVER_INPUT = 61443,
			SAVER_WATCHDOG = 61444,
			SAVER_STARTNOTVISIBLE = 61445,
			SAVER_NAVIGATIONMODEL = 61446,
			SAVER_OUTOFMEMORY = 61447,
			SAVER_GRAPHICS = 61448,
			SAVER_NAVSERVERTIMEOUT = 61449,
			SAVER_CHROMEPROCESSCRASH = 61450,
			SAVER_NOTIFICATIONDISMISSAL = 61451,
			SAVER_SPEECHDISMISSAL = 61452,
			SAVER_CALLDISMISSAL = 61453,
			SAVER_APPBARDISMISSAL = 61454,
			SAVER_RILADAPTATIONCRASH = 61455,
			SAVER_APPLISTUNREACHABLE = 61456,
			SAVER_REPORTNOTIFICATIONFAILURE = 61457,
			SAVER_UNEXPECTEDSHUTDOWN = 61458,
			SAVER_RPCFAILURE = 61459,
			SAVER_AUXILIARYFULLDUMP = 61460,
			SAVER_ACCOUNTPROVSVCINITFAILURE = 61461,
			SAVER_MTBFCOMMANDTIMEOUT = 789,
			SAVER_MTBFCOMMANDHANG = 61697,
			SAVER_MTBFPASSBUGCHECK = 61698,
			SAVER_MTBFIOERROR = 61699,
			SAVER_RENDERTHREADHANG = 61952,
			SAVER_RENDERMOBILEUIOOM = 61953,
			SAVER_DEVICEUPDATEUNSPECIFIED = 62208,
			SAVER_AUDIODRIVERHANG = 62464,
			SAVER_BATTERYPULLOUT = 62720,
			SAVER_MEDIACORETESTHANG = 62976,
			SAVER_RESOURCEMANAGEMENT = 63232,
			SAVER_CAPTURESERVICE = 63488,
			SAVER_WAITFORSHELLREADY = 63744,
			SAVER_NONRESPONSIVEPROCESS = 404,
			SAVER_SICKAPPLICATION = 34918,
			THREAD_STUCK_IN_DEVICE_DRIVER = 234,
			THREAD_STUCK_IN_DEVICE_DRIVER_M = 268435690,
			DIRTY_MAPPED_PAGES_CONGESTION = 235,
			SESSION_HAS_VALID_SPECIAL_POOL_ON_EXIT = 236,
			UNMOUNTABLE_BOOT_VOLUME = 237,
			CRITICAL_PROCESS_DIED = 239,
			STORAGE_MINIPORT_ERROR = 240,
			SCSI_VERIFIER_DETECTED_VIOLATION = 241,
			HARDWARE_INTERRUPT_STORM = 242,
			DISORDERLY_SHUTDOWN = 243,
			CRITICAL_OBJECT_TERMINATION = 244,
			FLTMGR_FILE_SYSTEM = 245,
			PCI_VERIFIER_DETECTED_VIOLATION = 246,
			DRIVER_OVERRAN_STACK_BUFFER = 247,
			RAMDISK_BOOT_INITIALIZATION_FAILED = 248,
			DRIVER_RETURNED_STATUS_REPARSE_FOR_VOLUME_OPEN = 249,
			HTTP_DRIVER_CORRUPTED = 250,
			RECURSIVE_MACHINE_CHECK = 251,
			ATTEMPTED_EXECUTE_OF_NOEXECUTE_MEMORY = 252,
			DIRTY_NOWRITE_PAGES_CONGESTION = 253,
			BUGCODE_USB_DRIVER = 254,
			BC_BLUETOOTH_VERIFIER_FAULT = 3070,
			BC_BTHMINI_VERIFIER_FAULT = 3071,
			RESERVE_QUEUE_OVERFLOW = 255,
			LOADER_BLOCK_MISMATCH = 256,
			CLOCK_WATCHDOG_TIMEOUT = 257,
			DPC_WATCHDOG_TIMEOUT = 258,
			MUP_FILE_SYSTEM = 259,
			AGP_INVALID_ACCESS = 260,
			AGP_GART_CORRUPTION = 261,
			AGP_ILLEGALLY_REPROGRAMMED = 262,
			KERNEL_EXPAND_STACK_ACTIVE = 263,
			THIRD_PARTY_FILE_SYSTEM_FAILURE = 264,
			CRITICAL_STRUCTURE_CORRUPTION = 265,
			APP_TAGGING_INITIALIZATION_FAILED = 266,
			DFSC_FILE_SYSTEM = 267,
			FSRTL_EXTRA_CREATE_PARAMETER_VIOLATION = 268,
			WDF_VIOLATION = 269,
			VIDEO_MEMORY_MANAGEMENT_INTERNAL = 270,
			DRIVER_INVALID_CRUNTIME_PARAMETER = 272,
			RECURSIVE_NMI = 273,
			MSRPC_STATE_VIOLATION = 274,
			VIDEO_DXGKRNL_FATAL_ERROR = 275,
			VIDEO_SHADOW_DRIVER_FATAL_ERROR = 276,
			AGP_INTERNAL = 277,
			VIDEO_TDR_FAILURE = 278,
			VIDEO_TDR_TIMEOUT_DETECTED = 279,
			NTHV_GUEST_ERROR = 280,
			VIDEO_SCHEDULER_INTERNAL_ERROR = 281,
			EM_INITIALIZATION_ERROR = 282,
			DRIVER_RETURNED_HOLDING_CANCEL_LOCK = 283,
			ATTEMPTED_WRITE_TO_CM_PROTECTED_STORAGE = 284,
			EVENT_TRACING_FATAL_ERROR = 285,
			TOO_MANY_RECURSIVE_FAULTS = 286,
			INVALID_DRIVER_HANDLE = 287,
			BITLOCKER_FATAL_ERROR = 288,
			DRIVER_VIOLATION = 289,
			WHEA_INTERNAL_ERROR = 290,
			CRYPTO_SELF_TEST_FAILURE = 291,
			WHEA_UNCORRECTABLE_ERROR = 292,
			NMR_INVALID_STATE = 293,
			NETIO_INVALID_POOL_CALLER = 294,
			PAGE_NOT_ZERO = 295,
			WORKER_THREAD_RETURNED_WITH_BAD_IO_PRIORITY = 296,
			WORKER_THREAD_RETURNED_WITH_BAD_PAGING_IO_PRIORITY = 297,
			MUI_NO_VALID_SYSTEM_LANGUAGE = 298,
			FAULTY_HARDWARE_CORRUPTED_PAGE = 299,
			EXFAT_FILE_SYSTEM = 300,
			VOLSNAP_OVERLAPPED_TABLE_ACCESS = 301,
			INVALID_MDL_RANGE = 302,
			VHD_BOOT_INITIALIZATION_FAILED = 303,
			DYNAMIC_ADD_PROCESSOR_MISMATCH = 304,
			INVALID_EXTENDED_PROCESSOR_STATE = 305,
			RESOURCE_OWNER_POINTER_INVALID = 306,
			DPC_WATCHDOG_VIOLATION = 307,
			DRIVE_EXTENDER = 308,
			REGISTRY_FILTER_DRIVER_EXCEPTION = 309,
			VHD_BOOT_HOST_VOLUME_NOT_ENOUGH_SPACE = 310,
			WIN32K_HANDLE_MANAGER = 311,
			GPIO_CONTROLLER_DRIVER_ERROR = 312,
			KERNEL_SECURITY_CHECK_FAILURE = 313,
			KERNEL_MODE_HEAP_CORRUPTION = 314,
			PASSIVE_INTERRUPT_ERROR = 315,
			INVALID_IO_BOOST_STATE = 316,
			CRITICAL_INITIALIZATION_FAILURE = 317,
			ERRATA_WORKAROUND_UNSUCCESSFUL = 318,
			REGISTRY_CALLBACK_DRIVER_EXCEPTION = 319,
			STORAGE_DEVICE_ABNORMALITY_DETECTED = 320,
			VIDEO_ENGINE_TIMEOUT_DETECTED = 321,
			VIDEO_TDR_APPLICATION_BLOCKED = 322,
			PROCESSOR_DRIVER_INTERNAL = 323,
			BUGCODE_USB3_DRIVER = 324,
			SECURE_BOOT_VIOLATION = 325,
			NDIS_NET_BUFFER_LIST_INFO_ILLEGALLY_TRANSFERRED = 326,
			ABNORMAL_RESET_DETECTED = 327,
			IO_OBJECT_INVALID = 328,
			REFS_FILE_SYSTEM = 329,
			KERNEL_WMI_INTERNAL = 330,
			SOC_SUBSYSTEM_FAILURE = 331,
			FATAL_ABNORMAL_RESET_ERROR = 332,
			EXCEPTION_SCOPE_INVALID = 333,
			SOC_CRITICAL_DEVICE_REMOVED = 334,
			PDC_WATCHDOG_TIMEOUT = 335,
			TCPIP_AOAC_NIC_ACTIVE_REFERENCE_LEAK = 336,
			UNSUPPORTED_INSTRUCTION_MODE = 337,
			INVALID_PUSH_LOCK_FLAGS = 338,
			KERNEL_LOCK_ENTRY_LEAKED_ON_THREAD_TERMINATION = 339,
			UNEXPECTED_STORE_EXCEPTION = 340,
			OS_DATA_TAMPERING = 341,
			WINSOCK_DETECTED_HUNG_CLOSESOCKET_LIVEDUMP = 342,
			KERNEL_THREAD_PRIORITY_FLOOR_VIOLATION = 343,
			ILLEGAL_IOMMU_PAGE_FAULT = 344,
			HAL_ILLEGAL_IOMMU_PAGE_FAULT = 345,
			SDBUS_INTERNAL_ERROR = 346,
			WORKER_THREAD_RETURNED_WITH_SYSTEM_PAGE_PRIORITY_ACTIVE = 347,
			PDC_WATCHDOG_TIMEOUT_LIVEDUMP = 348,
			SOC_SUBSYSTEM_FAILURE_LIVEDUMP = 349,
			BUGCODE_NDIS_DRIVER_LIVE_DUMP = 350,
			CONNECTED_STANDBY_WATCHDOG_TIMEOUT_LIVEDUMP = 351,
			WIN32K_ATOMIC_CHECK_FAILURE = 352,
			LIVE_SYSTEM_DUMP = 353,
			KERNEL_AUTO_BOOST_INVALID_LOCK_RELEASE = 354,
			WORKER_THREAD_TEST_CONDITION = 355,
			WIN32K_CRITICAL_FAILURE = 356,
			CLUSTER_CSV_STATUS_IO_TIMEOUT_LIVEDUMP = 357,
			CLUSTER_RESOURCE_CALL_TIMEOUT_LIVEDUMP = 358,
			CLUSTER_CSV_SNAPSHOT_DEVICE_INFO_TIMEOUT_LIVEDUMP = 359,
			CLUSTER_CSV_STATE_TRANSITION_TIMEOUT_LIVEDUMP = 360,
			CLUSTER_CSV_VOLUME_ARRIVAL_LIVEDUMP = 361,
			CLUSTER_CSV_VOLUME_REMOVAL_LIVEDUMP = 362,
			CLUSTER_CSV_CLUSTER_WATCHDOG_LIVEDUMP = 363,
			INVALID_RUNDOWN_PROTECTION_FLAGS = 364,
			INVALID_SLOT_ALLOCATOR_FLAGS = 365,
			ERESOURCE_INVALID_RELEASE = 366,
			CLUSTER_CSV_STATE_TRANSITION_INTERVAL_TIMEOUT_LIVEDUMP = 367,
			CLUSTER_CSV_CLUSSVC_DISCONNECT_WATCHDOG = 368,
			CRYPTO_LIBRARY_INTERNAL_ERROR = 369,
			COREMSGCALL_INTERNAL_ERROR = 371,
			COREMSG_INTERNAL_ERROR = 372,
			PREVIOUS_FATAL_ABNORMAL_RESET_ERROR = 373,
			ELAM_DRIVER_DETECTED_FATAL_ERROR = 376,
			CLUSTER_CLUSPORT_STATUS_IO_TIMEOUT_LIVEDUMP = 377,
			PROFILER_CONFIGURATION_ILLEGAL = 379,
			PDC_LOCK_WATCHDOG_LIVEDUMP = 380,
			PDC_UNEXPECTED_REVOCATION_LIVEDUMP = 381,
			MICROCODE_REVISION_MISMATCH = 382,
			HYPERGUARD_INITIALIZATION_FAILURE = 383,
			WVR_LIVEDUMP_REPLICATION_IOCONTEXT_TIMEOUT = 384,
			WVR_LIVEDUMP_STATE_TRANSITION_TIMEOUT = 385,
			WVR_LIVEDUMP_RECOVERY_IOCONTEXT_TIMEOUT = 386,
			WVR_LIVEDUMP_APP_IO_TIMEOUT = 387,
			WVR_LIVEDUMP_MANUALLY_INITIATED = 388,
			WVR_LIVEDUMP_STATE_FAILURE = 389,
			WVR_LIVEDUMP_CRITICAL_ERROR = 390,
			VIDEO_DWMINIT_TIMEOUT_FALLBACK_BDD = 391,
			CLUSTER_CSVFS_LIVEDUMP = 392,
			BAD_OBJECT_HEADER = 393,
			SILO_CORRUPT = 394,
			SECURE_KERNEL_ERROR = 395,
			HYPERGUARD_VIOLATION = 396,
			SECURE_FAULT_UNHANDLED = 397,
			KERNEL_PARTITION_REFERENCE_VIOLATION = 398,
			SYNTHETIC_EXCEPTION_UNHANDLED = 399,
			WIN32K_CRITICAL_FAILURE_LIVEDUMP = 400,
			PF_DETECTED_CORRUPTION = 401,
			KERNEL_AUTO_BOOST_LOCK_ACQUISITION_WITH_RAISED_IRQL = 402,
			VIDEO_DXGKRNL_LIVEDUMP = 403,
			KERNEL_STORAGE_SLOT_IN_USE = 409,
			SMB_SERVER_LIVEDUMP = 405,
			LOADER_ROLLBACK_DETECTED = 406,
			WIN32K_SECURITY_FAILURE = 407,
			UFX_LIVEDUMP = 408,
			WORKER_THREAD_RETURNED_WHILE_ATTACHED_TO_SILO = 410,
			TTM_FATAL_ERROR = 411,
			WIN32K_POWER_WATCHDOG_TIMEOUT = 412,
			CLUSTER_SVHDX_LIVEDUMP = 413,
			BUGCODE_NETADAPTER_DRIVER = 414,
			PDC_PRIVILEGE_CHECK_LIVEDUMP = 415,
			TTM_WATCHDOG_TIMEOUT = 416,
			WIN32K_CALLOUT_WATCHDOG_LIVEDUMP = 417,
			WIN32K_CALLOUT_WATCHDOG_BUGCHECK = 418,
			CALL_HAS_NOT_RETURNED_WATCHDOG_TIMEOUT_LIVEDUMP = 419,
			DRIPS_SW_HW_DIVERGENCE_LIVEDUMP = 420,
			USB_DRIPS_BLOCKER_SURPRISE_REMOVAL_LIVEDUMP = 421,
			BLUETOOTH_ERROR_RECOVERY_LIVEDUMP = 422,
			SMB_REDIRECTOR_LIVEDUMP = 423,
			VIDEO_DXGKRNL_BLACK_SCREEN_LIVEDUMP = 424,
			DIRECTED_FX_TRANSITION_LIVEDUMP = 425,
			EXCEPTION_ON_INVALID_STACK = 426,
			UNWIND_ON_INVALID_STACK = 427,
			VIDEO_MINIPORT_FAILED_LIVEDUMP = 432,
			VIDEO_MINIPORT_BLACK_SCREEN_LIVEDUMP = 440,
			DRIVER_VERIFIER_DETECTED_VIOLATION_LIVEDUMP = 452,
			IO_THREADPOOL_DEADLOCK_LIVEDUMP = 453,
			FAST_ERESOURCE_PRECONDITION_VIOLATION = 454,
			STORE_DATA_STRUCTURE_CORRUPTION = 455,
			MANUALLY_INITIATED_POWER_BUTTON_HOLD = 456,
			USER_MODE_HEALTH_MONITOR_LIVEDUMP = 457,
			SYNTHETIC_WATCHDOG_TIMEOUT = 458,
			INVALID_SILO_DETACH = 459,
			EXRESOURCE_TIMEOUT_LIVEDUMP = 460,
			INVALID_CALLBACK_STACK_ADDRESS = 461,
			INVALID_KERNEL_STACK_ADDRESS = 462,
			HARDWARE_WATCHDOG_TIMEOUT = 463,
			ACPI_FIRMWARE_WATCHDOG_TIMEOUT = 464,
			TELEMETRY_ASSERTS_LIVEDUMP = 465,
			WORKER_THREAD_INVALID_STATE = 466,
			WFP_INVALID_OPERATION = 467,
			UCMUCSI_LIVEDUMP = 468,
			DRIVER_PNP_WATCHDOG = 469,
			WORKER_THREAD_RETURNED_WITH_NON_DEFAULT_WORKLOAD_CLASS = 470,
			EFS_FATAL_ERROR = 471,
			UCMUCSI_FAILURE = 472,
			HAL_IOMMU_INTERNAL_ERROR = 473,
			HAL_BLOCKED_PROCESSOR_INTERNAL_ERROR = 474,
			IPI_WATCHDOG_TIMEOUT = 475,
			DMA_COMMON_BUFFER_VECTOR_ERROR = 476,
			BUGCODE_MBBADAPTER_DRIVER = 477,
			BUGCODE_WIFIADAPTER_DRIVER = 478,
			PROCESSOR_START_TIMEOUT = 479,
			INVALID_ALTERNATE_SYSTEM_CALL_HANDLER_REGISTRATION = 480,
			DEVICE_DIAGNOSTIC_LOG_LIVEDUMP = 481,
			AZURE_DEVICE_FW_DUMP = 482,
			BREAKAWAY_CABLE_TRANSITION = 483,
			VIDEO_DXGKRNL_SYSMM_FATAL_ERROR = 484,
			DRIVER_VERIFIER_TRACKING_LIVE_DUMP = 485,
			CRASHDUMP_WATCHDOG_TIMEOUT = 486,
			REGISTRY_LIVE_DUMP = 487,
			INVALID_THREAD_AFFINITY_STATE = 488,
			ILLEGAL_ATS_INITIALIZATION = 489,
			SECURE_PCI_CONFIG_SPACE_ACCESS_VIOLATION = 490,
			DAM_WATCHDOG_TIMEOUT = 491,
			XBOX_VMCTRL_CS_TIMEOUT = 854,
			XBOX_CORRUPTED_IMAGE = 855,
			XBOX_INVERTED_FUNCTION_TABLE_OVERFLOW = 856,
			XBOX_CORRUPTED_IMAGE_BASE = 857,
			XBOX_XDS_WATCHDOG_TIMEOUT = 858,
			XBOX_SHUTDOWN_WATCHDOG_TIMEOUT = 859,
			XBOX_360_SYSTEM_CRASH = 864,
			XBOX_360_SYSTEM_CRASH_RESERVED = 1056,
			XBOX_SECURITY_FAILUE = 1057,
			KERNEL_CFG_INIT_FAILURE = 1058,
			MANUALLY_INITIATED_POWER_BUTTON_HOLD_LIVE_DUMP = 4552,
			HYPERVISOR_ERROR = 131073,
			WINLOGON_FATAL_ERROR = 3221226010,
			MANUALLY_INITIATED_CRASH1 = 3735936685,
			BUGCHECK_CONTEXT_MODIFIER = 2147483648,
		}
		[AllowDuplicates]
		public enum FACILITY_CODE : uint32
		{
			NULL = 0,
			RPC = 1,
			DISPATCH = 2,
			STORAGE = 3,
			ITF = 4,
			WIN32 = 7,
			WINDOWS = 8,
			SSPI = 9,
			SECURITY = 9,
			CONTROL = 10,
			CERT = 11,
			INTERNET = 12,
			MEDIASERVER = 13,
			MSMQ = 14,
			SETUPAPI = 15,
			SCARD = 16,
			COMPLUS = 17,
			AAF = 18,
			URT = 19,
			ACS = 20,
			DPLAY = 21,
			UMI = 22,
			SXS = 23,
			WINDOWS_CE = 24,
			HTTP = 25,
			USERMODE_COMMONLOG = 26,
			WER = 27,
			USERMODE_FILTER_MANAGER = 31,
			BACKGROUNDCOPY = 32,
			CONFIGURATION = 33,
			WIA = 33,
			STATE_MANAGEMENT = 34,
			METADIRECTORY = 35,
			WINDOWSUPDATE = 36,
			DIRECTORYSERVICE = 37,
			GRAPHICS = 38,
			SHELL = 39,
			NAP = 39,
			TPM_SERVICES = 40,
			TPM_SOFTWARE = 41,
			UI = 42,
			XAML = 43,
			ACTION_QUEUE = 44,
			PLA = 48,
			WINDOWS_SETUP = 48,
			FVE = 49,
			FWP = 50,
			WINRM = 51,
			NDIS = 52,
			USERMODE_HYPERVISOR = 53,
			CMI = 54,
			USERMODE_VIRTUALIZATION = 55,
			USERMODE_VOLMGR = 56,
			BCD = 57,
			USERMODE_VHD = 58,
			USERMODE_HNS = 59,
			SDIAG = 60,
			WEBSERVICES = 61,
			WINPE = 61,
			WPN = 62,
			WINDOWS_STORE = 63,
			INPUT = 64,
			QUIC = 65,
			EAP = 66,
			IORING = 70,
			WINDOWS_DEFENDER = 80,
			OPC = 81,
			XPS = 82,
			MBN = 84,
			POWERSHELL = 84,
			RAS = 83,
			P2P_INT = 98,
			P2P = 99,
			DAF = 100,
			BLUETOOTH_ATT = 101,
			AUDIO = 102,
			STATEREPOSITORY = 103,
			VISUALCPP = 109,
			SCRIPT = 112,
			PARSE = 113,
			BLB = 120,
			BLB_CLI = 121,
			WSBAPP = 122,
			BLBUI = 128,
			USN = 129,
			USERMODE_VOLSNAP = 130,
			TIERING = 131,
			WSB_ONLINE = 133,
			ONLINE_ID = 134,
			DEVICE_UPDATE_AGENT = 135,
			DRVSERVICING = 136,
			DLS = 153,
			DELIVERY_OPTIMIZATION = 208,
			USERMODE_SPACES = 231,
			USER_MODE_SECURITY_CORE = 232,
			USERMODE_LICENSING = 234,
			SOS = 160,
			OCP_UPDATE_AGENT = 173,
			DEBUGGERS = 176,
			SPP = 256,
			RESTORE = 256,
			DMSERVER = 256,
			DEPLOYMENT_SERVICES_SERVER = 257,
			DEPLOYMENT_SERVICES_IMAGING = 258,
			DEPLOYMENT_SERVICES_MANAGEMENT = 259,
			DEPLOYMENT_SERVICES_UTIL = 260,
			DEPLOYMENT_SERVICES_BINLSVC = 261,
			DEPLOYMENT_SERVICES_PXE = 263,
			DEPLOYMENT_SERVICES_TFTP = 264,
			DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = 272,
			DEPLOYMENT_SERVICES_DRIVER_PROVISIONING = 278,
			DEPLOYMENT_SERVICES_MULTICAST_SERVER = 289,
			DEPLOYMENT_SERVICES_MULTICAST_CLIENT = 290,
			DEPLOYMENT_SERVICES_CONTENT_PROVIDER = 293,
			HSP_SERVICES = 296,
			HSP_SOFTWARE = 297,
			LINGUISTIC_SERVICES = 305,
			AUDIOSTREAMING = 1094,
			TTD = 1490,
			ACCELERATOR = 1536,
			WMAAECMA = 1996,
			DIRECTMUSIC = 2168,
			DIRECT3D10 = 2169,
			DXGI = 2170,
			DXGI_DDI = 2171,
			DIRECT3D11 = 2172,
			DIRECT3D11_DEBUG = 2173,
			DIRECT3D12 = 2174,
			DIRECT3D12_DEBUG = 2175,
			DXCORE = 2176,
			PRESENTATION = 2177,
			LEAP = 2184,
			AUDCLNT = 2185,
			WINCODEC_DWRITE_DWM = 2200,
			WINML = 2192,
			DIRECT2D = 2201,
			DEFRAG = 2304,
			USERMODE_SDBUS = 2305,
			JSCRIPT = 2306,
			PIDGENX = 2561,
			EAS = 85,
			WEB = 885,
			WEB_SOCKET = 886,
			MOBILE = 1793,
			SQLITE = 1967,
			SERVICE_FABRIC = 1968,
			UTC = 1989,
			WEP = 2049,
			SYNCENGINE = 2050,
			XBOX = 2339,
			GAME = 2340,
			PIX = 2748,
			NT_BIT = 268435456,
		}
		public enum THREAD_ERROR_MODE : uint32
		{
			ALL_ERRORS = 0,
			FAILCRITICALERRORS = 1,
			NOGPFAULTERRORBOX = 2,
			NOOPENFILEERRORBOX = 32768,
			NOALIGNMENTFAULTEXCEPT = 4,
		}
		public enum FORMAT_MESSAGE_OPTIONS : uint32
		{
			ALLOCATE_BUFFER = 256,
			ARGUMENT_ARRAY = 8192,
			FROM_HMODULE = 2048,
			FROM_STRING = 1024,
			FROM_SYSTEM = 4096,
			IGNORE_INSERTS = 512,
		}
		public enum RTL_VIRTUAL_UNWIND_HANDLER_TYPE : uint32
		{
			NHANDLER = 0,
			EHANDLER = 1,
			UHANDLER = 2,
			CHAININFO = 4,
		}
		public enum OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS : uint32
		{
			WCT_ASYNC_OPEN_FLAG = 1,
		}
		public enum SYM_SRV_STORE_FILE_FLAGS : uint32
		{
			COMPRESS = 1,
			OVERWRITE = 2,
			PASS_IF_EXISTS = 64,
			POINTER = 8,
			RETURNINDEX = 4,
		}
		public enum PROCESSOR_ARCHITECTURE : uint16
		{
			AMD64 = 9,
			IA64 = 6,
			INTEL = 0,
			ARM = 5,
			UNKNOWN = 65535,
		}
		public enum IMAGE_DIRECTORY_ENTRY : uint32
		{
			ARCHITECTURE = 7,
			BASERELOC = 5,
			BOUND_IMPORT = 11,
			COM_DESCRIPTOR = 14,
			DEBUG = 6,
			DELAY_IMPORT = 13,
			EXCEPTION = 3,
			EXPORT = 0,
			GLOBALPTR = 8,
			IAT = 12,
			IMPORT = 1,
			LOAD_CONFIG = 10,
			RESOURCE = 2,
			SECURITY = 4,
			TLS = 9,
		}
		public enum WAIT_CHAIN_THREAD_OPTIONS : uint32
		{
			COM_FLAG = 2,
			CS_FLAG = 4,
			FLAG = 1,
		}
		public enum SYM_FIND_ID_OPTION : uint32
		{
			DWORD = 2,
			DWORDPTR = 4,
			GUIDPTR = 8,
		}
		public enum IMAGE_FILE_CHARACTERISTICS : uint16
		{
			RELOCS_STRIPPED = 1,
			EXECUTABLE_IMAGE = 2,
			LINE_NUMS_STRIPPED = 4,
			LOCAL_SYMS_STRIPPED = 8,
			AGGRESIVE_WS_TRIM = 16,
			LARGE_ADDRESS_AWARE = 32,
			BYTES_REVERSED_LO = 128,
			_32BIT_MACHINE = 256,
			DEBUG_STRIPPED = 512,
			REMOVABLE_RUN_FROM_SWAP = 1024,
			NET_RUN_FROM_SWAP = 2048,
			SYSTEM = 4096,
			DLL = 8192,
			UP_SYSTEM_ONLY = 16384,
			BYTES_REVERSED_HI = 32768,
		}
		public enum IMAGE_FILE_CHARACTERISTICS2 : uint32
		{
			RELOCS_STRIPPED2 = 1,
			EXECUTABLE_IMAGE2 = 2,
			LINE_NUMS_STRIPPED2 = 4,
			LOCAL_SYMS_STRIPPED2 = 8,
			AGGRESIVE_WS_TRIM2 = 16,
			LARGE_ADDRESS_AWARE2 = 32,
			BYTES_REVERSED_LO2 = 128,
			_32BIT_MACHINE2 = 256,
			DEBUG_STRIPPED2 = 512,
			REMOVABLE_RUN_FROM_SWAP2 = 1024,
			NET_RUN_FROM_SWAP2 = 2048,
			SYSTEM_2 = 4096,
			DLL_2 = 8192,
			UP_SYSTEM_ONLY_2 = 16384,
			BYTES_REVERSED_HI_2 = 32768,
		}
		public enum SYMBOL_INFO_FLAGS : uint32
		{
			CLR_TOKEN = 262144,
			CONSTANT = 256,
			EXPORT = 512,
			FORWARDER = 1024,
			FRAMEREL = 32,
			FUNCTION = 2048,
			ILREL = 65536,
			LOCAL = 128,
			METADATA = 131072,
			PARAMETER = 64,
			REGISTER = 8,
			REGREL = 16,
			SLOT = 32768,
			THUNK = 8192,
			TLSREL = 16384,
			VALUEPRESENT = 1,
			VIRTUAL = 4096,
		}
		public enum IMAGEHLP_CBA_EVENT_SEVERITY : uint32
		{
			Info = 0,
			Problem = 1,
			Attn = 2,
			Fatal = 3,
		}
		public enum IMAGEHLP_GET_TYPE_INFO_FLAGS : uint32
		{
			CHILDREN = 2,
			UNCACHED = 1,
		}
		public enum RIP_INFO_TYPE : uint32
		{
			ERROR = 1,
			MINORERROR = 2,
			WARNING = 3,
		}
		public enum VER_PLATFORM : uint32
		{
			WIN32s = 0,
			WIN32_WINDOWS = 1,
			WIN32_NT = 2,
		}
		public enum IMAGE_DEBUG_TYPE : uint32
		{
			UNKNOWN = 0,
			COFF = 1,
			CODEVIEW = 2,
			FPO = 3,
			MISC = 4,
			EXCEPTION = 5,
			FIXUP = 6,
			BORLAND = 9,
		}
		public enum MINIDUMP_THREAD_INFO_DUMP_FLAGS : uint32
		{
			ERROR_THREAD = 1,
			EXITED_THREAD = 4,
			INVALID_CONTEXT = 16,
			INVALID_INFO = 8,
			INVALID_TEB = 32,
			WRITING_THREAD = 2,
		}
		public enum DEBUG_EVENT_CODE : uint32
		{
			CREATE_PROCESS_DEBUG_EVENT = 3,
			CREATE_THREAD_DEBUG_EVENT = 2,
			EXCEPTION_DEBUG_EVENT = 1,
			EXIT_PROCESS_DEBUG_EVENT = 5,
			EXIT_THREAD_DEBUG_EVENT = 4,
			LOAD_DLL_DEBUG_EVENT = 6,
			OUTPUT_DEBUG_STRING_EVENT = 8,
			RIP_EVENT = 9,
			UNLOAD_DLL_DEBUG_EVENT = 7,
		}
		public enum MINIDUMP_MISC_INFO_FLAGS : uint32
		{
			ID = 1,
			TIMES = 2,
		}
		public enum MODLOAD_DATA_TYPE : uint32
		{
			DEBUGDIRS = 1,
			CVMISC = 2,
		}
		public enum ModelObjectKind : int32
		{
			PropertyAccessor = 0,
			Context = 1,
			TargetObject = 2,
			TargetObjectReference = 3,
			Synthetic = 4,
			NoValue = 5,
			Error = 6,
			Intrinsic = 7,
			Method = 8,
			KeyReference = 9,
		}
		public enum SymbolKind : int32
		{
			Symbol = 0,
			SymbolModule = 1,
			SymbolType = 2,
			SymbolField = 3,
			SymbolConstant = 4,
			SymbolData = 5,
			SymbolBaseClass = 6,
			SymbolPublic = 7,
			SymbolFunction = 8,
		}
		public enum TypeKind : int32
		{
			UDT = 0,
			Pointer = 1,
			MemberPointer = 2,
			Array = 3,
			Function = 4,
			Typedef = 5,
			Enum = 6,
			Intrinsic = 7,
			ExtendedArray = 8,
		}
		public enum IntrinsicKind : int32
		{
			Void = 0,
			Bool = 1,
			Char = 2,
			WChar = 3,
			Int = 4,
			UInt = 5,
			Long = 6,
			ULong = 7,
			Float = 8,
			HResult = 9,
			Char16 = 10,
			Char32 = 11,
		}
		public enum PointerKind : int32
		{
			Standard = 0,
			Reference = 1,
			RValueReference = 2,
			CXHat = 3,
			ManagedReference = 4,
		}
		public enum CallingConventionKind : int32
		{
			Unknown = 0,
			CDecl = 1,
			FastCall = 2,
			StdCall = 3,
			SysCall = 4,
			ThisCall = 5,
		}
		public enum LocationKind : int32
		{
			Member = 0,
			Static = 1,
			Constant = 2,
			None = 3,
		}
		public enum PreferredFormat : int32
		{
			None = 0,
			SingleCharacter = 1,
			QuotedString = 2,
			String = 3,
			QuotedUnicodeString = 4,
			UnicodeString = 5,
			QuotedUTF8String = 6,
			UTF8String = 7,
			BSTRString = 8,
			QuotedHString = 9,
			HString = 10,
			Raw = 11,
			EnumNameOnly = 12,
			EscapedStringWithQuote = 13,
			UTF32String = 14,
			QuotedUTF32String = 15,
		}
		public enum RawSearchFlags : int32
		{
			None = 0,
			NoBases = 1,
		}
		public enum ErrorClass : int32
		{
			Warning = 0,
			Error = 1,
		}
		public enum SignatureComparison : int32
		{
			Unrelated = 0,
			Ambiguous = 1,
			LessSpecific = 2,
			MoreSpecific = 3,
			Identical = 4,
		}
		public enum SymbolSearchOptions : int32
		{
			None = 0,
			Completion = 1,
			CaseInsensitive = 2,
		}
		public enum LanguageKind : int32
		{
			Unknown = 0,
			C = 1,
			CPP = 2,
			Assembly = 3,
		}
		public enum VarArgsKind : int32
		{
			None = 0,
			CStyle = 1,
		}
		public enum ScriptChangeKind : int32
		{
			Rename = 0,
		}
		public enum ScriptDebugState : int32
		{
			NoDebugger = 0,
			NotExecuting = 1,
			Executing = 2,
			Break = 3,
		}
		public enum ScriptDebugEventFilter : int32
		{
			Entry = 0,
			Exception = 1,
			UnhandledException = 2,
			Abort = 3,
		}
		public enum ScriptDebugEvent : int32
		{
			Breakpoint = 0,
			Step = 1,
			Exception = 2,
			AsyncBreak = 3,
		}
		public enum ScriptExecutionKind : int32
		{
			Normal = 0,
			StepIn = 1,
			StepOut = 2,
			StepOver = 3,
		}
		public enum EXT_TDOP : int32
		{
			COPY = 0,
			RELEASE = 1,
			SET_FROM_EXPR = 2,
			SET_FROM_U64_EXPR = 3,
			GET_FIELD = 4,
			EVALUATE = 5,
			GET_TYPE_NAME = 6,
			OUTPUT_TYPE_NAME = 7,
			OUTPUT_SIMPLE_VALUE = 8,
			OUTPUT_FULL_VALUE = 9,
			HAS_FIELD = 10,
			GET_FIELD_OFFSET = 11,
			GET_ARRAY_ELEMENT = 12,
			GET_DEREFERENCE = 13,
			GET_TYPE_SIZE = 14,
			OUTPUT_TYPE_DEFINITION = 15,
			GET_POINTER_TO = 16,
			SET_FROM_TYPE_ID_AND_U64 = 17,
			SET_PTR_FROM_TYPE_ID_AND_U64 = 18,
			COUNT = 19,
		}
		public enum DBGKD_MAJOR_TYPES : int32
		{
			NT = 0,
			XBOX = 1,
			BIG = 2,
			EXDI = 3,
			NTBD = 4,
			EFI = 5,
			TNT = 6,
			SINGULARITY = 7,
			HYPERVISOR = 8,
			MIDORI = 9,
			CE = 10,
			COUNT = 11,
		}
		public enum WCT_OBJECT_TYPE : int32
		{
			CriticalSectionType = 1,
			SendMessageType = 2,
			MutexType = 3,
			AlpcType = 4,
			ComType = 5,
			ThreadWaitType = 6,
			ProcessWaitType = 7,
			ThreadType = 8,
			ComActivationType = 9,
			UnknownType = 10,
			SocketIoType = 11,
			SmbIoType = 12,
			MaxType = 13,
		}
		public enum WCT_OBJECT_STATUS : int32
		{
			NoAccess = 1,
			Running = 2,
			Blocked = 3,
			PidOnly = 4,
			PidOnlyRpcss = 5,
			Owned = 6,
			NotOwned = 7,
			Abandoned = 8,
			Unknown = 9,
			Error = 10,
			Max = 11,
		}
		public enum MINIDUMP_STREAM_TYPE : int32
		{
			UnusedStream = 0,
			ReservedStream0 = 1,
			ReservedStream1 = 2,
			ThreadListStream = 3,
			ModuleListStream = 4,
			MemoryListStream = 5,
			ExceptionStream = 6,
			SystemInfoStream = 7,
			ThreadExListStream = 8,
			Memory64ListStream = 9,
			CommentStreamA = 10,
			CommentStreamW = 11,
			HandleDataStream = 12,
			FunctionTableStream = 13,
			UnloadedModuleListStream = 14,
			MiscInfoStream = 15,
			MemoryInfoListStream = 16,
			ThreadInfoListStream = 17,
			HandleOperationListStream = 18,
			TokenStream = 19,
			JavaScriptDataStream = 20,
			SystemMemoryInfoStream = 21,
			ProcessVmCountersStream = 22,
			IptTraceStream = 23,
			ThreadNamesStream = 24,
			ceStreamNull = 32768,
			ceStreamSystemInfo = 32769,
			ceStreamException = 32770,
			ceStreamModuleList = 32771,
			ceStreamProcessList = 32772,
			ceStreamThreadList = 32773,
			ceStreamThreadContextList = 32774,
			ceStreamThreadCallStackList = 32775,
			ceStreamMemoryVirtualList = 32776,
			ceStreamMemoryPhysicalList = 32777,
			ceStreamBucketParameters = 32778,
			ceStreamProcessModuleMap = 32779,
			ceStreamDiagnosisList = 32780,
			LastReservedStream = 65535,
		}
		public enum MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE : int32
		{
			HandleObjectInformationNone = 0,
			ThreadInformation1 = 1,
			MutantInformation1 = 2,
			MutantInformation2 = 3,
			ProcessInformation1 = 4,
			ProcessInformation2 = 5,
			EventInformation1 = 6,
			SectionInformation1 = 7,
			SemaphoreInformation1 = 8,
			HandleObjectInformationTypeMax = 9,
		}
		public enum MINIDUMP_CALLBACK_TYPE : int32
		{
			ModuleCallback = 0,
			ThreadCallback = 1,
			ThreadExCallback = 2,
			IncludeThreadCallback = 3,
			IncludeModuleCallback = 4,
			MemoryCallback = 5,
			CancelCallback = 6,
			WriteKernelMinidumpCallback = 7,
			KernelMinidumpStatusCallback = 8,
			RemoveMemoryCallback = 9,
			IncludeVmRegionCallback = 10,
			IoStartCallback = 11,
			IoWriteAllCallback = 12,
			IoFinishCallback = 13,
			ReadMemoryFailureCallback = 14,
			SecondaryFlagsCallback = 15,
			IsProcessSnapshotCallback = 16,
			VmStartCallback = 17,
			VmQueryCallback = 18,
			VmPreReadCallback = 19,
			VmPostReadCallback = 20,
		}
		public enum THREAD_WRITE_FLAGS : int32
		{
			Thread = 1,
			Stack = 2,
			Context = 4,
			BackingStore = 8,
			InstructionWindow = 16,
			ThreadData = 32,
			ThreadInfo = 64,
		}
		public enum MODULE_WRITE_FLAGS : int32
		{
			WriteModule = 1,
			WriteDataSeg = 2,
			WriteMiscRecord = 4,
			WriteCvRecord = 8,
			ReferencedByMemory = 16,
			WriteTlsData = 32,
			WriteCodeSegs = 64,
		}
		public enum MINIDUMP_TYPE : uint32
		{
			Normal = 0,
			WithDataSegs = 1,
			WithFullMemory = 2,
			WithHandleData = 4,
			FilterMemory = 8,
			ScanMemory = 16,
			WithUnloadedModules = 32,
			WithIndirectlyReferencedMemory = 64,
			FilterModulePaths = 128,
			WithProcessThreadData = 256,
			WithPrivateReadWriteMemory = 512,
			WithoutOptionalData = 1024,
			WithFullMemoryInfo = 2048,
			WithThreadInfo = 4096,
			WithCodeSegs = 8192,
			WithoutAuxiliaryState = 16384,
			WithFullAuxiliaryState = 32768,
			WithPrivateWriteCopyMemory = 65536,
			IgnoreInaccessibleMemory = 131072,
			WithTokenInformation = 262144,
			WithModuleHeaders = 524288,
			FilterTriage = 1048576,
			WithAvxXStateContext = 2097152,
			WithIptTrace = 4194304,
			ScanInaccessiblePartialPages = 8388608,
			FilterWriteCombinedMemory = 16777216,
			ValidTypeFlags = 33554431,
		}
		[AllowDuplicates]
		public enum MINIDUMP_SECONDARY_FLAGS : int32
		{
			WithoutPowerInfo = 1,
			ValidFlags = 1,
		}
		public enum SCRIPTLANGUAGEVERSION : int32
		{
			DEFAULT = 0,
			_5_7 = 1,
			_5_8 = 2,
			MAX = 255,
		}
		public enum SCRIPTSTATE : int32
		{
			UNINITIALIZED = 0,
			INITIALIZED = 5,
			STARTED = 1,
			CONNECTED = 2,
			DISCONNECTED = 3,
			CLOSED = 4,
		}
		public enum SCRIPTTRACEINFO : int32
		{
			SCRIPTSTART = 0,
			SCRIPTEND = 1,
			COMCALLSTART = 2,
			COMCALLEND = 3,
			CREATEOBJSTART = 4,
			CREATEOBJEND = 5,
			GETOBJSTART = 6,
			GETOBJEND = 7,
		}
		public enum SCRIPTTHREADSTATE : int32
		{
			NOTINSCRIPT = 0,
			RUNNING = 1,
		}
		public enum SCRIPTGCTYPE : int32
		{
			NORMAL = 0,
			EXHAUSTIVE = 1,
		}
		public enum SCRIPTUICITEM : int32
		{
			INPUTBOX = 1,
			MSGBOX = 2,
		}
		public enum SCRIPTUICHANDLING : int32
		{
			ALLOW = 0,
			NOUIERROR = 1,
			NOUIDEFAULT = 2,
		}
		public enum DBGPROP_ATTRIB_FLAGS : uint32
		{
			NO_ATTRIB = 0,
			VALUE_IS_INVALID = 8,
			VALUE_IS_EXPANDABLE = 16,
			VALUE_IS_FAKE = 32,
			VALUE_IS_METHOD = 256,
			VALUE_IS_EVENT = 512,
			VALUE_IS_RAW_STRING = 1024,
			VALUE_READONLY = 2048,
			ACCESS_PUBLIC = 4096,
			ACCESS_PRIVATE = 8192,
			ACCESS_PROTECTED = 16384,
			ACCESS_FINAL = 32768,
			STORAGE_GLOBAL = 65536,
			STORAGE_STATIC = 131072,
			STORAGE_FIELD = 262144,
			STORAGE_VIRTUAL = 524288,
			TYPE_IS_CONSTANT = 1048576,
			TYPE_IS_SYNCHRONIZED = 2097152,
			TYPE_IS_VOLATILE = 4194304,
			HAS_EXTENDED_ATTRIBS = 8388608,
			FRAME_INTRYBLOCK = 16777216,
			FRAME_INCATCHBLOCK = 33554432,
			FRAME_INFINALLYBLOCK = 67108864,
			VALUE_IS_RETURN_VALUE = 134217728,
			VALUE_PENDING_MUTATION = 268435456,
		}
		public enum DBGPROP_INFO : uint32
		{
			NAME = 1,
			TYPE = 2,
			VALUE = 4,
			FULLNAME = 32,
			ATTRIBUTES = 8,
			DEBUGPROP = 16,
			BEAUTIFY = 33554432,
			CALLTOSTRING = 67108864,
			AUTOEXPAND = 134217728,
		}
		[AllowDuplicates]
		public enum OBJECT_ATTRIB_FLAG : uint32
		{
			NO_ATTRIB = 0,
			NO_NAME = 1,
			NO_TYPE = 2,
			NO_VALUE = 4,
			VALUE_IS_INVALID = 8,
			VALUE_IS_OBJECT = 16,
			VALUE_IS_ENUM = 32,
			VALUE_IS_CUSTOM = 64,
			OBJECT_IS_EXPANDABLE = 112,
			VALUE_HAS_CODE = 128,
			TYPE_IS_OBJECT = 256,
			TYPE_HAS_CODE = 512,
			TYPE_IS_EXPANDABLE = 256,
			SLOT_IS_CATEGORY = 1024,
			VALUE_READONLY = 2048,
			ACCESS_PUBLIC = 4096,
			ACCESS_PRIVATE = 8192,
			ACCESS_PROTECTED = 16384,
			ACCESS_FINAL = 32768,
			STORAGE_GLOBAL = 65536,
			STORAGE_STATIC = 131072,
			STORAGE_FIELD = 262144,
			STORAGE_VIRTUAL = 524288,
			TYPE_IS_CONSTANT = 1048576,
			TYPE_IS_SYNCHRONIZED = 2097152,
			TYPE_IS_VOLATILE = 4194304,
			HAS_EXTENDED_ATTRIBS = 8388608,
			IS_CLASS = 16777216,
			IS_FUNCTION = 33554432,
			IS_VARIABLE = 67108864,
			IS_PROPERTY = 134217728,
			IS_MACRO = 268435456,
			IS_TYPE = 536870912,
			IS_INHERITED = 1073741824,
			IS_INTERFACE = 2147483648,
		}
		public enum PROP_INFO_FLAGS : int32
		{
			NAME = 1,
			TYPE = 2,
			VALUE = 4,
			FULLNAME = 32,
			ATTRIBUTES = 8,
			DEBUGPROP = 16,
			AUTOEXPAND = 134217728,
		}
		public enum EX_PROP_INFO_FLAGS : int32
		{
			ID = 256,
			NTYPE = 512,
			NVALUE = 1024,
			LOCKBYTES = 2048,
			DEBUGEXTPROP = 4096,
		}
		public enum BREAKPOINT_STATE : int32
		{
			DELETED = 0,
			DISABLED = 1,
			ENABLED = 2,
		}
		public enum BREAKREASON : int32
		{
			STEP = 0,
			BREAKPOINT = 1,
			DEBUGGER_BLOCK = 2,
			HOST_INITIATED = 3,
			LANGUAGE_INITIATED = 4,
			DEBUGGER_HALT = 5,
			ERROR = 6,
			JIT = 7,
			MUTATION_BREAKPOINT = 8,
		}
		public enum BREAKRESUME_ACTION : int32
		{
			ABORT = 0,
			CONTINUE = 1,
			STEP_INTO = 2,
			STEP_OVER = 3,
			STEP_OUT = 4,
			IGNORE = 5,
			STEP_DOCUMENT = 6,
		}
		public enum ERRORRESUMEACTION : int32
		{
			ReexecuteErrorStatement = 0,
			AbortCallAndReturnErrorToCaller = 1,
			SkipErrorStatement = 2,
		}
		public enum DOCUMENTNAMETYPE : int32
		{
			APPNODE = 0,
			TITLE = 1,
			FILE_TAIL = 2,
			URL = 3,
			UNIQUE_TITLE = 4,
			SOURCE_MAP_URL = 5,
		}
		public enum PROFILER_SCRIPT_TYPE : int32
		{
			USER = 0,
			DYNAMIC = 1,
			NATIVE = 2,
			DOM = 3,
		}
		public enum PROFILER_EVENT_MASK : uint32
		{
			SCRIPT_FUNCTION_CALL = 1,
			NATIVE_FUNCTION_CALL = 2,
			DOM_FUNCTION_CALL = 4,
			ALL = 3,
			ALL_WITH_DOM = 7,
		}
		public enum PROFILER_HEAP_OBJECT_FLAGS : uint32
		{
			NEW_OBJECT = 1,
			IS_ROOT = 2,
			SITE_CLOSED = 4,
			EXTERNAL = 8,
			EXTERNAL_UNKNOWN = 16,
			EXTERNAL_DISPATCH = 32,
			SIZE_APPROXIMATE = 64,
			SIZE_UNAVAILABLE = 128,
			NEW_STATE_UNAVAILABLE = 256,
			WINRT_INSTANCE = 512,
			WINRT_RUNTIMECLASS = 1024,
			WINRT_DELEGATE = 2048,
			WINRT_NAMESPACE = 4096,
		}
		[AllowDuplicates]
		public enum PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE : int32
		{
			PROTOTYPE = 1,
			FUNCTION_NAME = 2,
			SCOPE_LIST = 3,
			INTERNAL_PROPERTY = 4,
			NAME_PROPERTIES = 5,
			INDEX_PROPERTIES = 6,
			ELEMENT_ATTRIBUTES_SIZE = 7,
			ELEMENT_TEXT_CHILDREN_SIZE = 8,
			RELATIONSHIPS = 9,
			WINRTEVENTS = 10,
			WEAKMAP_COLLECTION_LIST = 11,
			MAP_COLLECTION_LIST = 12,
			SET_COLLECTION_LIST = 13,
			MAX_VALUE = 13,
		}
		public enum PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS : uint32
		{
			NONE = 0,
			IS_GET_ACCESSOR = 65536,
			IS_SET_ACCESSOR = 131072,
			LET_VARIABLE = 262144,
			CONST_VARIABLE = 524288,
		}
		public enum PROFILER_HEAP_ENUM_FLAGS : uint32
		{
			NONE = 0,
			STORE_RELATIONSHIP_FLAGS = 1,
			SUBSTRINGS = 2,
			RELATIONSHIP_SUBSTRINGS = 3,
		}
		public enum PROFILER_RELATIONSHIP_INFO : int32
		{
			NUMBER = 1,
			STRING = 2,
			HEAP_OBJECT = 3,
			EXTERNAL_OBJECT = 4,
			BSTR = 5,
			SUBSTRING = 6,
		}
		public enum PROFILER_HEAP_SUMMARY_VERSION : int32
		{
			VERSION_1 = 1,
		}
		public enum IMAGEHLP_STATUS_REASON : int32
		{
			OutOfMemory = 0,
			RvaToVaFailed = 1,
			NoRoomInImage = 2,
			ImportModuleFailed = 3,
			ImportProcedureFailed = 4,
			ImportModule = 5,
			ImportProcedure = 6,
			Forwarder = 7,
			ForwarderNOT = 8,
			ImageModified = 9,
			ExpandFileHeaders = 10,
			ImageComplete = 11,
			MismatchedSymbols = 12,
			SymbolsNotUpdated = 13,
			ImportProcedure32 = 14,
			ImportProcedure64 = 15,
			Forwarder32 = 16,
			Forwarder64 = 17,
			ForwarderNOT32 = 18,
			ForwarderNOT64 = 19,
		}
		public enum ADDRESS_MODE : int32
		{
			Mode1616 = 0,
			Mode1632 = 1,
			ModeReal = 2,
			ModeFlat = 3,
		}
		public enum SYM_TYPE : int32
		{
			SymNone = 0,
			SymCoff = 1,
			SymCv = 2,
			SymPdb = 3,
			SymExport = 4,
			SymDeferred = 5,
			SymSym = 6,
			SymDia = 7,
			SymVirtual = 8,
			NumSymTypes = 9,
		}
		public enum IMAGEHLP_HD_TYPE : int32
		{
			Base = 0,
			Sym = 1,
			Src = 2,
			Max = 3,
		}
		public enum IMAGEHLP_EXTENDED_OPTIONS : int32
		{
			DISABLEACCESSTIMEUPDATE = 0,
			LASTVALIDDEBUGDIRECTORY = 1,
			NOIMPLICITPATTERNSEARCH = 2,
			NEVERLOADSYMBOLS = 3,
			MAX = 4,
		}
		public enum IMAGEHLP_SYMBOL_TYPE_INFO : int32
		{
			TI_GET_SYMTAG = 0,
			TI_GET_SYMNAME = 1,
			TI_GET_LENGTH = 2,
			TI_GET_TYPE = 3,
			TI_GET_TYPEID = 4,
			TI_GET_BASETYPE = 5,
			TI_GET_ARRAYINDEXTYPEID = 6,
			TI_FINDCHILDREN = 7,
			TI_GET_DATAKIND = 8,
			TI_GET_ADDRESSOFFSET = 9,
			TI_GET_OFFSET = 10,
			TI_GET_VALUE = 11,
			TI_GET_COUNT = 12,
			TI_GET_CHILDRENCOUNT = 13,
			TI_GET_BITPOSITION = 14,
			TI_GET_VIRTUALBASECLASS = 15,
			TI_GET_VIRTUALTABLESHAPEID = 16,
			TI_GET_VIRTUALBASEPOINTEROFFSET = 17,
			TI_GET_CLASSPARENTID = 18,
			TI_GET_NESTED = 19,
			TI_GET_SYMINDEX = 20,
			TI_GET_LEXICALPARENT = 21,
			TI_GET_ADDRESS = 22,
			TI_GET_THISADJUST = 23,
			TI_GET_UDTKIND = 24,
			TI_IS_EQUIV_TO = 25,
			TI_GET_CALLING_CONVENTION = 26,
			TI_IS_CLOSE_EQUIV_TO = 27,
			TI_GTIEX_REQS_VALID = 28,
			TI_GET_VIRTUALBASEOFFSET = 29,
			TI_GET_VIRTUALBASEDISPINDEX = 30,
			TI_GET_IS_REFERENCE = 31,
			TI_GET_INDIRECTVIRTUALBASECLASS = 32,
			TI_GET_VIRTUALBASETABLETYPE = 33,
			TI_GET_OBJECTPOINTERTYPE = 34,
			IMAGEHLP_SYMBOL_TYPE_INFO_MAX = 35,
		}
		public enum IMAGEHLP_SF_TYPE : int32
		{
			Image = 0,
			Dbg = 1,
			Pdb = 2,
			Mpd = 3,
			Max = 4,
		}
		public enum APPLICATION_NODE_EVENT_FILTER : int32
		{
			NOTHING = 0,
			ANONYMOUS_CODE = 1,
			EVAL_CODE = 2,
		}
		public enum SCRIPT_DEBUGGER_OPTIONS : int32
		{
			NONE = 0,
			ENABLE_FIRST_CHANCE_EXCEPTIONS = 1,
			ENABLE_WEB_WORKER_SUPPORT = 2,
			ENABLE_NONUSER_CODE_SUPPORT = 4,
			ENABLE_LIBRARY_STACK_FRAME = 8,
		}
		public enum SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND : int32
		{
			FIRST_CHANCE = 0,
			USER_UNHANDLED = 1,
			UNHANDLED = 2,
		}
		public enum SCRIPT_INVOCATION_CONTEXT_TYPE : int32
		{
			Event = 0,
			SetTimeout = 1,
			SetInterval = 2,
			SetImmediate = 3,
			RequestAnimationFrame = 4,
			ToString = 5,
			MutationObserverCheckpoint = 6,
			WWAExecUnsafeLocalFunction = 7,
			WWAExecAtPriority = 8,
		}
		public enum DEBUG_STACKFRAME_TYPE : int32
		{
			SCRIPT_FRAME = 0,
			INTERNAL_FRAME = 1,
			INVOCATION_FRAME = 2,
		}
		public enum DEBUG_EVENT_INFO_TYPE : int32
		{
			GENERAL = 0,
			ASMJS_IN_DEBUGGING = 1,
			ASMJS_SUCCEEDED = 2,
			ASMJS_FAILED = 3,
		}
		public enum JS_PROPERTY_MEMBERS : int32
		{
			ALL = 0,
			ARGUMENTS = 1,
		}
		public enum JS_PROPERTY_ATTRIBUTES : int32
		{
			ATTRIBUTE_NONE = 0,
			HAS_CHILDREN = 1,
			FAKE = 2,
			METHOD = 4,
			READONLY = 8,
			NATIVE_WINRT_POINTER = 16,
			FRAME_INTRYBLOCK = 32,
			FRAME_INCATCHBLOCK = 64,
			FRAME_INFINALLYBLOCK = 128,
		}
		public enum JsDebugReadMemoryFlags : int32
		{
			None = 0,
			JsDebugAllowPartialRead = 1,
		}
		public enum _DUMP_TYPES : int32
		{
			INVALID = -1,
			UNKNOWN = 0,
			FULL = 1,
			SUMMARY = 2,
			HEADER = 3,
			TRIAGE = 4,
			BITMAP_FULL = 5,
			BITMAP_KERNEL = 6,
			AUTOMATIC = 7,
		}
		public enum WHEA_ERROR_SOURCE_TYPE : int32
		{
			MCE = 0,
			CMC = 1,
			CPE = 2,
			NMI = 3,
			PCIe = 4,
			Generic = 5,
			INIT = 6,
			BOOT = 7,
			SCIGeneric = 8,
			IPFMCA = 9,
			IPFCMC = 10,
			IPFCPE = 11,
			GenericV2 = 12,
			SCIGenericV2 = 13,
			BMC = 14,
			PMEM = 15,
			DeviceDriver = 16,
			Max = 17,
		}
		public enum WHEA_ERROR_SOURCE_STATE : int32
		{
			Stopped = 1,
			Started = 2,
			Removed = 3,
			RemovePending = 4,
		}
		public enum IPMI_OS_SEL_RECORD_TYPE : int32
		{
			Whea = 0,
			Other = 1,
			WheaErrorXpfMca = 2,
			WheaErrorPci = 3,
			WheaErrorNmi = 4,
			WheaErrorOther = 5,
			Raw = 6,
			Driver = 7,
			BugcheckRecovery = 8,
			BugcheckData = 9,
			Max = 10,
		}
		
		// --- Function Pointers ---
		
		public function IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* PGET_RUNTIME_FUNCTION_CALLBACK(uint64 ControlPc, void* Context);
		public function HResult PDEBUG_EXTENSION_INITIALIZE(out uint32 Version, out uint32 Flags);
		public function void PDEBUG_EXTENSION_UNINITIALIZE();
		public function HResult PDEBUG_EXTENSION_CANUNLOAD();
		public function void PDEBUG_EXTENSION_UNLOAD();
		public function void PDEBUG_EXTENSION_NOTIFY(uint32 Notify, uint64 Argument);
		public function HResult PDEBUG_EXTENSION_CALL(ref IDebugClient Client, char8* Args);
		public function HResult PDEBUG_EXTENSION_KNOWN_STRUCT(uint32 Flags, uint64 Offset, char8* TypeName, uint8* Buffer, uint32* BufferChars);
		public function HResult PDEBUG_EXTENSION_KNOWN_STRUCT_EX(ref IDebugClient Client, uint32 Flags, uint64 Offset, char8* TypeName, uint8* Buffer, uint32* BufferChars);
		public function HResult PDEBUG_EXTENSION_QUERY_VALUE_NAMES(ref IDebugClient Client, uint32 Flags, char16* Buffer, uint32 BufferChars, out uint32 BufferNeeded);
		public function HResult PDEBUG_EXTENSION_PROVIDE_VALUE(ref IDebugClient Client, uint32 Flags, char16* Name, out uint64 Value, out uint64 TypeModBase, out uint32 TypeId, out uint32 TypeFlags);
		public function HResult PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION(uint32 StreamType, void* MiniDumpStreamBuffer, uint32 BufferSize);
		public function HResult PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK(uint32 SystemThreadId, DEBUG_STACK_FRAME_EX* NativeFrames, uint32 CountNativeFrames, out STACK_SYM_FRAME_INFO* StackSymFrames, out uint32 StackSymFramesFilled);
		public function HResult PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES(STACK_SYM_FRAME_INFO* StackSymFrames);
		public function HResult PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION();
		public function void PWINDBG_OUTPUT_ROUTINE(char8* lpFormat);
		public function uint PWINDBG_GET_EXPRESSION(char8* lpExpression);
		public function uint32 PWINDBG_GET_EXPRESSION32(char8* lpExpression);
		public function uint64 PWINDBG_GET_EXPRESSION64(char8* lpExpression);
		public function void PWINDBG_GET_SYMBOL(void* offset, char8* pchBuffer, out uint pDisplacement);
		public function void PWINDBG_GET_SYMBOL32(uint32 offset, char8* pchBuffer, out uint32 pDisplacement);
		public function void PWINDBG_GET_SYMBOL64(uint64 offset, char8* pchBuffer, out uint64 pDisplacement);
		public function uint32 PWINDBG_DISASM(out uint lpOffset, char8* lpBuffer, uint32 fShowEffectiveAddress);
		public function uint32 PWINDBG_DISASM32(out uint32 lpOffset, char8* lpBuffer, uint32 fShowEffectiveAddress);
		public function uint32 PWINDBG_DISASM64(out uint64 lpOffset, char8* lpBuffer, uint32 fShowEffectiveAddress);
		public function uint32 PWINDBG_CHECK_CONTROL_C();
		public function uint32 PWINDBG_READ_PROCESS_MEMORY_ROUTINE(uint offset, void* lpBuffer, uint32 cb, out uint32 lpcbBytesRead);
		public function uint32 PWINDBG_READ_PROCESS_MEMORY_ROUTINE32(uint32 offset, void* lpBuffer, uint32 cb, out uint32 lpcbBytesRead);
		public function uint32 PWINDBG_READ_PROCESS_MEMORY_ROUTINE64(uint64 offset, void* lpBuffer, uint32 cb, out uint32 lpcbBytesRead);
		public function uint32 PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE(uint offset, void* lpBuffer, uint32 cb, out uint32 lpcbBytesWritten);
		public function uint32 PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32(uint32 offset, void* lpBuffer, uint32 cb, out uint32 lpcbBytesWritten);
		public function uint32 PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64(uint64 offset, void* lpBuffer, uint32 cb, out uint32 lpcbBytesWritten);
		public function uint32 PWINDBG_GET_THREAD_CONTEXT_ROUTINE(uint32 Processor, out CONTEXT lpContext, uint32 cbSizeOfContext);
		public function uint32 PWINDBG_SET_THREAD_CONTEXT_ROUTINE(uint32 Processor, out CONTEXT lpContext, uint32 cbSizeOfContext);
		public function uint32 PWINDBG_IOCTL_ROUTINE(uint16 IoctlType, void* lpvData, uint32 cbSize);
		public function uint32 PWINDBG_OLDKD_READ_PHYSICAL_MEMORY(uint64 address, void* buffer, uint32 count, out uint32 bytesread);
		public function uint32 PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY(uint64 address, void* buffer, uint32 length, out uint32 byteswritten);
		public function uint32 PWINDBG_STACKTRACE_ROUTINE(uint32 FramePointer, uint32 StackPointer, uint32 ProgramCounter, out EXTSTACKTRACE StackFrames, uint32 Frames);
		public function uint32 PWINDBG_STACKTRACE_ROUTINE32(uint32 FramePointer, uint32 StackPointer, uint32 ProgramCounter, out EXTSTACKTRACE32 StackFrames, uint32 Frames);
		public function uint32 PWINDBG_STACKTRACE_ROUTINE64(uint64 FramePointer, uint64 StackPointer, uint64 ProgramCounter, out EXTSTACKTRACE64 StackFrames, uint32 Frames);
		public function void PWINDBG_OLD_EXTENSION_ROUTINE(uint32 dwCurrentPc, out WINDBG_EXTENSION_APIS lpExtensionApis, char8* lpArgumentString);
		public function void PWINDBG_EXTENSION_ROUTINE(Handle hCurrentProcess, Handle hCurrentThread, uint32 dwCurrentPc, uint32 dwProcessor, char8* lpArgumentString);
		public function void PWINDBG_EXTENSION_ROUTINE32(Handle hCurrentProcess, Handle hCurrentThread, uint32 dwCurrentPc, uint32 dwProcessor, char8* lpArgumentString);
		public function void PWINDBG_EXTENSION_ROUTINE64(Handle hCurrentProcess, Handle hCurrentThread, uint64 dwCurrentPc, uint32 dwProcessor, char8* lpArgumentString);
		public function void PWINDBG_OLDKD_EXTENSION_ROUTINE(uint32 dwCurrentPc, out WINDBG_OLDKD_EXTENSION_APIS lpExtensionApis, char8* lpArgumentString);
		public function void PWINDBG_EXTENSION_DLL_INIT(out WINDBG_EXTENSION_APIS lpExtensionApis, uint16 MajorVersion, uint16 MinorVersion);
		public function void PWINDBG_EXTENSION_DLL_INIT32(out WINDBG_EXTENSION_APIS32 lpExtensionApis, uint16 MajorVersion, uint16 MinorVersion);
		public function void PWINDBG_EXTENSION_DLL_INIT64(out WINDBG_EXTENSION_APIS64 lpExtensionApis, uint16 MajorVersion, uint16 MinorVersion);
		public function uint32 PWINDBG_CHECK_VERSION();
		public function EXT_API_VERSION* PWINDBG_EXTENSION_API_VERSION();
		public function uint32 PSYM_DUMP_FIELD_CALLBACK(out FIELD_INFO pField, void* UserContext);
		public function int32 PVECTORED_EXCEPTION_HANDLER(out EXCEPTION_POINTERS ExceptionInfo);
		public function int32 LPTOP_LEVEL_EXCEPTION_FILTER(ref EXCEPTION_POINTERS ExceptionInfo);
		public function void PWAITCHAINCALLBACK(void* WctHandle, uint Context, uint32 CallbackStatus, out uint32 NodeCount, out WAITCHAIN_NODE_INFO NodeInfoArray, out int32 IsCycle);
		public function HResult PCOGETCALLSTATE(int32 param0, out uint32 param1);
		public function HResult PCOGETACTIVATIONSTATE(Guid param0, uint32 param1, out uint32 param2);
		public function IntBool MINIDUMP_CALLBACK_ROUTINE(void* CallbackParam, ref MINIDUMP_CALLBACK_INPUT CallbackInput, out MINIDUMP_CALLBACK_OUTPUT CallbackOutput);
		public function IntBool PIMAGEHLP_STATUS_ROUTINE(IMAGEHLP_STATUS_REASON Reason, char8* ImageName, char8* DllName, uint Va, uint Parameter);
		public function IntBool PIMAGEHLP_STATUS_ROUTINE32(IMAGEHLP_STATUS_REASON Reason, char8* ImageName, char8* DllName, uint32 Va, uint Parameter);
		public function IntBool PIMAGEHLP_STATUS_ROUTINE64(IMAGEHLP_STATUS_REASON Reason, char8* ImageName, char8* DllName, uint64 Va, uint Parameter);
		public function IntBool DIGEST_FUNCTION(void* refdata, out uint8 pData, uint32 dwLength);
		public function IntBool PFIND_DEBUG_FILE_CALLBACK(Handle FileHandle, char8* FileName, void* CallerData);
		public function IntBool PFIND_DEBUG_FILE_CALLBACKW(Handle FileHandle, char16* FileName, void* CallerData);
		public function IntBool PFINDFILEINPATHCALLBACK(char8* filename, void* context);
		public function IntBool PFINDFILEINPATHCALLBACKW(char16* filename, void* context);
		public function IntBool PFIND_EXE_FILE_CALLBACK(Handle FileHandle, char8* FileName, void* CallerData);
		public function IntBool PFIND_EXE_FILE_CALLBACKW(Handle FileHandle, char16* FileName, void* CallerData);
		public function IntBool PENUMDIRTREE_CALLBACK(char8* FilePath, void* CallerData);
		public function IntBool PENUMDIRTREE_CALLBACKW(char16* FilePath, void* CallerData);
		public function IntBool PREAD_PROCESS_MEMORY_ROUTINE64(Handle hProcess, uint64 qwBaseAddress, void* lpBuffer, uint32 nSize, out uint32 lpNumberOfBytesRead);
		public function void* PFUNCTION_TABLE_ACCESS_ROUTINE64(Handle ahProcess, uint64 AddrBase);
		public function uint64 PGET_MODULE_BASE_ROUTINE64(Handle hProcess, uint64 Address);
		public function uint64 PTRANSLATE_ADDRESS_ROUTINE64(Handle hProcess, Handle hThread, ref ADDRESS64 lpaddr);
		public function IntBool PSYM_ENUMMODULES_CALLBACK64(char8* ModuleName, uint64 BaseOfDll, void* UserContext);
		public function IntBool PSYM_ENUMMODULES_CALLBACKW64(char16* ModuleName, uint64 BaseOfDll, void* UserContext);
		public function IntBool PENUMLOADED_MODULES_CALLBACK64(char8* ModuleName, uint64 ModuleBase, uint32 ModuleSize, void* UserContext);
		public function IntBool PENUMLOADED_MODULES_CALLBACKW64(char16* ModuleName, uint64 ModuleBase, uint32 ModuleSize, void* UserContext);
		public function IntBool PSYM_ENUMSYMBOLS_CALLBACK64(char8* SymbolName, uint64 SymbolAddress, uint32 SymbolSize, void* UserContext);
		public function IntBool PSYM_ENUMSYMBOLS_CALLBACK64W(char16* SymbolName, uint64 SymbolAddress, uint32 SymbolSize, void* UserContext);
		public function IntBool PSYMBOL_REGISTERED_CALLBACK64(Handle hProcess, uint32 ActionCode, uint64 CallbackData, uint64 UserContext);
		public function void* PSYMBOL_FUNCENTRY_CALLBACK(Handle hProcess, uint32 AddrBase, void* UserContext);
		public function void* PSYMBOL_FUNCENTRY_CALLBACK64(Handle hProcess, uint64 AddrBase, uint64 UserContext);
		public function IntBool PSYM_ENUMSOURCEFILES_CALLBACK(ref SOURCEFILE pSourceFile, void* UserContext);
		public function IntBool PSYM_ENUMSOURCEFILES_CALLBACKW(ref SOURCEFILEW pSourceFile, void* UserContext);
		public function IntBool PSYM_ENUMLINES_CALLBACK(ref SRCCODEINFO LineInfo, void* UserContext);
		public function IntBool PSYM_ENUMLINES_CALLBACKW(ref SRCCODEINFOW LineInfo, void* UserContext);
		public function IntBool PENUMSOURCEFILETOKENSCALLBACK(void* token, uint size);
		public function IntBool PSYM_ENUMPROCESSES_CALLBACK(Handle hProcess, void* UserContext);
		public function IntBool PSYM_ENUMERATESYMBOLS_CALLBACK(ref SYMBOL_INFO pSymInfo, uint32 SymbolSize, void* UserContext);
		public function IntBool PSYM_ENUMERATESYMBOLS_CALLBACKW(ref SYMBOL_INFOW pSymInfo, uint32 SymbolSize, void* UserContext);
		public function IntBool SYMADDSOURCESTREAM(Handle param0, uint64 param1, char8* param2, out uint8 param3, uint param4);
		public function IntBool SYMADDSOURCESTREAMA(Handle param0, uint64 param1, char8* param2, out uint8 param3, uint param4);
		public function IntBool PDBGHELP_CREATE_USER_DUMP_CALLBACK(uint32 DataType, void** Data, out uint32 DataLength, void* UserData);
		public function IntBool PSYMBOLSERVERPROC(char8* param0, char8* param1, void* param2, uint32 param3, uint32 param4, char8* param5);
		public function IntBool PSYMBOLSERVERPROCA(char8* param0, char8* param1, void* param2, uint32 param3, uint32 param4, char8* param5);
		public function IntBool PSYMBOLSERVERPROCW(char16* param0, char16* param1, void* param2, uint32 param3, uint32 param4, char16* param5);
		public function IntBool PSYMBOLSERVERBYINDEXPROC(char8* param0, char8* param1, char8* param2, char8* param3);
		public function IntBool PSYMBOLSERVERBYINDEXPROCA(char8* param0, char8* param1, char8* param2, char8* param3);
		public function IntBool PSYMBOLSERVERBYINDEXPROCW(char16* param0, char16* param1, char16* param2, char16* param3);
		public function IntBool PSYMBOLSERVEROPENPROC();
		public function IntBool PSYMBOLSERVERCLOSEPROC();
		public function IntBool PSYMBOLSERVERSETOPTIONSPROC(uint param0, uint64 param1);
		public function IntBool PSYMBOLSERVERSETOPTIONSWPROC(uint param0, uint64 param1);
		public function IntBool PSYMBOLSERVERCALLBACKPROC(uint action, uint64 data, uint64 context);
		public function uint PSYMBOLSERVERGETOPTIONSPROC();
		public function IntBool PSYMBOLSERVERPINGPROC(char8* param0);
		public function IntBool PSYMBOLSERVERPINGPROCA(char8* param0);
		public function IntBool PSYMBOLSERVERPINGPROCW(char16* param0);
		public function IntBool PSYMBOLSERVERGETVERSION(out API_VERSION param0);
		public function IntBool PSYMBOLSERVERDELTANAME(char8* param0, void* param1, uint32 param2, uint32 param3, void* param4, uint32 param5, uint32 param6, char8* param7, uint param8);
		public function IntBool PSYMBOLSERVERDELTANAMEW(char16* param0, void* param1, uint32 param2, uint32 param3, void* param4, uint32 param5, uint32 param6, char16* param7, uint param8);
		public function IntBool PSYMBOLSERVERGETSUPPLEMENT(char8* param0, char8* param1, char8* param2, char8* param3, uint param4);
		public function IntBool PSYMBOLSERVERGETSUPPLEMENTW(char16* param0, char16* param1, char16* param2, char16* param3, uint param4);
		public function IntBool PSYMBOLSERVERSTORESUPPLEMENT(char8* param0, char8* param1, char8* param2, char8* param3, uint param4, uint32 param5);
		public function IntBool PSYMBOLSERVERSTORESUPPLEMENTW(char16* param0, char16* param1, char16* param2, char16* param3, uint param4, uint32 param5);
		public function IntBool PSYMBOLSERVERGETINDEXSTRING(void* param0, uint32 param1, uint32 param2, char8* param3, uint param4);
		public function IntBool PSYMBOLSERVERGETINDEXSTRINGW(void* param0, uint32 param1, uint32 param2, char16* param3, uint param4);
		public function IntBool PSYMBOLSERVERSTOREFILE(char8* param0, char8* param1, void* param2, uint32 param3, uint32 param4, char8* param5, uint param6, uint32 param7);
		public function IntBool PSYMBOLSERVERSTOREFILEW(char16* param0, char16* param1, void* param2, uint32 param3, uint32 param4, char16* param5, uint param6, uint32 param7);
		public function IntBool PSYMBOLSERVERISSTORE(char8* param0);
		public function IntBool PSYMBOLSERVERISSTOREW(char16* param0);
		public function uint32 PSYMBOLSERVERVERSION();
		public function IntBool PSYMBOLSERVERMESSAGEPROC(uint action, uint64 data, uint64 context);
		public function IntBool PSYMBOLSERVERWEXPROC(char16* param0, char16* param1, void* param2, uint32 param3, uint32 param4, char16* param5, out SYMSRV_EXTENDED_OUTPUT_DATA param6);
		public function IntBool PSYMBOLSERVERPINGPROCWEX(char16* param0);
		public function IntBool PSYMBOLSERVERGETOPTIONDATAPROC(uint param0, out uint64 param1);
		public function IntBool PSYMBOLSERVERSETHTTPAUTHHEADER(char16* pszAuthHeader);
		public function uint32 LPCALL_BACK_USER_INTERRUPT_ROUTINE();
		public function NTSTATUS WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER(void* Context, uint32 ErrorSourceId);
		public function void WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER(void* Context);
		public function NTSTATUS WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER(void* ErrorSourceDesc, out uint32 MaximumSectionLength);
		public function IntBool PREAD_PROCESS_MEMORY_ROUTINE(Handle hProcess, uint32 lpBaseAddress, void* lpBuffer, uint32 nSize, out uint32 lpNumberOfBytesRead);
		public function void* PFUNCTION_TABLE_ACCESS_ROUTINE(Handle hProcess, uint32 AddrBase);
		public function uint32 PGET_MODULE_BASE_ROUTINE(Handle hProcess, uint32 Address);
		public function uint32 PTRANSLATE_ADDRESS_ROUTINE(Handle hProcess, Handle hThread, out ADDRESS lpaddr);
		public function IntBool PSYM_ENUMMODULES_CALLBACK(char8* ModuleName, uint32 BaseOfDll, void* UserContext);
		public function IntBool PSYM_ENUMSYMBOLS_CALLBACK(char8* SymbolName, uint32 SymbolAddress, uint32 SymbolSize, void* UserContext);
		public function IntBool PSYM_ENUMSYMBOLS_CALLBACKW(char16* SymbolName, uint32 SymbolAddress, uint32 SymbolSize, void* UserContext);
		public function IntBool PENUMLOADED_MODULES_CALLBACK(char8* ModuleName, uint32 ModuleBase, uint32 ModuleSize, void* UserContext);
		public function IntBool PSYMBOL_REGISTERED_CALLBACK(Handle hProcess, uint32 ActionCode, void* CallbackData, void* UserContext);
		
		// --- Structs ---
		
		[CRepr]
		public struct CONTEXT
		{
			public uint32 ContextFlags;
			public uint32 Cpsr;
			public _Anonymous_e__Union Anonymous;
			public uint64 Sp;
			public uint64 Pc;
			public ARM64_NT_NEON128[32] V;
			public uint32 Fpcr;
			public uint32 Fpsr;
			public uint32[8] Bcr;
			public uint64[8] Bvr;
			public uint32[2] Wcr;
			public uint64[2] Wvr;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public _Anonymous_e__Struct Anonymous;
				public uint64[31] X;
				
				[CRepr]
				public struct _Anonymous_e__Struct
				{
					public uint64 X0;
					public uint64 X1;
					public uint64 X2;
					public uint64 X3;
					public uint64 X4;
					public uint64 X5;
					public uint64 X6;
					public uint64 X7;
					public uint64 X8;
					public uint64 X9;
					public uint64 X10;
					public uint64 X11;
					public uint64 X12;
					public uint64 X13;
					public uint64 X14;
					public uint64 X15;
					public uint64 X16;
					public uint64 X17;
					public uint64 X18;
					public uint64 X19;
					public uint64 X20;
					public uint64 X21;
					public uint64 X22;
					public uint64 X23;
					public uint64 X24;
					public uint64 X25;
					public uint64 X26;
					public uint64 X27;
					public uint64 X28;
					public uint64 Fp;
					public uint64 Lr;
				}
			}
		}
		[CRepr]
		public struct DISPATCHER_CONTEXT
		{
			public uint ControlPc;
			public uint ImageBase;
			public IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* FunctionEntry;
			public uint EstablisherFrame;
			public uint TargetPc;
			public CONTEXT* ContextRecord;
			public EXCEPTION_ROUTINE LanguageHandler;
			public void* HandlerData;
			public UNWIND_HISTORY_TABLE* HistoryTable;
			public uint32 ScopeIndex;
			public bool ControlPcIsUnwound;
			public uint8* NonVolatileRegisters;
		}
		[CRepr]
		public struct KNONVOLATILE_CONTEXT_POINTERS_ARM64
		{
			public uint64* X19;
			public uint64* X20;
			public uint64* X21;
			public uint64* X22;
			public uint64* X23;
			public uint64* X24;
			public uint64* X25;
			public uint64* X26;
			public uint64* X27;
			public uint64* X28;
			public uint64* Fp;
			public uint64* Lr;
			public uint64* D8;
			public uint64* D9;
			public uint64* D10;
			public uint64* D11;
			public uint64* D12;
			public uint64* D13;
			public uint64* D14;
			public uint64* D15;
		}
		[CRepr]
		public struct UNWIND_HISTORY_TABLE_ENTRY
		{
			public uint ImageBase;
			public IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* FunctionEntry;
		}
		[CRepr]
		public struct MINIDUMP_THREAD_CALLBACK
		{
			public uint32 ThreadId;
			public Handle ThreadHandle;
			public uint32 Pad;
			public CONTEXT Context;
			public uint32 SizeOfContext;
			public uint64 StackBase;
			public uint64 StackEnd;
		}
		[CRepr]
		public struct MINIDUMP_THREAD_EX_CALLBACK
		{
			public uint32 ThreadId;
			public Handle ThreadHandle;
			public uint32 Pad;
			public CONTEXT Context;
			public uint32 SizeOfContext;
			public uint64 StackBase;
			public uint64 StackEnd;
			public uint64 BackingStoreBase;
			public uint64 BackingStoreEnd;
		}
		[CRepr]
		public struct EXCEPTION_DEBUG_INFO
		{
			public EXCEPTION_RECORD ExceptionRecord;
			public uint32 dwFirstChance;
		}
		[CRepr]
		public struct CREATE_THREAD_DEBUG_INFO
		{
			public Handle hThread;
			public void* lpThreadLocalBase;
			public LPTHREAD_START_ROUTINE lpStartAddress;
		}
		[CRepr]
		public struct CREATE_PROCESS_DEBUG_INFO
		{
			public Handle hFile;
			public Handle hProcess;
			public Handle hThread;
			public void* lpBaseOfImage;
			public uint32 dwDebugInfoFileOffset;
			public uint32 nDebugInfoSize;
			public void* lpThreadLocalBase;
			public LPTHREAD_START_ROUTINE lpStartAddress;
			public void* lpImageName;
			public uint16 fUnicode;
		}
		[CRepr]
		public struct EXIT_THREAD_DEBUG_INFO
		{
			public uint32 dwExitCode;
		}
		[CRepr]
		public struct EXIT_PROCESS_DEBUG_INFO
		{
			public uint32 dwExitCode;
		}
		[CRepr]
		public struct LOAD_DLL_DEBUG_INFO
		{
			public Handle hFile;
			public void* lpBaseOfDll;
			public uint32 dwDebugInfoFileOffset;
			public uint32 nDebugInfoSize;
			public void* lpImageName;
			public uint16 fUnicode;
		}
		[CRepr]
		public struct UNLOAD_DLL_DEBUG_INFO
		{
			public void* lpBaseOfDll;
		}
		[CRepr]
		public struct OUTPUT_DEBUG_STRING_INFO
		{
			public char8* lpDebugStringData;
			public uint16 fUnicode;
			public uint16 nDebugStringLength;
		}
		[CRepr]
		public struct RIP_INFO
		{
			public uint32 dwError;
			public RIP_INFO_TYPE dwType;
		}
		[CRepr]
		public struct DEBUG_EVENT
		{
			public DEBUG_EVENT_CODE dwDebugEventCode;
			public uint32 dwProcessId;
			public uint32 dwThreadId;
			public _u_e__Union u;
			
			[CRepr, Union]
			public struct _u_e__Union
			{
				public EXCEPTION_DEBUG_INFO Exception;
				public CREATE_THREAD_DEBUG_INFO CreateThread;
				public CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
				public EXIT_THREAD_DEBUG_INFO ExitThread;
				public EXIT_PROCESS_DEBUG_INFO ExitProcess;
				public LOAD_DLL_DEBUG_INFO LoadDll;
				public UNLOAD_DLL_DEBUG_INFO UnloadDll;
				public OUTPUT_DEBUG_STRING_INFO DebugString;
				public RIP_INFO RipInfo;
			}
		}
		[CRepr]
		public struct DEBUG_OFFSET_REGION
		{
			public uint64 Base;
			public uint64 Size;
		}
		[CRepr]
		public struct DEBUG_READ_USER_MINIDUMP_STREAM
		{
			public uint32 StreamType;
			public uint32 Flags;
			public uint64 Offset;
			public void* Buffer;
			public uint32 BufferSize;
			public uint32 BufferUsed;
		}
		[CRepr]
		public struct DEBUG_GET_TEXT_COMPLETIONS_IN
		{
			public uint32 Flags;
			public uint32 MatchCountLimit;
			public uint64[3] Reserved;
		}
		[CRepr]
		public struct DEBUG_GET_TEXT_COMPLETIONS_OUT
		{
			public uint32 Flags;
			public uint32 ReplaceIndex;
			public uint32 MatchCount;
			public uint32 Reserved1;
			public uint64[2] Reserved2;
		}
		[CRepr]
		public struct DEBUG_CACHED_SYMBOL_INFO
		{
			public uint64 ModBase;
			public uint64 Arg1;
			public uint64 Arg2;
			public uint32 Id;
			public uint32 Arg3;
		}
		[CRepr]
		public struct PROCESS_NAME_ENTRY
		{
			public uint32 ProcessId;
			public uint32 NameOffset;
			public uint32 NameSize;
			public uint32 NextEntry;
		}
		[CRepr]
		public struct DEBUG_THREAD_BASIC_INFORMATION
		{
			public uint32 Valid;
			public uint32 ExitStatus;
			public uint32 PriorityClass;
			public uint32 Priority;
			public uint64 CreateTime;
			public uint64 ExitTime;
			public uint64 KernelTime;
			public uint64 UserTime;
			public uint64 StartOffset;
			public uint64 Affinity;
		}
		[CRepr]
		public struct SYMBOL_INFO_EX
		{
			public uint32 SizeOfStruct;
			public uint32 TypeOfInfo;
			public uint64 Offset;
			public uint32 Line;
			public uint32 Displacement;
			public uint32[4] Reserved;
		}
		[CRepr]
		public struct DEBUG_BREAKPOINT_PARAMETERS
		{
			public uint64 Offset;
			public uint32 Id;
			public uint32 BreakType;
			public uint32 ProcType;
			public uint32 Flags;
			public uint32 DataSize;
			public uint32 DataAccessType;
			public uint32 PassCount;
			public uint32 CurrentPassCount;
			public uint32 MatchThread;
			public uint32 CommandSize;
			public uint32 OffsetExpressionSize;
		}
		[CRepr]
		public struct DEBUG_CREATE_PROCESS_OPTIONS
		{
			public uint32 CreateFlags;
			public uint32 EngCreateFlags;
			public uint32 VerifierFlags;
			public uint32 Reserved;
		}
		[CRepr]
		public struct DEBUG_CLIENT_CONTEXT
		{
			public uint32 cbSize;
			public uint32 eClient;
		}
		[CRepr]
		public struct DEBUG_STACK_FRAME
		{
			public uint64 InstructionOffset;
			public uint64 ReturnOffset;
			public uint64 FrameOffset;
			public uint64 StackOffset;
			public uint64 FuncTableEntry;
			public uint64[4] Params;
			public uint64[6] Reserved;
			public IntBool Virtual;
			public uint32 FrameNumber;
		}
		[CRepr]
		public struct DEBUG_STACK_FRAME_EX
		{
			public uint64 InstructionOffset;
			public uint64 ReturnOffset;
			public uint64 FrameOffset;
			public uint64 StackOffset;
			public uint64 FuncTableEntry;
			public uint64[4] Params;
			public uint64[6] Reserved;
			public IntBool Virtual;
			public uint32 FrameNumber;
			public uint32 InlineFrameContext;
			public uint32 Reserved1;
		}
		[CRepr, Union]
		public struct INLINE_FRAME_CONTEXT
		{
			public uint32 ContextValue;
			public _Anonymous_e__Struct Anonymous;
			
			[CRepr]
			public struct _Anonymous_e__Struct
			{
				public uint8 FrameId;
				public uint8 FrameType;
				public uint16 FrameSignature;
			}
		}
		[CRepr]
		public struct STACK_SRC_INFO
		{
			public char16* ImagePath;
			public char16* ModuleName;
			public char16* Function;
			public uint32 Displacement;
			public uint32 Row;
			public uint32 Column;
		}
		[CRepr]
		public struct STACK_SYM_FRAME_INFO
		{
			public DEBUG_STACK_FRAME_EX StackFrameEx;
			public STACK_SRC_INFO SrcInfo;
		}
		[CRepr]
		public struct DEBUG_SPECIFIC_FILTER_PARAMETERS
		{
			public uint32 ExecutionOption;
			public uint32 ContinueOption;
			public uint32 TextSize;
			public uint32 CommandSize;
			public uint32 ArgumentSize;
		}
		[CRepr]
		public struct DEBUG_EXCEPTION_FILTER_PARAMETERS
		{
			public uint32 ExecutionOption;
			public uint32 ContinueOption;
			public uint32 TextSize;
			public uint32 CommandSize;
			public uint32 SecondCommandSize;
			public uint32 ExceptionCode;
		}
		[CRepr]
		public struct DEBUG_LAST_EVENT_INFO_BREAKPOINT
		{
			public uint32 Id;
		}
		[CRepr]
		public struct DEBUG_LAST_EVENT_INFO_EXCEPTION
		{
			public EXCEPTION_RECORD64 ExceptionRecord;
			public uint32 FirstChance;
		}
		[CRepr]
		public struct DEBUG_LAST_EVENT_INFO_EXIT_THREAD
		{
			public uint32 ExitCode;
		}
		[CRepr]
		public struct DEBUG_LAST_EVENT_INFO_EXIT_PROCESS
		{
			public uint32 ExitCode;
		}
		[CRepr]
		public struct DEBUG_LAST_EVENT_INFO_LOAD_MODULE
		{
			public uint64 Base;
		}
		[CRepr]
		public struct DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE
		{
			public uint64 Base;
		}
		[CRepr]
		public struct DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR
		{
			public uint32 Error;
			public uint32 Level;
		}
		[CRepr]
		public struct DEBUG_LAST_EVENT_INFO_SERVICE_EXCEPTION
		{
			public uint32 Kind;
			public uint32 DataSize;
			public uint64 Address;
		}
		[CRepr]
		public struct DEBUG_VALUE
		{
			public _Anonymous_e__Union Anonymous;
			public uint32 TailOfRawBytes;
			public uint32 Type;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public uint8 I8;
				public uint16 I16;
				public uint32 I32;
				public _Anonymous_e__Struct Anonymous;
				public float F32;
				public double F64;
				public uint8[10] F80Bytes;
				public uint8[11] F82Bytes;
				public uint8[16] F128Bytes;
				public uint8[16] VI8;
				public uint16[8] VI16;
				public uint32[4] VI32;
				public uint64[2] VI64;
				public float[4] VF32;
				public double[2] VF64;
				public _I64Parts32_e__Struct I64Parts32;
				public _F128Parts64_e__Struct F128Parts64;
				public uint8[24] RawBytes;
				
				[CRepr]
				public struct _I64Parts32_e__Struct
				{
					public uint32 LowPart;
					public uint32 HighPart;
				}
				[CRepr]
				public struct _F128Parts64_e__Struct
				{
					public uint64 LowPart;
					public int64 HighPart;
				}
				[CRepr]
				public struct _Anonymous_e__Struct
				{
					public uint64 I64;
					public IntBool Nat;
				}
			}
		}
		[CRepr]
		public struct DEBUG_PROCESSOR_IDENTIFICATION_ALPHA
		{
			public uint32 Type;
			public uint32 Revision;
		}
		[CRepr]
		public struct DEBUG_PROCESSOR_IDENTIFICATION_AMD64
		{
			public uint32 Family;
			public uint32 Model;
			public uint32 Stepping;
			public char8[16] VendorString;
		}
		[CRepr]
		public struct DEBUG_PROCESSOR_IDENTIFICATION_IA64
		{
			public uint32 Model;
			public uint32 Revision;
			public uint32 Family;
			public uint32 ArchRev;
			public char8[16] VendorString;
		}
		[CRepr]
		public struct DEBUG_PROCESSOR_IDENTIFICATION_X86
		{
			public uint32 Family;
			public uint32 Model;
			public uint32 Stepping;
			public char8[16] VendorString;
		}
		[CRepr]
		public struct DEBUG_PROCESSOR_IDENTIFICATION_ARM
		{
			public uint32 Model;
			public uint32 Revision;
			public char8[16] VendorString;
		}
		[CRepr]
		public struct DEBUG_PROCESSOR_IDENTIFICATION_ARM64
		{
			public uint32 Model;
			public uint32 Revision;
			public char8[16] VendorString;
		}
		[CRepr, Union]
		public struct DEBUG_PROCESSOR_IDENTIFICATION_ALL
		{
			public DEBUG_PROCESSOR_IDENTIFICATION_ALPHA Alpha;
			public DEBUG_PROCESSOR_IDENTIFICATION_AMD64 Amd64;
			public DEBUG_PROCESSOR_IDENTIFICATION_IA64 Ia64;
			public DEBUG_PROCESSOR_IDENTIFICATION_X86 X86;
			public DEBUG_PROCESSOR_IDENTIFICATION_ARM Arm;
			public DEBUG_PROCESSOR_IDENTIFICATION_ARM64 Arm64;
		}
		[CRepr]
		public struct DEBUG_HANDLE_DATA_BASIC
		{
			public uint32 TypeNameSize;
			public uint32 ObjectNameSize;
			public uint32 Attributes;
			public uint32 GrantedAccess;
			public uint32 HandleCount;
			public uint32 PointerCount;
		}
		[CRepr]
		public struct DEBUG_EVENT_CONTEXT
		{
			public uint32 Size;
			public uint32 ProcessEngineId;
			public uint32 ThreadEngineId;
			public uint32 FrameEngineId;
		}
		[CRepr]
		public struct DEBUG_REGISTER_DESCRIPTION
		{
			public uint32 Type;
			public uint32 Flags;
			public uint32 SubregMaster;
			public uint32 SubregLength;
			public uint64 SubregMask;
			public uint32 SubregShift;
			public uint32 Reserved0;
		}
		[CRepr]
		public struct DEBUG_SYMBOL_PARAMETERS
		{
			public uint64 Module;
			public uint32 TypeId;
			public uint32 ParentSymbol;
			public uint32 SubElements;
			public uint32 Flags;
			public uint64 Reserved;
		}
		[CRepr]
		public struct DEBUG_SYMBOL_ENTRY
		{
			public uint64 ModuleBase;
			public uint64 Offset;
			public uint64 Id;
			public uint64 Arg64;
			public uint32 Size;
			public uint32 Flags;
			public uint32 TypeId;
			public uint32 NameSize;
			public uint32 Token;
			public uint32 Tag;
			public uint32 Arg32;
			public uint32 Reserved;
		}
		[CRepr]
		public struct DEBUG_MODULE_PARAMETERS
		{
			public uint64 Base;
			public uint32 Size;
			public uint32 TimeDateStamp;
			public uint32 Checksum;
			public uint32 Flags;
			public uint32 SymbolType;
			public uint32 ImageNameSize;
			public uint32 ModuleNameSize;
			public uint32 LoadedImageNameSize;
			public uint32 SymbolFileNameSize;
			public uint32 MappedImageNameSize;
			public uint64[2] Reserved;
		}
		[CRepr]
		public struct DEBUG_MODULE_AND_ID
		{
			public uint64 ModuleBase;
			public uint64 Id;
		}
		[CRepr]
		public struct DEBUG_SYMBOL_SOURCE_ENTRY
		{
			public uint64 ModuleBase;
			public uint64 Offset;
			public uint64 FileNameId;
			public uint64 EngineInternal;
			public uint32 Size;
			public uint32 Flags;
			public uint32 FileNameSize;
			public uint32 StartLine;
			public uint32 EndLine;
			public uint32 StartColumn;
			public uint32 EndColumn;
			public uint32 Reserved;
		}
		[CRepr]
		public struct Location
		{
			public uint64 HostDefined;
			public uint64 Offset;
		}
		[CRepr]
		public struct ArrayDimension
		{
			public int64 LowerBound;
			public uint64 Length;
			public uint64 Stride;
		}
		[CRepr]
		public struct ScriptDebugPosition
		{
			public uint32 Line;
			public uint32 Column;
		}
		[CRepr]
		public struct ScriptDebugEventInformation
		{
			public ScriptDebugEvent DebugEvent;
			public ScriptDebugPosition EventPosition;
			public ScriptDebugPosition EventSpanEnd;
			public _u_e__Union u;
			
			[CRepr, Union]
			public struct _u_e__Union
			{
				public _ExceptionInformation_e__Struct ExceptionInformation;
				public _BreakpointInformation_e__Struct BreakpointInformation;
				
				[CRepr]
				public struct _ExceptionInformation_e__Struct
				{
					public Boolean IsUncaught;
				}
				[CRepr]
				public struct _BreakpointInformation_e__Struct
				{
					public uint64 BreakpointId;
				}
			}
		}
		[CRepr]
		public struct EXTSTACKTRACE
		{
			public uint32 FramePointer;
			public uint32 ProgramCounter;
			public uint32 ReturnAddress;
			public uint32[4] Args;
		}
		[CRepr]
		public struct EXTSTACKTRACE32
		{
			public uint32 FramePointer;
			public uint32 ProgramCounter;
			public uint32 ReturnAddress;
			public uint32[4] Args;
		}
		[CRepr]
		public struct EXTSTACKTRACE64
		{
			public uint64 FramePointer;
			public uint64 ProgramCounter;
			public uint64 ReturnAddress;
			public uint64[4] Args;
		}
		[CRepr]
		public struct WINDBG_EXTENSION_APIS
		{
			public uint32 nSize;
			public PWINDBG_OUTPUT_ROUTINE lpOutputRoutine;
			public PWINDBG_GET_EXPRESSION lpGetExpressionRoutine;
			public PWINDBG_GET_SYMBOL lpGetSymbolRoutine;
			public PWINDBG_DISASM lpDisasmRoutine;
			public PWINDBG_CHECK_CONTROL_C lpCheckControlCRoutine;
			public PWINDBG_READ_PROCESS_MEMORY_ROUTINE lpReadProcessMemoryRoutine;
			public PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE lpWriteProcessMemoryRoutine;
			public PWINDBG_GET_THREAD_CONTEXT_ROUTINE lpGetThreadContextRoutine;
			public PWINDBG_SET_THREAD_CONTEXT_ROUTINE lpSetThreadContextRoutine;
			public PWINDBG_IOCTL_ROUTINE lpIoctlRoutine;
			public PWINDBG_STACKTRACE_ROUTINE lpStackTraceRoutine;
		}
		[CRepr]
		public struct WINDBG_EXTENSION_APIS32
		{
			public uint32 nSize;
			public PWINDBG_OUTPUT_ROUTINE lpOutputRoutine;
			public PWINDBG_GET_EXPRESSION32 lpGetExpressionRoutine;
			public PWINDBG_GET_SYMBOL32 lpGetSymbolRoutine;
			public PWINDBG_DISASM32 lpDisasmRoutine;
			public PWINDBG_CHECK_CONTROL_C lpCheckControlCRoutine;
			public PWINDBG_READ_PROCESS_MEMORY_ROUTINE32 lpReadProcessMemoryRoutine;
			public PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteProcessMemoryRoutine;
			public PWINDBG_GET_THREAD_CONTEXT_ROUTINE lpGetThreadContextRoutine;
			public PWINDBG_SET_THREAD_CONTEXT_ROUTINE lpSetThreadContextRoutine;
			public PWINDBG_IOCTL_ROUTINE lpIoctlRoutine;
			public PWINDBG_STACKTRACE_ROUTINE32 lpStackTraceRoutine;
		}
		[CRepr]
		public struct WINDBG_EXTENSION_APIS64
		{
			public uint32 nSize;
			public PWINDBG_OUTPUT_ROUTINE lpOutputRoutine;
			public PWINDBG_GET_EXPRESSION64 lpGetExpressionRoutine;
			public PWINDBG_GET_SYMBOL64 lpGetSymbolRoutine;
			public PWINDBG_DISASM64 lpDisasmRoutine;
			public PWINDBG_CHECK_CONTROL_C lpCheckControlCRoutine;
			public PWINDBG_READ_PROCESS_MEMORY_ROUTINE64 lpReadProcessMemoryRoutine;
			public PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64 lpWriteProcessMemoryRoutine;
			public PWINDBG_GET_THREAD_CONTEXT_ROUTINE lpGetThreadContextRoutine;
			public PWINDBG_SET_THREAD_CONTEXT_ROUTINE lpSetThreadContextRoutine;
			public PWINDBG_IOCTL_ROUTINE lpIoctlRoutine;
			public PWINDBG_STACKTRACE_ROUTINE64 lpStackTraceRoutine;
		}
		[CRepr]
		public struct WINDBG_OLD_EXTENSION_APIS
		{
			public uint32 nSize;
			public PWINDBG_OUTPUT_ROUTINE lpOutputRoutine;
			public PWINDBG_GET_EXPRESSION lpGetExpressionRoutine;
			public PWINDBG_GET_SYMBOL lpGetSymbolRoutine;
			public PWINDBG_DISASM lpDisasmRoutine;
			public PWINDBG_CHECK_CONTROL_C lpCheckControlCRoutine;
		}
		[CRepr]
		public struct WINDBG_OLDKD_EXTENSION_APIS
		{
			public uint32 nSize;
			public PWINDBG_OUTPUT_ROUTINE lpOutputRoutine;
			public PWINDBG_GET_EXPRESSION32 lpGetExpressionRoutine;
			public PWINDBG_GET_SYMBOL32 lpGetSymbolRoutine;
			public PWINDBG_DISASM32 lpDisasmRoutine;
			public PWINDBG_CHECK_CONTROL_C lpCheckControlCRoutine;
			public PWINDBG_READ_PROCESS_MEMORY_ROUTINE32 lpReadVirtualMemRoutine;
			public PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 lpWriteVirtualMemRoutine;
			public PWINDBG_OLDKD_READ_PHYSICAL_MEMORY lpReadPhysicalMemRoutine;
			public PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY lpWritePhysicalMemRoutine;
		}
		[CRepr]
		public struct EXT_API_VERSION
		{
			public uint16 MajorVersion;
			public uint16 MinorVersion;
			public uint16 Revision;
			public uint16 Reserved;
		}
		[CRepr]
		public struct PROCESSORINFO
		{
			public uint16 Processor;
			public uint16 NumberProcessors;
		}
		[CRepr]
		public struct READCONTROLSPACE
		{
			public uint16 Processor;
			public uint32 Address;
			public uint32 BufLen;
			public uint8[0] Buf;
		}
		[CRepr]
		public struct READCONTROLSPACE32
		{
			public uint16 Processor;
			public uint32 Address;
			public uint32 BufLen;
			public uint8[0] Buf;
		}
		[CRepr]
		public struct READCONTROLSPACE64
		{
			public uint16 Processor;
			public uint64 Address;
			public uint32 BufLen;
			public uint8[0] Buf;
		}
		[CRepr]
		public struct IOSPACE
		{
			public uint32 Address;
			public uint32 Length;
			public uint32 Data;
		}
		[CRepr]
		public struct IOSPACE32
		{
			public uint32 Address;
			public uint32 Length;
			public uint32 Data;
		}
		[CRepr]
		public struct IOSPACE64
		{
			public uint64 Address;
			public uint32 Length;
			public uint32 Data;
		}
		[CRepr]
		public struct IOSPACE_EX
		{
			public uint32 Address;
			public uint32 Length;
			public uint32 Data;
			public uint32 InterfaceType;
			public uint32 BusNumber;
			public uint32 AddressSpace;
		}
		[CRepr]
		public struct IOSPACE_EX32
		{
			public uint32 Address;
			public uint32 Length;
			public uint32 Data;
			public uint32 InterfaceType;
			public uint32 BusNumber;
			public uint32 AddressSpace;
		}
		[CRepr]
		public struct IOSPACE_EX64
		{
			public uint64 Address;
			public uint32 Length;
			public uint32 Data;
			public uint32 InterfaceType;
			public uint32 BusNumber;
			public uint32 AddressSpace;
		}
		[CRepr]
		public struct _GETSETBUSDATA
		{
			public uint32 BusDataType;
			public uint32 BusNumber;
			public uint32 SlotNumber;
			public void* Buffer;
			public uint32 Offset;
			public uint32 Length;
		}
		[CRepr]
		public struct SEARCHMEMORY
		{
			public uint64 SearchAddress;
			public uint64 SearchLength;
			public uint64 FoundAddress;
			public uint32 PatternLength;
			public void* Pattern;
		}
		[CRepr]
		public struct PHYSICAL
		{
			public uint64 Address;
			public uint32 BufLen;
			public uint8[0] Buf;
		}
		[CRepr]
		public struct PHYSICAL_WITH_FLAGS
		{
			public uint64 Address;
			public uint32 BufLen;
			public uint32 Flags;
			public uint8[0] Buf;
		}
		[CRepr]
		public struct READ_WRITE_MSR
		{
			public uint32 Msr;
			public int64 Value;
		}
		[CRepr]
		public struct GET_SET_SYMPATH
		{
			public char8* Args;
			public char8* Result;
			public int32 Length;
		}
		[CRepr]
		public struct GET_TEB_ADDRESS
		{
			public uint64 Address;
		}
		[CRepr]
		public struct GET_PEB_ADDRESS
		{
			public uint64 CurrentThread;
			public uint64 Address;
		}
		[CRepr]
		public struct GET_CURRENT_THREAD_ADDRESS
		{
			public uint32 Processor;
			public uint64 Address;
		}
		[CRepr]
		public struct GET_CURRENT_PROCESS_ADDRESS
		{
			public uint32 Processor;
			public uint64 CurrentThread;
			public uint64 Address;
		}
		[CRepr]
		public struct GET_INPUT_LINE
		{
			public char8* Prompt;
			public char8* Buffer;
			public uint32 BufferSize;
			public uint32 InputSize;
		}
		[CRepr]
		public struct GET_EXPRESSION_EX
		{
			public char8* Expression;
			public char8* Remainder;
			public uint64 Value;
		}
		[CRepr]
		public struct TRANSLATE_VIRTUAL_TO_PHYSICAL
		{
			public uint64 Virtual;
			public uint64 Physical;
		}
		[CRepr]
		public struct VIRTUAL_TO_PHYSICAL
		{
			public uint32 Status;
			public uint32 Size;
			public uint64 PdeAddress;
			public uint64 Virtual;
			public uint64 Physical;
		}
		[CRepr]
		public struct PHYSICAL_TO_VIRTUAL
		{
			public uint32 Status;
			public uint32 Size;
			public uint64 PdeAddress;
		}
		[CRepr]
		public struct GET_CONTEXT_EX
		{
			public uint32 Status;
			public uint32 ContextSize;
			public void* pContext;
		}
		[CRepr]
		public struct POINTER_SEARCH_PHYSICAL
		{
			public uint64 Offset;
			public uint64 Length;
			public uint64 PointerMin;
			public uint64 PointerMax;
			public uint32 Flags;
			public uint64* MatchOffsets;
			public uint32 MatchOffsetsSize;
			public uint32 MatchOffsetsCount;
		}
		[CRepr]
		public struct WDBGEXTS_THREAD_OS_INFO
		{
			public uint32 ThreadId;
			public uint32 ExitStatus;
			public uint32 PriorityClass;
			public uint32 Priority;
			public uint64 CreateTime;
			public uint64 ExitTime;
			public uint64 KernelTime;
			public uint64 UserTime;
			public uint64 StartOffset;
			public uint64 Affinity;
		}
		[CRepr]
		public struct WDBGEXTS_CLR_DATA_INTERFACE
		{
			public Guid* Iid;
			public void* Iface;
		}
		[CRepr]
		public struct EXT_MATCH_PATTERN_A
		{
			public char8* Str;
			public char8* Pattern;
			public uint32 CaseSensitive;
		}
		[CRepr]
		public struct EXT_FIND_FILE
		{
			public char16* FileName;
			public uint64 IndexedSize;
			public uint32 ImageTimeDateStamp;
			public uint32 ImageCheckSum;
			public void* ExtraInfo;
			public uint32 ExtraInfoSize;
			public uint32 Flags;
			public void* FileMapping;
			public uint64 FileMappingSize;
			public Handle FileHandle;
			public char16* FoundFileName;
			public uint32 FoundFileNameChars;
		}
		[CRepr]
		public struct DEBUG_TYPED_DATA
		{
			public uint64 ModBase;
			public uint64 Offset;
			public uint64 EngineHandle;
			public uint64 Data;
			public uint32 Size;
			public uint32 Flags;
			public uint32 TypeId;
			public uint32 BaseTypeId;
			public uint32 Tag;
			public uint32 Register;
			public uint64[9] Internal;
		}
		[CRepr]
		public struct EXT_TYPED_DATA
		{
			public EXT_TDOP Operation;
			public uint32 Flags;
			public DEBUG_TYPED_DATA InData;
			public DEBUG_TYPED_DATA OutData;
			public uint32 InStrIndex;
			public uint32 In32;
			public uint32 Out32;
			public uint64 In64;
			public uint64 Out64;
			public uint32 StrBufferIndex;
			public uint32 StrBufferChars;
			public uint32 StrCharsNeeded;
			public uint32 DataBufferIndex;
			public uint32 DataBufferBytes;
			public uint32 DataBytesNeeded;
			public HResult Status;
			public uint64[8] Reserved;
		}
		[CRepr]
		public struct WDBGEXTS_QUERY_INTERFACE
		{
			public Guid* Iid;
			public void* Iface;
		}
		[CRepr]
		public struct WDBGEXTS_DISASSEMBLE_BUFFER
		{
			public uint64 InOffset;
			public uint64 OutOffset;
			public uint32 AddrFlags;
			public uint32 FormatFlags;
			public uint32 DataBufferBytes;
			public uint32 DisasmBufferChars;
			public void* DataBuffer;
			public char16* DisasmBuffer;
			public uint64[3] Reserved0;
		}
		[CRepr]
		public struct WDBGEXTS_MODULE_IN_RANGE
		{
			public uint64 Start;
			public uint64 End;
			public uint64 FoundModBase;
			public uint32 FoundModSize;
		}
		[CRepr]
		public struct DBGKD_GET_VERSION32
		{
			public uint16 MajorVersion;
			public uint16 MinorVersion;
			public uint16 ProtocolVersion;
			public uint16 Flags;
			public uint32 KernBase;
			public uint32 PsLoadedModuleList;
			public uint16 MachineType;
			public uint16 ThCallbackStack;
			public uint16 NextCallback;
			public uint16 FramePointer;
			public uint32 KiCallUserMode;
			public uint32 KeUserCallbackDispatcher;
			public uint32 BreakpointWithStatus;
			public uint32 DebuggerDataList;
		}
		[CRepr]
		public struct DBGKD_DEBUG_DATA_HEADER32
		{
			public LIST_ENTRY32 List;
			public uint32 OwnerTag;
			public uint32 Size;
		}
		[CRepr]
		public struct KDDEBUGGER_DATA32
		{
			public DBGKD_DEBUG_DATA_HEADER32 Header;
			public uint32 KernBase;
			public uint32 BreakpointWithStatus;
			public uint32 SavedContext;
			public uint16 ThCallbackStack;
			public uint16 NextCallback;
			public uint16 FramePointer;
			public uint16 _bitfield;
			public uint32 KiCallUserMode;
			public uint32 KeUserCallbackDispatcher;
			public uint32 PsLoadedModuleList;
			public uint32 PsActiveProcessHead;
			public uint32 PspCidTable;
			public uint32 ExpSystemResourcesList;
			public uint32 ExpPagedPoolDescriptor;
			public uint32 ExpNumberOfPagedPools;
			public uint32 KeTimeIncrement;
			public uint32 KeBugCheckCallbackListHead;
			public uint32 KiBugcheckData;
			public uint32 IopErrorLogListHead;
			public uint32 ObpRootDirectoryObject;
			public uint32 ObpTypeObjectType;
			public uint32 MmSystemCacheStart;
			public uint32 MmSystemCacheEnd;
			public uint32 MmSystemCacheWs;
			public uint32 MmPfnDatabase;
			public uint32 MmSystemPtesStart;
			public uint32 MmSystemPtesEnd;
			public uint32 MmSubsectionBase;
			public uint32 MmNumberOfPagingFiles;
			public uint32 MmLowestPhysicalPage;
			public uint32 MmHighestPhysicalPage;
			public uint32 MmNumberOfPhysicalPages;
			public uint32 MmMaximumNonPagedPoolInBytes;
			public uint32 MmNonPagedSystemStart;
			public uint32 MmNonPagedPoolStart;
			public uint32 MmNonPagedPoolEnd;
			public uint32 MmPagedPoolStart;
			public uint32 MmPagedPoolEnd;
			public uint32 MmPagedPoolInformation;
			public uint32 MmPageSize;
			public uint32 MmSizeOfPagedPoolInBytes;
			public uint32 MmTotalCommitLimit;
			public uint32 MmTotalCommittedPages;
			public uint32 MmSharedCommit;
			public uint32 MmDriverCommit;
			public uint32 MmProcessCommit;
			public uint32 MmPagedPoolCommit;
			public uint32 MmExtendedCommit;
			public uint32 MmZeroedPageListHead;
			public uint32 MmFreePageListHead;
			public uint32 MmStandbyPageListHead;
			public uint32 MmModifiedPageListHead;
			public uint32 MmModifiedNoWritePageListHead;
			public uint32 MmAvailablePages;
			public uint32 MmResidentAvailablePages;
			public uint32 PoolTrackTable;
			public uint32 NonPagedPoolDescriptor;
			public uint32 MmHighestUserAddress;
			public uint32 MmSystemRangeStart;
			public uint32 MmUserProbeAddress;
			public uint32 KdPrintCircularBuffer;
			public uint32 KdPrintCircularBufferEnd;
			public uint32 KdPrintWritePointer;
			public uint32 KdPrintRolloverCount;
			public uint32 MmLoadedUserImageList;
		}
		[CRepr]
		public struct DBGKD_GET_VERSION64
		{
			public uint16 MajorVersion;
			public uint16 MinorVersion;
			public uint8 ProtocolVersion;
			public uint8 KdSecondaryVersion;
			public uint16 Flags;
			public uint16 MachineType;
			public uint8 MaxPacketType;
			public uint8 MaxStateChange;
			public uint8 MaxManipulate;
			public uint8 Simulation;
			public uint16[0] Unused;
			public uint64 KernBase;
			public uint64 PsLoadedModuleList;
			public uint64 DebuggerDataList;
		}
		[CRepr]
		public struct DBGKD_DEBUG_DATA_HEADER64
		{
			public LIST_ENTRY64 List;
			public uint32 OwnerTag;
			public uint32 Size;
		}
		[CRepr]
		public struct KDDEBUGGER_DATA64
		{
			public DBGKD_DEBUG_DATA_HEADER64 Header;
			public uint64 KernBase;
			public uint64 BreakpointWithStatus;
			public uint64 SavedContext;
			public uint16 ThCallbackStack;
			public uint16 NextCallback;
			public uint16 FramePointer;
			public uint16 _bitfield;
			public uint64 KiCallUserMode;
			public uint64 KeUserCallbackDispatcher;
			public uint64 PsLoadedModuleList;
			public uint64 PsActiveProcessHead;
			public uint64 PspCidTable;
			public uint64 ExpSystemResourcesList;
			public uint64 ExpPagedPoolDescriptor;
			public uint64 ExpNumberOfPagedPools;
			public uint64 KeTimeIncrement;
			public uint64 KeBugCheckCallbackListHead;
			public uint64 KiBugcheckData;
			public uint64 IopErrorLogListHead;
			public uint64 ObpRootDirectoryObject;
			public uint64 ObpTypeObjectType;
			public uint64 MmSystemCacheStart;
			public uint64 MmSystemCacheEnd;
			public uint64 MmSystemCacheWs;
			public uint64 MmPfnDatabase;
			public uint64 MmSystemPtesStart;
			public uint64 MmSystemPtesEnd;
			public uint64 MmSubsectionBase;
			public uint64 MmNumberOfPagingFiles;
			public uint64 MmLowestPhysicalPage;
			public uint64 MmHighestPhysicalPage;
			public uint64 MmNumberOfPhysicalPages;
			public uint64 MmMaximumNonPagedPoolInBytes;
			public uint64 MmNonPagedSystemStart;
			public uint64 MmNonPagedPoolStart;
			public uint64 MmNonPagedPoolEnd;
			public uint64 MmPagedPoolStart;
			public uint64 MmPagedPoolEnd;
			public uint64 MmPagedPoolInformation;
			public uint64 MmPageSize;
			public uint64 MmSizeOfPagedPoolInBytes;
			public uint64 MmTotalCommitLimit;
			public uint64 MmTotalCommittedPages;
			public uint64 MmSharedCommit;
			public uint64 MmDriverCommit;
			public uint64 MmProcessCommit;
			public uint64 MmPagedPoolCommit;
			public uint64 MmExtendedCommit;
			public uint64 MmZeroedPageListHead;
			public uint64 MmFreePageListHead;
			public uint64 MmStandbyPageListHead;
			public uint64 MmModifiedPageListHead;
			public uint64 MmModifiedNoWritePageListHead;
			public uint64 MmAvailablePages;
			public uint64 MmResidentAvailablePages;
			public uint64 PoolTrackTable;
			public uint64 NonPagedPoolDescriptor;
			public uint64 MmHighestUserAddress;
			public uint64 MmSystemRangeStart;
			public uint64 MmUserProbeAddress;
			public uint64 KdPrintCircularBuffer;
			public uint64 KdPrintCircularBufferEnd;
			public uint64 KdPrintWritePointer;
			public uint64 KdPrintRolloverCount;
			public uint64 MmLoadedUserImageList;
			public uint64 NtBuildLab;
			public uint64 KiNormalSystemCall;
			public uint64 KiProcessorBlock;
			public uint64 MmUnloadedDrivers;
			public uint64 MmLastUnloadedDriver;
			public uint64 MmTriageActionTaken;
			public uint64 MmSpecialPoolTag;
			public uint64 KernelVerifier;
			public uint64 MmVerifierData;
			public uint64 MmAllocatedNonPagedPool;
			public uint64 MmPeakCommitment;
			public uint64 MmTotalCommitLimitMaximum;
			public uint64 CmNtCSDVersion;
			public uint64 MmPhysicalMemoryBlock;
			public uint64 MmSessionBase;
			public uint64 MmSessionSize;
			public uint64 MmSystemParentTablePage;
			public uint64 MmVirtualTranslationBase;
			public uint16 OffsetKThreadNextProcessor;
			public uint16 OffsetKThreadTeb;
			public uint16 OffsetKThreadKernelStack;
			public uint16 OffsetKThreadInitialStack;
			public uint16 OffsetKThreadApcProcess;
			public uint16 OffsetKThreadState;
			public uint16 OffsetKThreadBStore;
			public uint16 OffsetKThreadBStoreLimit;
			public uint16 SizeEProcess;
			public uint16 OffsetEprocessPeb;
			public uint16 OffsetEprocessParentCID;
			public uint16 OffsetEprocessDirectoryTableBase;
			public uint16 SizePrcb;
			public uint16 OffsetPrcbDpcRoutine;
			public uint16 OffsetPrcbCurrentThread;
			public uint16 OffsetPrcbMhz;
			public uint16 OffsetPrcbCpuType;
			public uint16 OffsetPrcbVendorString;
			public uint16 OffsetPrcbProcStateContext;
			public uint16 OffsetPrcbNumber;
			public uint16 SizeEThread;
			public uint8 L1tfHighPhysicalBitIndex;
			public uint8 L1tfSwizzleBitIndex;
			public uint32 Padding0;
			public uint64 KdPrintCircularBufferPtr;
			public uint64 KdPrintBufferSize;
			public uint64 KeLoaderBlock;
			public uint16 SizePcr;
			public uint16 OffsetPcrSelfPcr;
			public uint16 OffsetPcrCurrentPrcb;
			public uint16 OffsetPcrContainedPrcb;
			public uint16 OffsetPcrInitialBStore;
			public uint16 OffsetPcrBStoreLimit;
			public uint16 OffsetPcrInitialStack;
			public uint16 OffsetPcrStackLimit;
			public uint16 OffsetPrcbPcrPage;
			public uint16 OffsetPrcbProcStateSpecialReg;
			public uint16 GdtR0Code;
			public uint16 GdtR0Data;
			public uint16 GdtR0Pcr;
			public uint16 GdtR3Code;
			public uint16 GdtR3Data;
			public uint16 GdtR3Teb;
			public uint16 GdtLdt;
			public uint16 GdtTss;
			public uint16 Gdt64R3CmCode;
			public uint16 Gdt64R3CmTeb;
			public uint64 IopNumTriageDumpDataBlocks;
			public uint64 IopTriageDumpDataBlocks;
			public uint64 VfCrashDataBlock;
			public uint64 MmBadPagesDetected;
			public uint64 MmZeroedPageSingleBitErrorsDetected;
			public uint64 EtwpDebuggerData;
			public uint16 OffsetPrcbContext;
			public uint16 OffsetPrcbMaxBreakpoints;
			public uint16 OffsetPrcbMaxWatchpoints;
			public uint32 OffsetKThreadStackLimit;
			public uint32 OffsetKThreadStackBase;
			public uint32 OffsetKThreadQueueListEntry;
			public uint32 OffsetEThreadIrpList;
			public uint16 OffsetPrcbIdleThread;
			public uint16 OffsetPrcbNormalDpcState;
			public uint16 OffsetPrcbDpcStack;
			public uint16 OffsetPrcbIsrStack;
			public uint16 SizeKDPC_STACK_FRAME;
			public uint16 OffsetKPriQueueThreadListHead;
			public uint16 OffsetKThreadWaitReason;
			public uint16 Padding1;
			public uint64 PteBase;
			public uint64 RetpolineStubFunctionTable;
			public uint32 RetpolineStubFunctionTableSize;
			public uint32 RetpolineStubOffset;
			public uint32 RetpolineStubSize;
			public uint16 OffsetEProcessMmHotPatchContext;
		}
		[CRepr]
		public struct FIELD_INFO
		{
			public uint8* fName;
			public uint8* printName;
			public uint32 size;
			public uint32 fOptions;
			public uint64 address;
			public _Anonymous_e__Union Anonymous;
			public uint32 TypeId;
			public uint32 FieldOffset;
			public uint32 BufferSize;
			public _BitField BitField;
			public uint32 _bitfield;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public void* fieldCallBack;
				public void* pBuffer;
			}
			[CRepr]
			public struct _BitField
			{
				public uint16 Position;
				public uint16 Size;
			}
		}
		[CRepr]
		public struct SYM_DUMP_PARAM
		{
			public uint32 size;
			public uint8* sName;
			public uint32 Options;
			public uint64 addr;
			public FIELD_INFO* listLink;
			public _Anonymous_e__Union Anonymous;
			public PSYM_DUMP_FIELD_CALLBACK CallbackRoutine;
			public uint32 nFields;
			public FIELD_INFO* Fields;
			public uint64 ModBase;
			public uint32 TypeId;
			public uint32 TypeSize;
			public uint32 BufferSize;
			public uint32 _bitfield;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public void* Context;
				public void* pBuffer;
			}
		}
		[CRepr]
		public struct M128A
		{
			public uint64 Low;
			public int64 High;
		}
		[CRepr]
		public struct XSAVE_FORMAT
		{
			public uint16 ControlWord;
			public uint16 StatusWord;
			public uint8 TagWord;
			public uint8 Reserved1;
			public uint16 ErrorOpcode;
			public uint32 ErrorOffset;
			public uint16 ErrorSelector;
			public uint16 Reserved2;
			public uint32 DataOffset;
			public uint16 DataSelector;
			public uint16 Reserved3;
			public uint32 MxCsr;
			public uint32 MxCsr_Mask;
			public M128A[8] FloatRegisters;
			public M128A[16] XmmRegisters;
			public uint8[96] Reserved4;
		}
		[CRepr]
		public struct XSAVE_AREA_HEADER
		{
			public uint64 Mask;
			public uint64 CompactionMask;
			public uint64[6] Reserved2;
		}
		[CRepr]
		public struct XSAVE_AREA
		{
			public XSAVE_FORMAT LegacyState;
			public XSAVE_AREA_HEADER Header;
		}
		[CRepr]
		public struct XSTATE_CONTEXT
		{
			public uint64 Mask;
			public uint32 Length;
			public uint32 Reserved1;
			public XSAVE_AREA* Area;
			public void* Buffer;
		}
		[CRepr]
		public struct KNONVOLATILE_CONTEXT_POINTERS
		{
			public _Anonymous1_e__Union Anonymous1;
			public _Anonymous2_e__Union Anonymous2;
			
			[CRepr, Union]
			public struct _Anonymous2_e__Union
			{
				public uint64*[16] IntegerContext;
				public _Anonymous_e__Struct Anonymous;
				
				[CRepr]
				public struct _Anonymous_e__Struct
				{
					public uint64* Rax;
					public uint64* Rcx;
					public uint64* Rdx;
					public uint64* Rbx;
					public uint64* Rsp;
					public uint64* Rbp;
					public uint64* Rsi;
					public uint64* Rdi;
					public uint64* R8;
					public uint64* R9;
					public uint64* R10;
					public uint64* R11;
					public uint64* R12;
					public uint64* R13;
					public uint64* R14;
					public uint64* R15;
				}
			}
			[CRepr, Union]
			public struct _Anonymous1_e__Union
			{
				public M128A*[16] FloatingContext;
				public _Anonymous_e__Struct Anonymous;
				
				[CRepr]
				public struct _Anonymous_e__Struct
				{
					public M128A* Xmm0;
					public M128A* Xmm1;
					public M128A* Xmm2;
					public M128A* Xmm3;
					public M128A* Xmm4;
					public M128A* Xmm5;
					public M128A* Xmm6;
					public M128A* Xmm7;
					public M128A* Xmm8;
					public M128A* Xmm9;
					public M128A* Xmm10;
					public M128A* Xmm11;
					public M128A* Xmm12;
					public M128A* Xmm13;
					public M128A* Xmm14;
					public M128A* Xmm15;
				}
			}
		}
		[CRepr, Union]
		public struct ARM64_NT_NEON128
		{
			public _Anonymous_e__Struct Anonymous;
			public double[2] D;
			public float[4] S;
			public uint16[8] H;
			public uint8[16] B;
			
			[CRepr]
			public struct _Anonymous_e__Struct
			{
				public uint64 Low;
				public int64 High;
			}
		}
		[CRepr]
		public struct ARM64_NT_CONTEXT
		{
			public uint32 ContextFlags;
			public uint32 Cpsr;
			public _Anonymous_e__Union Anonymous;
			public uint64 Sp;
			public uint64 Pc;
			public ARM64_NT_NEON128[32] V;
			public uint32 Fpcr;
			public uint32 Fpsr;
			public uint32[8] Bcr;
			public uint64[8] Bvr;
			public uint32[2] Wcr;
			public uint64[2] Wvr;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public _Anonymous_e__Struct Anonymous;
				public uint64[31] X;
				
				[CRepr]
				public struct _Anonymous_e__Struct
				{
					public uint64 X0;
					public uint64 X1;
					public uint64 X2;
					public uint64 X3;
					public uint64 X4;
					public uint64 X5;
					public uint64 X6;
					public uint64 X7;
					public uint64 X8;
					public uint64 X9;
					public uint64 X10;
					public uint64 X11;
					public uint64 X12;
					public uint64 X13;
					public uint64 X14;
					public uint64 X15;
					public uint64 X16;
					public uint64 X17;
					public uint64 X18;
					public uint64 X19;
					public uint64 X20;
					public uint64 X21;
					public uint64 X22;
					public uint64 X23;
					public uint64 X24;
					public uint64 X25;
					public uint64 X26;
					public uint64 X27;
					public uint64 X28;
					public uint64 Fp;
					public uint64 Lr;
				}
			}
		}
		[CRepr]
		public struct DISPATCHER_CONTEXT_ARM64
		{
			public uint ControlPc;
			public uint ImageBase;
			public IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* FunctionEntry;
			public uint EstablisherFrame;
			public uint TargetPc;
			public ARM64_NT_CONTEXT* ContextRecord;
			public EXCEPTION_ROUTINE LanguageHandler;
			public void* HandlerData;
			public UNWIND_HISTORY_TABLE* HistoryTable;
			public uint32 ScopeIndex;
			public bool ControlPcIsUnwound;
			public uint8* NonVolatileRegisters;
		}
		[CRepr]
		public struct LDT_ENTRY
		{
			public uint16 LimitLow;
			public uint16 BaseLow;
			public _HighWord_e__Union HighWord;
			
			[CRepr, Union]
			public struct _HighWord_e__Union
			{
				public _Bytes_e__Struct Bytes;
				public _Bits_e__Struct Bits;
				
				[CRepr]
				public struct _Bytes_e__Struct
				{
					public uint8 BaseMid;
					public uint8 Flags1;
					public uint8 Flags2;
					public uint8 BaseHi;
				}
				[CRepr]
				public struct _Bits_e__Struct
				{
					public uint32 _bitfield;
				}
			}
		}
		[CRepr]
		public struct WOW64_FLOATING_SAVE_AREA
		{
			public uint32 ControlWord;
			public uint32 StatusWord;
			public uint32 TagWord;
			public uint32 ErrorOffset;
			public uint32 ErrorSelector;
			public uint32 DataOffset;
			public uint32 DataSelector;
			public uint8[80] RegisterArea;
			public uint32 Cr0NpxState;
		}
		[CRepr]
		public struct WOW64_CONTEXT
		{
			public uint32 ContextFlags;
			public uint32 Dr0;
			public uint32 Dr1;
			public uint32 Dr2;
			public uint32 Dr3;
			public uint32 Dr6;
			public uint32 Dr7;
			public WOW64_FLOATING_SAVE_AREA FloatSave;
			public uint32 SegGs;
			public uint32 SegFs;
			public uint32 SegEs;
			public uint32 SegDs;
			public uint32 Edi;
			public uint32 Esi;
			public uint32 Ebx;
			public uint32 Edx;
			public uint32 Ecx;
			public uint32 Eax;
			public uint32 Ebp;
			public uint32 Eip;
			public uint32 SegCs;
			public uint32 EFlags;
			public uint32 Esp;
			public uint32 SegSs;
			public uint8[512] ExtendedRegisters;
		}
		[CRepr]
		public struct WOW64_LDT_ENTRY
		{
			public uint16 LimitLow;
			public uint16 BaseLow;
			public _HighWord_e__Union HighWord;
			
			[CRepr, Union]
			public struct _HighWord_e__Union
			{
				public _Bytes_e__Struct Bytes;
				public _Bits_e__Struct Bits;
				
				[CRepr]
				public struct _Bytes_e__Struct
				{
					public uint8 BaseMid;
					public uint8 Flags1;
					public uint8 Flags2;
					public uint8 BaseHi;
				}
				[CRepr]
				public struct _Bits_e__Struct
				{
					public uint32 _bitfield;
				}
			}
		}
		[CRepr]
		public struct WOW64_DESCRIPTOR_TABLE_ENTRY
		{
			public uint32 Selector;
			public WOW64_LDT_ENTRY Descriptor;
		}
		[CRepr]
		public struct EXCEPTION_RECORD
		{
			public NTSTATUS ExceptionCode;
			public uint32 ExceptionFlags;
			public EXCEPTION_RECORD* ExceptionRecord;
			public void* ExceptionAddress;
			public uint32 NumberParameters;
			public uint[15] ExceptionInformation;
		}
		[CRepr]
		public struct EXCEPTION_RECORD32
		{
			public NTSTATUS ExceptionCode;
			public uint32 ExceptionFlags;
			public uint32 ExceptionRecord;
			public uint32 ExceptionAddress;
			public uint32 NumberParameters;
			public uint32[15] ExceptionInformation;
		}
		[CRepr]
		public struct EXCEPTION_RECORD64
		{
			public NTSTATUS ExceptionCode;
			public uint32 ExceptionFlags;
			public uint64 ExceptionRecord;
			public uint64 ExceptionAddress;
			public uint32 NumberParameters;
			public uint32 __unusedAlignment;
			public uint64[15] ExceptionInformation;
		}
		[CRepr]
		public struct EXCEPTION_POINTERS
		{
			public EXCEPTION_RECORD* ExceptionRecord;
			public CONTEXT* ContextRecord;
		}
		[CRepr]
		public struct XSTATE_FEATURE
		{
			public uint32 Offset;
			public uint32 Size;
		}
		[CRepr]
		public struct XSTATE_CONFIGURATION
		{
			public uint64 EnabledFeatures;
			public uint64 EnabledVolatileFeatures;
			public uint32 Size;
			public _Anonymous_e__Union Anonymous;
			public XSTATE_FEATURE[64] Features;
			public uint64 EnabledSupervisorFeatures;
			public uint64 AlignedFeatures;
			public uint32 AllFeatureSize;
			public uint32[64] AllFeatures;
			public uint64 EnabledUserVisibleSupervisorFeatures;
			public uint64 ExtendedFeatureDisableFeatures;
			public uint32 AllNonLargeFeatureSize;
			public uint32 Spare;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public uint32 ControlFlags;
				public _Anonymous_e__Struct Anonymous;
				
				[CRepr]
				public struct _Anonymous_e__Struct
				{
					public uint32 _bitfield;
				}
			}
		}
		[CRepr]
		public struct IMAGE_FILE_HEADER
		{
			public IMAGE_FILE_MACHINE Machine;
			public uint16 NumberOfSections;
			public uint32 TimeDateStamp;
			public uint32 PointerToSymbolTable;
			public uint32 NumberOfSymbols;
			public uint16 SizeOfOptionalHeader;
			public IMAGE_FILE_CHARACTERISTICS Characteristics;
		}
		[CRepr]
		public struct IMAGE_DATA_DIRECTORY
		{
			public uint32 VirtualAddress;
			public uint32 Size;
		}
		[CRepr]
		public struct IMAGE_OPTIONAL_HEADER32
		{
			public IMAGE_OPTIONAL_HEADER_MAGIC Magic;
			public uint8 MajorLinkerVersion;
			public uint8 MinorLinkerVersion;
			public uint32 SizeOfCode;
			public uint32 SizeOfInitializedData;
			public uint32 SizeOfUninitializedData;
			public uint32 AddressOfEntryPoint;
			public uint32 BaseOfCode;
			public uint32 BaseOfData;
			public uint32 ImageBase;
			public uint32 SectionAlignment;
			public uint32 FileAlignment;
			public uint16 MajorOperatingSystemVersion;
			public uint16 MinorOperatingSystemVersion;
			public uint16 MajorImageVersion;
			public uint16 MinorImageVersion;
			public uint16 MajorSubsystemVersion;
			public uint16 MinorSubsystemVersion;
			public uint32 Win32VersionValue;
			public uint32 SizeOfImage;
			public uint32 SizeOfHeaders;
			public uint32 CheckSum;
			public IMAGE_SUBSYSTEM Subsystem;
			public IMAGE_DLL_CHARACTERISTICS DllCharacteristics;
			public uint32 SizeOfStackReserve;
			public uint32 SizeOfStackCommit;
			public uint32 SizeOfHeapReserve;
			public uint32 SizeOfHeapCommit;
			public uint32 LoaderFlags;
			public uint32 NumberOfRvaAndSizes;
			public IMAGE_DATA_DIRECTORY[16] DataDirectory;
		}
		[CRepr]
		public struct IMAGE_ROM_OPTIONAL_HEADER
		{
			public uint16 Magic;
			public uint8 MajorLinkerVersion;
			public uint8 MinorLinkerVersion;
			public uint32 SizeOfCode;
			public uint32 SizeOfInitializedData;
			public uint32 SizeOfUninitializedData;
			public uint32 AddressOfEntryPoint;
			public uint32 BaseOfCode;
			public uint32 BaseOfData;
			public uint32 BaseOfBss;
			public uint32 GprMask;
			public uint32[4] CprMask;
			public uint32 GpValue;
		}
		[CRepr, Packed(4)]
		public struct IMAGE_OPTIONAL_HEADER64
		{
			public IMAGE_OPTIONAL_HEADER_MAGIC Magic;
			public uint8 MajorLinkerVersion;
			public uint8 MinorLinkerVersion;
			public uint32 SizeOfCode;
			public uint32 SizeOfInitializedData;
			public uint32 SizeOfUninitializedData;
			public uint32 AddressOfEntryPoint;
			public uint32 BaseOfCode;
			public uint64 ImageBase;
			public uint32 SectionAlignment;
			public uint32 FileAlignment;
			public uint16 MajorOperatingSystemVersion;
			public uint16 MinorOperatingSystemVersion;
			public uint16 MajorImageVersion;
			public uint16 MinorImageVersion;
			public uint16 MajorSubsystemVersion;
			public uint16 MinorSubsystemVersion;
			public uint32 Win32VersionValue;
			public uint32 SizeOfImage;
			public uint32 SizeOfHeaders;
			public uint32 CheckSum;
			public IMAGE_SUBSYSTEM Subsystem;
			public IMAGE_DLL_CHARACTERISTICS DllCharacteristics;
			public uint64 SizeOfStackReserve;
			public uint64 SizeOfStackCommit;
			public uint64 SizeOfHeapReserve;
			public uint64 SizeOfHeapCommit;
			public uint32 LoaderFlags;
			public uint32 NumberOfRvaAndSizes;
			public IMAGE_DATA_DIRECTORY[16] DataDirectory;
		}
		[CRepr]
		public struct IMAGE_NT_HEADERS64
		{
			public uint32 Signature;
			public IMAGE_FILE_HEADER FileHeader;
			public IMAGE_OPTIONAL_HEADER64 OptionalHeader;
		}
		[CRepr]
		public struct IMAGE_NT_HEADERS32
		{
			public uint32 Signature;
			public IMAGE_FILE_HEADER FileHeader;
			public IMAGE_OPTIONAL_HEADER32 OptionalHeader;
		}
		[CRepr]
		public struct IMAGE_ROM_HEADERS
		{
			public IMAGE_FILE_HEADER FileHeader;
			public IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
		}
		[CRepr]
		public struct IMAGE_SECTION_HEADER
		{
			public uint8[8] Name;
			public _Misc_e__Union Misc;
			public uint32 VirtualAddress;
			public uint32 SizeOfRawData;
			public uint32 PointerToRawData;
			public uint32 PointerToRelocations;
			public uint32 PointerToLinenumbers;
			public uint16 NumberOfRelocations;
			public uint16 NumberOfLinenumbers;
			public IMAGE_SECTION_CHARACTERISTICS Characteristics;
			
			[CRepr, Union]
			public struct _Misc_e__Union
			{
				public uint32 PhysicalAddress;
				public uint32 VirtualSize;
			}
		}
		[CRepr]
		public struct IMAGE_LOAD_CONFIG_CODE_INTEGRITY
		{
			public uint16 Flags;
			public uint16 Catalog;
			public uint32 CatalogOffset;
			public uint32 Reserved;
		}
		[CRepr]
		public struct IMAGE_LOAD_CONFIG_DIRECTORY32
		{
			public uint32 Size;
			public uint32 TimeDateStamp;
			public uint16 MajorVersion;
			public uint16 MinorVersion;
			public uint32 GlobalFlagsClear;
			public uint32 GlobalFlagsSet;
			public uint32 CriticalSectionDefaultTimeout;
			public uint32 DeCommitFreeBlockThreshold;
			public uint32 DeCommitTotalFreeThreshold;
			public uint32 LockPrefixTable;
			public uint32 MaximumAllocationSize;
			public uint32 VirtualMemoryThreshold;
			public uint32 ProcessHeapFlags;
			public uint32 ProcessAffinityMask;
			public uint16 CSDVersion;
			public uint16 DependentLoadFlags;
			public uint32 EditList;
			public uint32 SecurityCookie;
			public uint32 SEHandlerTable;
			public uint32 SEHandlerCount;
			public uint32 GuardCFCheckFunctionPointer;
			public uint32 GuardCFDispatchFunctionPointer;
			public uint32 GuardCFFunctionTable;
			public uint32 GuardCFFunctionCount;
			public uint32 GuardFlags;
			public IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
			public uint32 GuardAddressTakenIatEntryTable;
			public uint32 GuardAddressTakenIatEntryCount;
			public uint32 GuardLongJumpTargetTable;
			public uint32 GuardLongJumpTargetCount;
			public uint32 DynamicValueRelocTable;
			public uint32 CHPEMetadataPointer;
			public uint32 GuardRFFailureRoutine;
			public uint32 GuardRFFailureRoutineFunctionPointer;
			public uint32 DynamicValueRelocTableOffset;
			public uint16 DynamicValueRelocTableSection;
			public uint16 Reserved2;
			public uint32 GuardRFVerifyStackPointerFunctionPointer;
			public uint32 HotPatchTableOffset;
			public uint32 Reserved3;
			public uint32 EnclaveConfigurationPointer;
			public uint32 VolatileMetadataPointer;
			public uint32 GuardEHContinuationTable;
			public uint32 GuardEHContinuationCount;
			public uint32 GuardXFGCheckFunctionPointer;
			public uint32 GuardXFGDispatchFunctionPointer;
			public uint32 GuardXFGTableDispatchFunctionPointer;
			public uint32 CastGuardOsDeterminedFailureMode;
		}
		[CRepr, Packed(4)]
		public struct IMAGE_LOAD_CONFIG_DIRECTORY64
		{
			public uint32 Size;
			public uint32 TimeDateStamp;
			public uint16 MajorVersion;
			public uint16 MinorVersion;
			public uint32 GlobalFlagsClear;
			public uint32 GlobalFlagsSet;
			public uint32 CriticalSectionDefaultTimeout;
			public uint64 DeCommitFreeBlockThreshold;
			public uint64 DeCommitTotalFreeThreshold;
			public uint64 LockPrefixTable;
			public uint64 MaximumAllocationSize;
			public uint64 VirtualMemoryThreshold;
			public uint64 ProcessAffinityMask;
			public uint32 ProcessHeapFlags;
			public uint16 CSDVersion;
			public uint16 DependentLoadFlags;
			public uint64 EditList;
			public uint64 SecurityCookie;
			public uint64 SEHandlerTable;
			public uint64 SEHandlerCount;
			public uint64 GuardCFCheckFunctionPointer;
			public uint64 GuardCFDispatchFunctionPointer;
			public uint64 GuardCFFunctionTable;
			public uint64 GuardCFFunctionCount;
			public uint32 GuardFlags;
			public IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
			public uint64 GuardAddressTakenIatEntryTable;
			public uint64 GuardAddressTakenIatEntryCount;
			public uint64 GuardLongJumpTargetTable;
			public uint64 GuardLongJumpTargetCount;
			public uint64 DynamicValueRelocTable;
			public uint64 CHPEMetadataPointer;
			public uint64 GuardRFFailureRoutine;
			public uint64 GuardRFFailureRoutineFunctionPointer;
			public uint32 DynamicValueRelocTableOffset;
			public uint16 DynamicValueRelocTableSection;
			public uint16 Reserved2;
			public uint64 GuardRFVerifyStackPointerFunctionPointer;
			public uint32 HotPatchTableOffset;
			public uint32 Reserved3;
			public uint64 EnclaveConfigurationPointer;
			public uint64 VolatileMetadataPointer;
			public uint64 GuardEHContinuationTable;
			public uint64 GuardEHContinuationCount;
			public uint64 GuardXFGCheckFunctionPointer;
			public uint64 GuardXFGDispatchFunctionPointer;
			public uint64 GuardXFGTableDispatchFunctionPointer;
			public uint64 CastGuardOsDeterminedFailureMode;
		}
		[CRepr]
		public struct IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
		{
			public uint32 BeginAddress;
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public uint32 UnwindData;
				public _Anonymous_e__Struct Anonymous;
				
				[CRepr]
				public struct _Anonymous_e__Struct
				{
					public uint32 _bitfield;
				}
			}
		}
		[CRepr]
		public struct IMAGE_RUNTIME_FUNCTION_ENTRY
		{
			public uint32 BeginAddress;
			public uint32 EndAddress;
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public uint32 UnwindInfoAddress;
				public uint32 UnwindData;
			}
		}
		[CRepr]
		public struct IMAGE_DEBUG_DIRECTORY
		{
			public uint32 Characteristics;
			public uint32 TimeDateStamp;
			public uint16 MajorVersion;
			public uint16 MinorVersion;
			public IMAGE_DEBUG_TYPE Type;
			public uint32 SizeOfData;
			public uint32 AddressOfRawData;
			public uint32 PointerToRawData;
		}
		[CRepr]
		public struct IMAGE_COFF_SYMBOLS_HEADER
		{
			public uint32 NumberOfSymbols;
			public uint32 LvaToFirstSymbol;
			public uint32 NumberOfLinenumbers;
			public uint32 LvaToFirstLinenumber;
			public uint32 RvaToFirstByteOfCode;
			public uint32 RvaToLastByteOfCode;
			public uint32 RvaToFirstByteOfData;
			public uint32 RvaToLastByteOfData;
		}
		[CRepr]
		public struct FPO_DATA
		{
			public uint32 ulOffStart;
			public uint32 cbProcSize;
			public uint32 cdwLocals;
			public uint16 cdwParams;
			public uint16 _bitfield;
		}
		[CRepr]
		public struct IMAGE_FUNCTION_ENTRY
		{
			public uint32 StartingAddress;
			public uint32 EndingAddress;
			public uint32 EndOfPrologue;
		}
		[CRepr, Packed(4)]
		public struct IMAGE_FUNCTION_ENTRY64
		{
			public uint64 StartingAddress;
			public uint64 EndingAddress;
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union, Packed(4)]
			public struct _Anonymous_e__Union
			{
				public uint64 EndOfPrologue;
				public uint64 UnwindInfoAddress;
			}
		}
		[CRepr]
		public struct IMAGE_COR20_HEADER
		{
			public uint32 cb;
			public uint16 MajorRuntimeVersion;
			public uint16 MinorRuntimeVersion;
			public IMAGE_DATA_DIRECTORY MetaData;
			public uint32 Flags;
			public _Anonymous_e__Union Anonymous;
			public IMAGE_DATA_DIRECTORY Resources;
			public IMAGE_DATA_DIRECTORY StrongNameSignature;
			public IMAGE_DATA_DIRECTORY CodeManagerTable;
			public IMAGE_DATA_DIRECTORY VTableFixups;
			public IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
			public IMAGE_DATA_DIRECTORY ManagedNativeHeader;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public uint32 EntryPointToken;
				public uint32 EntryPointRVA;
			}
		}
		[CRepr]
		public struct UNWIND_HISTORY_TABLE
		{
			public uint32 Count;
			public uint8 LocalHint;
			public uint8 GlobalHint;
			public uint8 Search;
			public uint8 Once;
			public uint LowAddress;
			public uint HighAddress;
			public UNWIND_HISTORY_TABLE_ENTRY[12] Entry;
		}
		[CRepr]
		public struct WAITCHAIN_NODE_INFO
		{
			public WCT_OBJECT_TYPE ObjectType;
			public WCT_OBJECT_STATUS ObjectStatus;
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public _LockObject_e__Struct LockObject;
				public _ThreadObject_e__Struct ThreadObject;
				
				[CRepr]
				public struct _LockObject_e__Struct
				{
					public char16[128] ObjectName;
					public LARGE_INTEGER Timeout;
					public IntBool Alertable;
				}
				[CRepr]
				public struct _ThreadObject_e__Struct
				{
					public uint32 ProcessId;
					public uint32 ThreadId;
					public uint32 WaitTime;
					public uint32 ContextSwitches;
				}
			}
		}
		[CRepr]
		public struct MINIDUMP_LOCATION_DESCRIPTOR
		{
			public uint32 DataSize;
			public uint32 Rva;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_LOCATION_DESCRIPTOR64
		{
			public uint64 DataSize;
			public uint64 Rva;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_MEMORY_DESCRIPTOR
		{
			public uint64 StartOfMemoryRange;
			public MINIDUMP_LOCATION_DESCRIPTOR Memory;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_MEMORY_DESCRIPTOR64
		{
			public uint64 StartOfMemoryRange;
			public uint64 DataSize;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_HEADER
		{
			public uint32 Signature;
			public uint32 Version;
			public uint32 NumberOfStreams;
			public uint32 StreamDirectoryRva;
			public uint32 CheckSum;
			public _Anonymous_e__Union Anonymous;
			public uint64 Flags;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public uint32 Reserved;
				public uint32 TimeDateStamp;
			}
		}
		[CRepr]
		public struct MINIDUMP_DIRECTORY
		{
			public uint32 StreamType;
			public MINIDUMP_LOCATION_DESCRIPTOR Location;
		}
		[CRepr]
		public struct MINIDUMP_STRING
		{
			public uint32 Length;
			public char16[0] Buffer;
		}
		[CRepr, Union]
		public struct CPU_INFORMATION
		{
			public _X86CpuInfo_e__Struct X86CpuInfo;
			public _OtherCpuInfo_e__Struct OtherCpuInfo;
			
			[CRepr]
			public struct _X86CpuInfo_e__Struct
			{
				public uint32[3] VendorId;
				public uint32 VersionInformation;
				public uint32 FeatureInformation;
				public uint32 AMDExtendedCpuFeatures;
			}
			[CRepr, Packed(4)]
			public struct _OtherCpuInfo_e__Struct
			{
				public uint64[2] ProcessorFeatures;
			}
		}
		[CRepr]
		public struct MINIDUMP_SYSTEM_INFO
		{
			public PROCESSOR_ARCHITECTURE ProcessorArchitecture;
			public uint16 ProcessorLevel;
			public uint16 ProcessorRevision;
			public _Anonymous1_e__Union Anonymous1;
			public uint32 MajorVersion;
			public uint32 MinorVersion;
			public uint32 BuildNumber;
			public VER_PLATFORM PlatformId;
			public uint32 CSDVersionRva;
			public _Anonymous2_e__Union Anonymous2;
			public CPU_INFORMATION Cpu;
			
			[CRepr, Union]
			public struct _Anonymous2_e__Union
			{
				public uint32 Reserved1;
				public _Anonymous_e__Struct Anonymous;
				
				[CRepr]
				public struct _Anonymous_e__Struct
				{
					public uint16 SuiteMask;
					public uint16 Reserved2;
				}
			}
			[CRepr, Union]
			public struct _Anonymous1_e__Union
			{
				public uint16 Reserved0;
				public _Anonymous_e__Struct Anonymous;
				
				[CRepr]
				public struct _Anonymous_e__Struct
				{
					public uint8 NumberOfProcessors;
					public uint8 ProductType;
				}
			}
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_THREAD
		{
			public uint32 ThreadId;
			public uint32 SuspendCount;
			public uint32 PriorityClass;
			public uint32 Priority;
			public uint64 Teb;
			public MINIDUMP_MEMORY_DESCRIPTOR Stack;
			public MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
		}
		[CRepr]
		public struct MINIDUMP_THREAD_LIST
		{
			public uint32 NumberOfThreads;
			public MINIDUMP_THREAD[0] Threads;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_THREAD_EX
		{
			public uint32 ThreadId;
			public uint32 SuspendCount;
			public uint32 PriorityClass;
			public uint32 Priority;
			public uint64 Teb;
			public MINIDUMP_MEMORY_DESCRIPTOR Stack;
			public MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
			public MINIDUMP_MEMORY_DESCRIPTOR BackingStore;
		}
		[CRepr]
		public struct MINIDUMP_THREAD_EX_LIST
		{
			public uint32 NumberOfThreads;
			public MINIDUMP_THREAD_EX[0] Threads;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_EXCEPTION
		{
			public uint32 ExceptionCode;
			public uint32 ExceptionFlags;
			public uint64 ExceptionRecord;
			public uint64 ExceptionAddress;
			public uint32 NumberParameters;
			public uint32 __unusedAlignment;
			public uint64[15] ExceptionInformation;
		}
		[CRepr]
		public struct MINIDUMP_EXCEPTION_STREAM
		{
			public uint32 ThreadId;
			public uint32 __alignment;
			public MINIDUMP_EXCEPTION ExceptionRecord;
			public MINIDUMP_LOCATION_DESCRIPTOR ThreadContext;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_MODULE
		{
			public uint64 BaseOfImage;
			public uint32 SizeOfImage;
			public uint32 CheckSum;
			public uint32 TimeDateStamp;
			public uint32 ModuleNameRva;
			public VS_FIXEDFILEINFO VersionInfo;
			public MINIDUMP_LOCATION_DESCRIPTOR CvRecord;
			public MINIDUMP_LOCATION_DESCRIPTOR MiscRecord;
			public uint64 Reserved0;
			public uint64 Reserved1;
		}
		[CRepr]
		public struct MINIDUMP_MODULE_LIST
		{
			public uint32 NumberOfModules;
			public MINIDUMP_MODULE[0] Modules;
		}
		[CRepr]
		public struct MINIDUMP_MEMORY_LIST
		{
			public uint32 NumberOfMemoryRanges;
			public MINIDUMP_MEMORY_DESCRIPTOR[0] MemoryRanges;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_MEMORY64_LIST
		{
			public uint64 NumberOfMemoryRanges;
			public uint64 BaseRva;
			public MINIDUMP_MEMORY_DESCRIPTOR64[0] MemoryRanges;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_EXCEPTION_INFORMATION
		{
			public uint32 ThreadId;
			public EXCEPTION_POINTERS* ExceptionPointers;
			public IntBool ClientPointers;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_EXCEPTION_INFORMATION64
		{
			public uint32 ThreadId;
			public uint64 ExceptionRecord;
			public uint64 ContextRecord;
			public IntBool ClientPointers;
		}
		[CRepr]
		public struct MINIDUMP_HANDLE_OBJECT_INFORMATION
		{
			public uint32 NextInfoRva;
			public uint32 InfoType;
			public uint32 SizeOfInfo;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_HANDLE_DESCRIPTOR
		{
			public uint64 Handle;
			public uint32 TypeNameRva;
			public uint32 ObjectNameRva;
			public uint32 Attributes;
			public uint32 GrantedAccess;
			public uint32 HandleCount;
			public uint32 PointerCount;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_HANDLE_DESCRIPTOR_2
		{
			public uint64 Handle;
			public uint32 TypeNameRva;
			public uint32 ObjectNameRva;
			public uint32 Attributes;
			public uint32 GrantedAccess;
			public uint32 HandleCount;
			public uint32 PointerCount;
			public uint32 ObjectInfoRva;
			public uint32 Reserved0;
		}
		[CRepr]
		public struct MINIDUMP_HANDLE_DATA_STREAM
		{
			public uint32 SizeOfHeader;
			public uint32 SizeOfDescriptor;
			public uint32 NumberOfDescriptors;
			public uint32 Reserved;
		}
		[CRepr]
		public struct MINIDUMP_HANDLE_OPERATION_LIST
		{
			public uint32 SizeOfHeader;
			public uint32 SizeOfEntry;
			public uint32 NumberOfEntries;
			public uint32 Reserved;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_FUNCTION_TABLE_DESCRIPTOR
		{
			public uint64 MinimumAddress;
			public uint64 MaximumAddress;
			public uint64 BaseAddress;
			public uint32 EntryCount;
			public uint32 SizeOfAlignPad;
		}
		[CRepr]
		public struct MINIDUMP_FUNCTION_TABLE_STREAM
		{
			public uint32 SizeOfHeader;
			public uint32 SizeOfDescriptor;
			public uint32 SizeOfNativeDescriptor;
			public uint32 SizeOfFunctionEntry;
			public uint32 NumberOfDescriptors;
			public uint32 SizeOfAlignPad;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_UNLOADED_MODULE
		{
			public uint64 BaseOfImage;
			public uint32 SizeOfImage;
			public uint32 CheckSum;
			public uint32 TimeDateStamp;
			public uint32 ModuleNameRva;
		}
		[CRepr]
		public struct MINIDUMP_UNLOADED_MODULE_LIST
		{
			public uint32 SizeOfHeader;
			public uint32 SizeOfEntry;
			public uint32 NumberOfEntries;
		}
		[CRepr, Packed(4)]
		public struct XSTATE_CONFIG_FEATURE_MSC_INFO
		{
			public uint32 SizeOfInfo;
			public uint32 ContextSize;
			public uint64 EnabledFeatures;
			public XSTATE_FEATURE[64] Features;
		}
		[CRepr]
		public struct MINIDUMP_MISC_INFO
		{
			public uint32 SizeOfInfo;
			public MINIDUMP_MISC_INFO_FLAGS Flags1;
			public uint32 ProcessId;
			public uint32 ProcessCreateTime;
			public uint32 ProcessUserTime;
			public uint32 ProcessKernelTime;
		}
		[CRepr]
		public struct MINIDUMP_MISC_INFO_2
		{
			public uint32 SizeOfInfo;
			public uint32 Flags1;
			public uint32 ProcessId;
			public uint32 ProcessCreateTime;
			public uint32 ProcessUserTime;
			public uint32 ProcessKernelTime;
			public uint32 ProcessorMaxMhz;
			public uint32 ProcessorCurrentMhz;
			public uint32 ProcessorMhzLimit;
			public uint32 ProcessorMaxIdleState;
			public uint32 ProcessorCurrentIdleState;
		}
		[CRepr]
		public struct MINIDUMP_MISC_INFO_3
		{
			public uint32 SizeOfInfo;
			public uint32 Flags1;
			public uint32 ProcessId;
			public uint32 ProcessCreateTime;
			public uint32 ProcessUserTime;
			public uint32 ProcessKernelTime;
			public uint32 ProcessorMaxMhz;
			public uint32 ProcessorCurrentMhz;
			public uint32 ProcessorMhzLimit;
			public uint32 ProcessorMaxIdleState;
			public uint32 ProcessorCurrentIdleState;
			public uint32 ProcessIntegrityLevel;
			public uint32 ProcessExecuteFlags;
			public uint32 ProtectedProcess;
			public uint32 TimeZoneId;
			public TIME_ZONE_INFORMATION TimeZone;
		}
		[CRepr]
		public struct MINIDUMP_MISC_INFO_4
		{
			public uint32 SizeOfInfo;
			public uint32 Flags1;
			public uint32 ProcessId;
			public uint32 ProcessCreateTime;
			public uint32 ProcessUserTime;
			public uint32 ProcessKernelTime;
			public uint32 ProcessorMaxMhz;
			public uint32 ProcessorCurrentMhz;
			public uint32 ProcessorMhzLimit;
			public uint32 ProcessorMaxIdleState;
			public uint32 ProcessorCurrentIdleState;
			public uint32 ProcessIntegrityLevel;
			public uint32 ProcessExecuteFlags;
			public uint32 ProtectedProcess;
			public uint32 TimeZoneId;
			public TIME_ZONE_INFORMATION TimeZone;
			public char16[260] BuildString;
			public char16[40] DbgBldStr;
		}
		[CRepr]
		public struct MINIDUMP_MISC_INFO_5
		{
			public uint32 SizeOfInfo;
			public uint32 Flags1;
			public uint32 ProcessId;
			public uint32 ProcessCreateTime;
			public uint32 ProcessUserTime;
			public uint32 ProcessKernelTime;
			public uint32 ProcessorMaxMhz;
			public uint32 ProcessorCurrentMhz;
			public uint32 ProcessorMhzLimit;
			public uint32 ProcessorMaxIdleState;
			public uint32 ProcessorCurrentIdleState;
			public uint32 ProcessIntegrityLevel;
			public uint32 ProcessExecuteFlags;
			public uint32 ProtectedProcess;
			public uint32 TimeZoneId;
			public TIME_ZONE_INFORMATION TimeZone;
			public char16[260] BuildString;
			public char16[40] DbgBldStr;
			public XSTATE_CONFIG_FEATURE_MSC_INFO XStateData;
			public uint32 ProcessCookie;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_MEMORY_INFO
		{
			public uint64 BaseAddress;
			public uint64 AllocationBase;
			public uint32 AllocationProtect;
			public uint32 __alignment1;
			public uint64 RegionSize;
			public VIRTUAL_ALLOCATION_TYPE State;
			public uint32 Protect;
			public uint32 Type;
			public uint32 __alignment2;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_MEMORY_INFO_LIST
		{
			public uint32 SizeOfHeader;
			public uint32 SizeOfEntry;
			public uint64 NumberOfEntries;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_THREAD_NAME
		{
			public uint32 ThreadId;
			public uint64 RvaOfThreadName;
		}
		[CRepr]
		public struct MINIDUMP_THREAD_NAME_LIST
		{
			public uint32 NumberOfThreadNames;
			public MINIDUMP_THREAD_NAME[0] ThreadNames;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_THREAD_INFO
		{
			public uint32 ThreadId;
			public MINIDUMP_THREAD_INFO_DUMP_FLAGS DumpFlags;
			public uint32 DumpError;
			public uint32 ExitStatus;
			public uint64 CreateTime;
			public uint64 ExitTime;
			public uint64 KernelTime;
			public uint64 UserTime;
			public uint64 StartAddress;
			public uint64 Affinity;
		}
		[CRepr]
		public struct MINIDUMP_THREAD_INFO_LIST
		{
			public uint32 SizeOfHeader;
			public uint32 SizeOfEntry;
			public uint32 NumberOfEntries;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_TOKEN_INFO_HEADER
		{
			public uint32 TokenSize;
			public uint32 TokenId;
			public uint64 TokenHandle;
		}
		[CRepr]
		public struct MINIDUMP_TOKEN_INFO_LIST
		{
			public uint32 TokenListSize;
			public uint32 TokenListEntries;
			public uint32 ListHeaderSize;
			public uint32 ElementHeaderSize;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_SYSTEM_BASIC_INFORMATION
		{
			public uint32 TimerResolution;
			public uint32 PageSize;
			public uint32 NumberOfPhysicalPages;
			public uint32 LowestPhysicalPageNumber;
			public uint32 HighestPhysicalPageNumber;
			public uint32 AllocationGranularity;
			public uint64 MinimumUserModeAddress;
			public uint64 MaximumUserModeAddress;
			public uint64 ActiveProcessorsAffinityMask;
			public uint32 NumberOfProcessors;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_SYSTEM_FILECACHE_INFORMATION
		{
			public uint64 CurrentSize;
			public uint64 PeakSize;
			public uint32 PageFaultCount;
			public uint64 MinimumWorkingSet;
			public uint64 MaximumWorkingSet;
			public uint64 CurrentSizeIncludingTransitionInPages;
			public uint64 PeakSizeIncludingTransitionInPages;
			public uint32 TransitionRePurposeCount;
			public uint32 Flags;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION
		{
			public uint64 AvailablePages;
			public uint64 CommittedPages;
			public uint64 CommitLimit;
			public uint64 PeakCommitment;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION
		{
			public uint64 IdleProcessTime;
			public uint64 IoReadTransferCount;
			public uint64 IoWriteTransferCount;
			public uint64 IoOtherTransferCount;
			public uint32 IoReadOperationCount;
			public uint32 IoWriteOperationCount;
			public uint32 IoOtherOperationCount;
			public uint32 AvailablePages;
			public uint32 CommittedPages;
			public uint32 CommitLimit;
			public uint32 PeakCommitment;
			public uint32 PageFaultCount;
			public uint32 CopyOnWriteCount;
			public uint32 TransitionCount;
			public uint32 CacheTransitionCount;
			public uint32 DemandZeroCount;
			public uint32 PageReadCount;
			public uint32 PageReadIoCount;
			public uint32 CacheReadCount;
			public uint32 CacheIoCount;
			public uint32 DirtyPagesWriteCount;
			public uint32 DirtyWriteIoCount;
			public uint32 MappedPagesWriteCount;
			public uint32 MappedWriteIoCount;
			public uint32 PagedPoolPages;
			public uint32 NonPagedPoolPages;
			public uint32 PagedPoolAllocs;
			public uint32 PagedPoolFrees;
			public uint32 NonPagedPoolAllocs;
			public uint32 NonPagedPoolFrees;
			public uint32 FreeSystemPtes;
			public uint32 ResidentSystemCodePage;
			public uint32 TotalSystemDriverPages;
			public uint32 TotalSystemCodePages;
			public uint32 NonPagedPoolLookasideHits;
			public uint32 PagedPoolLookasideHits;
			public uint32 AvailablePagedPoolPages;
			public uint32 ResidentSystemCachePage;
			public uint32 ResidentPagedPoolPage;
			public uint32 ResidentSystemDriverPage;
			public uint32 CcFastReadNoWait;
			public uint32 CcFastReadWait;
			public uint32 CcFastReadResourceMiss;
			public uint32 CcFastReadNotPossible;
			public uint32 CcFastMdlReadNoWait;
			public uint32 CcFastMdlReadWait;
			public uint32 CcFastMdlReadResourceMiss;
			public uint32 CcFastMdlReadNotPossible;
			public uint32 CcMapDataNoWait;
			public uint32 CcMapDataWait;
			public uint32 CcMapDataNoWaitMiss;
			public uint32 CcMapDataWaitMiss;
			public uint32 CcPinMappedDataCount;
			public uint32 CcPinReadNoWait;
			public uint32 CcPinReadWait;
			public uint32 CcPinReadNoWaitMiss;
			public uint32 CcPinReadWaitMiss;
			public uint32 CcCopyReadNoWait;
			public uint32 CcCopyReadWait;
			public uint32 CcCopyReadNoWaitMiss;
			public uint32 CcCopyReadWaitMiss;
			public uint32 CcMdlReadNoWait;
			public uint32 CcMdlReadWait;
			public uint32 CcMdlReadNoWaitMiss;
			public uint32 CcMdlReadWaitMiss;
			public uint32 CcReadAheadIos;
			public uint32 CcLazyWriteIos;
			public uint32 CcLazyWritePages;
			public uint32 CcDataFlushes;
			public uint32 CcDataPages;
			public uint32 ContextSwitches;
			public uint32 FirstLevelTbFills;
			public uint32 SecondLevelTbFills;
			public uint32 SystemCalls;
			public uint64 CcTotalDirtyPages;
			public uint64 CcDirtyPageThreshold;
			public int64 ResidentAvailablePages;
			public uint64 SharedCommittedPages;
		}
		[CRepr]
		public struct MINIDUMP_SYSTEM_MEMORY_INFO_1
		{
			public uint16 Revision;
			public uint16 Flags;
			public MINIDUMP_SYSTEM_BASIC_INFORMATION BasicInfo;
			public MINIDUMP_SYSTEM_FILECACHE_INFORMATION FileCacheInfo;
			public MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION BasicPerfInfo;
			public MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_PROCESS_VM_COUNTERS_1
		{
			public uint16 Revision;
			public uint32 PageFaultCount;
			public uint64 PeakWorkingSetSize;
			public uint64 WorkingSetSize;
			public uint64 QuotaPeakPagedPoolUsage;
			public uint64 QuotaPagedPoolUsage;
			public uint64 QuotaPeakNonPagedPoolUsage;
			public uint64 QuotaNonPagedPoolUsage;
			public uint64 PagefileUsage;
			public uint64 PeakPagefileUsage;
			public uint64 PrivateUsage;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_PROCESS_VM_COUNTERS_2
		{
			public uint16 Revision;
			public uint16 Flags;
			public uint32 PageFaultCount;
			public uint64 PeakWorkingSetSize;
			public uint64 WorkingSetSize;
			public uint64 QuotaPeakPagedPoolUsage;
			public uint64 QuotaPagedPoolUsage;
			public uint64 QuotaPeakNonPagedPoolUsage;
			public uint64 QuotaNonPagedPoolUsage;
			public uint64 PagefileUsage;
			public uint64 PeakPagefileUsage;
			public uint64 PeakVirtualSize;
			public uint64 VirtualSize;
			public uint64 PrivateUsage;
			public uint64 PrivateWorkingSetSize;
			public uint64 SharedCommitUsage;
			public uint64 JobSharedCommitUsage;
			public uint64 JobPrivateCommitUsage;
			public uint64 JobPeakPrivateCommitUsage;
			public uint64 JobPrivateCommitLimit;
			public uint64 JobTotalCommitLimit;
		}
		[CRepr]
		public struct MINIDUMP_USER_RECORD
		{
			public uint32 Type;
			public MINIDUMP_LOCATION_DESCRIPTOR Memory;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_USER_STREAM
		{
			public uint32 Type;
			public uint32 BufferSize;
			public void* Buffer;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_USER_STREAM_INFORMATION
		{
			public uint32 UserStreamCount;
			public MINIDUMP_USER_STREAM* UserStreamArray;
		}
		[CRepr]
		public struct MINIDUMP_INCLUDE_THREAD_CALLBACK
		{
			public uint32 ThreadId;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_MODULE_CALLBACK
		{
			public char16* FullPath;
			public uint64 BaseOfImage;
			public uint32 SizeOfImage;
			public uint32 CheckSum;
			public uint32 TimeDateStamp;
			public VS_FIXEDFILEINFO VersionInfo;
			public void* CvRecord;
			public uint32 SizeOfCvRecord;
			public void* MiscRecord;
			public uint32 SizeOfMiscRecord;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_INCLUDE_MODULE_CALLBACK
		{
			public uint64 BaseOfImage;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_IO_CALLBACK
		{
			public Handle Handle;
			public uint64 Offset;
			public void* Buffer;
			public uint32 BufferBytes;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_READ_MEMORY_FAILURE_CALLBACK
		{
			public uint64 Offset;
			public uint32 Bytes;
			public HResult FailureStatus;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_VM_QUERY_CALLBACK
		{
			public uint64 Offset;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_VM_PRE_READ_CALLBACK
		{
			public uint64 Offset;
			public void* Buffer;
			public uint32 Size;
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_VM_POST_READ_CALLBACK
		{
			public uint64 Offset;
			public void* Buffer;
			public uint32 Size;
			public uint32 Completed;
			public HResult Status;
		}
		[CRepr]
		public struct MINIDUMP_CALLBACK_INPUT
		{
			public uint32 ProcessId;
			public Handle ProcessHandle;
			public uint32 CallbackType;
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public HResult Status;
				public MINIDUMP_THREAD_CALLBACK Thread;
				public MINIDUMP_THREAD_EX_CALLBACK ThreadEx;
				public MINIDUMP_MODULE_CALLBACK Module;
				public MINIDUMP_INCLUDE_THREAD_CALLBACK IncludeThread;
				public MINIDUMP_INCLUDE_MODULE_CALLBACK IncludeModule;
				public MINIDUMP_IO_CALLBACK Io;
				public MINIDUMP_READ_MEMORY_FAILURE_CALLBACK ReadMemoryFailure;
				public uint32 SecondaryFlags;
				public MINIDUMP_VM_QUERY_CALLBACK VmQuery;
				public MINIDUMP_VM_PRE_READ_CALLBACK VmPreRead;
				public MINIDUMP_VM_POST_READ_CALLBACK VmPostRead;
			}
		}
		[CRepr]
		public struct MINIDUMP_CALLBACK_OUTPUT
		{
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union, Packed(4)]
			public struct _Anonymous_e__Union
			{
				public uint32 ModuleWriteFlags;
				public uint32 ThreadWriteFlags;
				public uint32 SecondaryFlags;
				public _Anonymous1_e__Struct Anonymous1;
				public _Anonymous2_e__Struct Anonymous2;
				public Handle Handle;
				public _Anonymous3_e__Struct Anonymous3;
				public _Anonymous4_e__Struct Anonymous4;
				public _Anonymous5_e__Struct Anonymous5;
				public HResult Status;
				
				[CRepr]
				public struct _Anonymous4_e__Struct
				{
					public HResult VmQueryStatus;
					public MINIDUMP_MEMORY_INFO VmQueryResult;
				}
				[CRepr]
				public struct _Anonymous2_e__Struct
				{
					public IntBool CheckCancel;
					public IntBool Cancel;
				}
				[CRepr]
				public struct _Anonymous5_e__Struct
				{
					public HResult VmReadStatus;
					public uint32 VmReadBytesCompleted;
				}
				[CRepr, Packed(4)]
				public struct _Anonymous1_e__Struct
				{
					public uint64 MemoryBase;
					public uint32 MemorySize;
				}
				[CRepr]
				public struct _Anonymous3_e__Struct
				{
					public MINIDUMP_MEMORY_INFO VmRegion;
					public IntBool Continue;
				}
			}
		}
		[CRepr, Packed(4)]
		public struct MINIDUMP_CALLBACK_INFORMATION
		{
			public MINIDUMP_CALLBACK_ROUTINE CallbackRoutine;
			public void* CallbackParam;
		}
		[CRepr]
		public struct DebugPropertyInfo
		{
			public uint32 m_dwValidFields;
			public char16* m_bstrName;
			public char16* m_bstrType;
			public char16* m_bstrValue;
			public char16* m_bstrFullName;
			public uint32 m_dwAttrib;
			public IDebugProperty* m_pDebugProp;
		}
		[CRepr]
		public struct ExtendedDebugPropertyInfo
		{
			public uint32 dwValidFields;
			public char16* pszName;
			public char16* pszType;
			public char16* pszValue;
			public char16* pszFullName;
			public uint32 dwAttrib;
			public IDebugProperty* pDebugProp;
			public uint32 nDISPID;
			public uint32 nType;
			public VARIANT varValue;
			public ILockBytes* plbValue;
			public IDebugExtendedProperty* pDebugExtProp;
		}
		[CRepr]
		public struct DebugStackFrameDescriptor
		{
			public IDebugStackFrame* pdsf;
			public uint32 dwMin;
			public uint32 dwLim;
			public IntBool fFinal;
			public IUnknown* punkFinal;
		}
		[CRepr]
		public struct DebugStackFrameDescriptor64
		{
			public IDebugStackFrame* pdsf;
			public uint64 dwMin;
			public uint64 dwLim;
			public IntBool fFinal;
			public IUnknown* punkFinal;
		}
		[CRepr]
		public struct PROFILER_HEAP_OBJECT_SCOPE_LIST
		{
			public uint32 count;
			public uint[0] scopes;
		}
		[CRepr]
		public struct PROFILER_PROPERTY_TYPE_SUBSTRING_INFO
		{
			public uint32 length;
			public char16* value;
		}
		[CRepr]
		public struct PROFILER_HEAP_OBJECT_RELATIONSHIP
		{
			public uint32 relationshipId;
			public PROFILER_RELATIONSHIP_INFO relationshipInfo;
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public double numberValue;
				public char16* stringValue;
				public char16* bstrValue;
				public uint objectId;
				public void* externalObjectAddress;
				public PROFILER_PROPERTY_TYPE_SUBSTRING_INFO* subString;
			}
		}
		[CRepr]
		public struct PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST
		{
			public uint32 count;
			public PROFILER_HEAP_OBJECT_RELATIONSHIP[0] elements;
		}
		[CRepr]
		public struct PROFILER_HEAP_OBJECT_OPTIONAL_INFO
		{
			public PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE infoType;
			public _Anonymous_e__Union Anonymous;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public uint prototype;
				public char16* functionName;
				public uint32 elementAttributesSize;
				public uint32 elementTextChildrenSize;
				public PROFILER_HEAP_OBJECT_SCOPE_LIST* scopeList;
				public PROFILER_HEAP_OBJECT_RELATIONSHIP* internalProperty;
				public PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST* namePropertyList;
				public PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST* indexPropertyList;
				public PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST* relationshipList;
				public PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST* eventList;
				public PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST* weakMapCollectionList;
				public PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST* mapCollectionList;
				public PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST* setCollectionList;
			}
		}
		[CRepr]
		public struct PROFILER_HEAP_OBJECT
		{
			public uint32 size;
			public _Anonymous_e__Union Anonymous;
			public uint32 typeNameId;
			public uint32 flags;
			public uint16 unused;
			public uint16 optionalInfoCount;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public uint objectId;
				public void* externalObjectAddress;
			}
		}
		[CRepr]
		public struct PROFILER_HEAP_SUMMARY
		{
			public PROFILER_HEAP_SUMMARY_VERSION version;
			public uint32 totalHeapSize;
		}
		[CRepr]
		public struct LOADED_IMAGE
		{
			public char8* ModuleName;
			public Handle hFile;
			public uint8* MappedAddress;
			public IMAGE_NT_HEADERS64* FileHeader;
			public IMAGE_SECTION_HEADER* LastRvaSection;
			public uint32 NumberOfSections;
			public IMAGE_SECTION_HEADER* Sections;
			public IMAGE_FILE_CHARACTERISTICS2 Characteristics;
			public bool fSystemImage;
			public bool fDOSImage;
			public bool fReadOnly;
			public uint8 Version;
			public ListEntry Links;
			public uint32 SizeOfImage;
		}
		[CRepr]
		public struct MODLOAD_DATA
		{
			public uint32 ssize;
			public MODLOAD_DATA_TYPE ssig;
			public void* data;
			public uint32 size;
			public uint32 flags;
		}
		[CRepr]
		public struct MODLOAD_CVMISC
		{
			public uint32 oCV;
			public uint cCV;
			public uint32 oMisc;
			public uint cMisc;
			public uint32 dtImage;
			public uint32 cImage;
		}
		[CRepr]
		public struct MODLOAD_PDBGUID_PDBAGE
		{
			public Guid PdbGuid;
			public uint32 PdbAge;
		}
		[CRepr]
		public struct ADDRESS64
		{
			public uint64 Offset;
			public uint16 Segment;
			public ADDRESS_MODE Mode;
		}
		[CRepr]
		public struct KDHELP64
		{
			public uint64 Thread;
			public uint32 ThCallbackStack;
			public uint32 ThCallbackBStore;
			public uint32 NextCallback;
			public uint32 FramePointer;
			public uint64 KiCallUserMode;
			public uint64 KeUserCallbackDispatcher;
			public uint64 SystemRangeStart;
			public uint64 KiUserExceptionDispatcher;
			public uint64 StackBase;
			public uint64 StackLimit;
			public uint32 BuildVersion;
			public uint32 RetpolineStubFunctionTableSize;
			public uint64 RetpolineStubFunctionTable;
			public uint32 RetpolineStubOffset;
			public uint32 RetpolineStubSize;
			public uint64[2] Reserved0;
		}
		[CRepr]
		public struct STACKFRAME64
		{
			public ADDRESS64 AddrPC;
			public ADDRESS64 AddrReturn;
			public ADDRESS64 AddrFrame;
			public ADDRESS64 AddrStack;
			public ADDRESS64 AddrBStore;
			public void* FuncTableEntry;
			public uint64[4] Params;
			public IntBool Far;
			public IntBool Virtual;
			public uint64[3] Reserved;
			public KDHELP64 KdHelp;
		}
		[CRepr]
		public struct STACKFRAME_EX
		{
			public ADDRESS64 AddrPC;
			public ADDRESS64 AddrReturn;
			public ADDRESS64 AddrFrame;
			public ADDRESS64 AddrStack;
			public ADDRESS64 AddrBStore;
			public void* FuncTableEntry;
			public uint64[4] Params;
			public IntBool Far;
			public IntBool Virtual;
			public uint64[3] Reserved;
			public KDHELP64 KdHelp;
			public uint32 StackFrameSize;
			public uint32 InlineFrameContext;
		}
		[CRepr]
		public struct API_VERSION
		{
			public uint16 MajorVersion;
			public uint16 MinorVersion;
			public uint16 Revision;
			public uint16 Reserved;
		}
		[CRepr]
		public struct IMAGEHLP_SYMBOL64
		{
			public uint32 SizeOfStruct;
			public uint64 Address;
			public uint32 Size;
			public uint32 Flags;
			public uint32 MaxNameLength;
			public char8[0] Name;
		}
		[CRepr]
		public struct IMAGEHLP_SYMBOL64_PACKAGE
		{
			public IMAGEHLP_SYMBOL64 sym;
			public char8[2001] name;
		}
		[CRepr]
		public struct IMAGEHLP_SYMBOLW64
		{
			public uint32 SizeOfStruct;
			public uint64 Address;
			public uint32 Size;
			public uint32 Flags;
			public uint32 MaxNameLength;
			public char16[0] Name;
		}
		[CRepr]
		public struct IMAGEHLP_SYMBOLW64_PACKAGE
		{
			public IMAGEHLP_SYMBOLW64 sym;
			public char16[2001] name;
		}
		[CRepr]
		public struct IMAGEHLP_MODULE64
		{
			public uint32 SizeOfStruct;
			public uint64 BaseOfImage;
			public uint32 ImageSize;
			public uint32 TimeDateStamp;
			public uint32 CheckSum;
			public uint32 NumSyms;
			public SYM_TYPE SymType;
			public char8[32] ModuleName;
			public char8[256] ImageName;
			public char8[256] LoadedImageName;
			public char8[256] LoadedPdbName;
			public uint32 CVSig;
			public char8[780] CVData;
			public uint32 PdbSig;
			public Guid PdbSig70;
			public uint32 PdbAge;
			public IntBool PdbUnmatched;
			public IntBool DbgUnmatched;
			public IntBool LineNumbers;
			public IntBool GlobalSymbols;
			public IntBool TypeInfo;
			public IntBool SourceIndexed;
			public IntBool Publics;
			public uint32 MachineType;
			public uint32 Reserved;
		}
		[CRepr]
		public struct IMAGEHLP_MODULE64_EX
		{
			public IMAGEHLP_MODULE64 Module;
			public uint32 RegionFlags;
		}
		[CRepr]
		public struct IMAGEHLP_MODULEW64
		{
			public uint32 SizeOfStruct;
			public uint64 BaseOfImage;
			public uint32 ImageSize;
			public uint32 TimeDateStamp;
			public uint32 CheckSum;
			public uint32 NumSyms;
			public SYM_TYPE SymType;
			public char16[32] ModuleName;
			public char16[256] ImageName;
			public char16[256] LoadedImageName;
			public char16[256] LoadedPdbName;
			public uint32 CVSig;
			public char16[780] CVData;
			public uint32 PdbSig;
			public Guid PdbSig70;
			public uint32 PdbAge;
			public IntBool PdbUnmatched;
			public IntBool DbgUnmatched;
			public IntBool LineNumbers;
			public IntBool GlobalSymbols;
			public IntBool TypeInfo;
			public IntBool SourceIndexed;
			public IntBool Publics;
			public uint32 MachineType;
			public uint32 Reserved;
		}
		[CRepr]
		public struct IMAGEHLP_MODULEW64_EX
		{
			public IMAGEHLP_MODULEW64 Module;
			public uint32 RegionFlags;
		}
		[CRepr]
		public struct IMAGEHLP_LINE64
		{
			public uint32 SizeOfStruct;
			public void* Key;
			public uint32 LineNumber;
			public char8* FileName;
			public uint64 Address;
		}
		[CRepr]
		public struct IMAGEHLP_LINEW64
		{
			public uint32 SizeOfStruct;
			public void* Key;
			public uint32 LineNumber;
			public char16* FileName;
			public uint64 Address;
		}
		[CRepr]
		public struct SOURCEFILE
		{
			public uint64 ModBase;
			public char8* FileName;
		}
		[CRepr]
		public struct SOURCEFILEW
		{
			public uint64 ModBase;
			public char16* FileName;
		}
		[CRepr]
		public struct IMAGEHLP_CBA_READ_MEMORY
		{
			public uint64 addr;
			public void* buf;
			public uint32 bytes;
			public uint32* bytesread;
		}
		[CRepr]
		public struct IMAGEHLP_CBA_EVENT
		{
			public IMAGEHLP_CBA_EVENT_SEVERITY severity;
			public uint32 code;
			public char8* desc;
			public void* object;
		}
		[CRepr]
		public struct IMAGEHLP_CBA_EVENTW
		{
			public IMAGEHLP_CBA_EVENT_SEVERITY severity;
			public uint32 code;
			public char16* desc;
			public void* object;
		}
		[CRepr]
		public struct IMAGEHLP_DEFERRED_SYMBOL_LOAD64
		{
			public uint32 SizeOfStruct;
			public uint64 BaseOfImage;
			public uint32 CheckSum;
			public uint32 TimeDateStamp;
			public char8[260] FileName;
			public bool Reparse;
			public Handle hFile;
			public uint32 Flags;
		}
		[CRepr]
		public struct IMAGEHLP_DEFERRED_SYMBOL_LOADW64
		{
			public uint32 SizeOfStruct;
			public uint64 BaseOfImage;
			public uint32 CheckSum;
			public uint32 TimeDateStamp;
			public char16[261] FileName;
			public bool Reparse;
			public Handle hFile;
			public uint32 Flags;
		}
		[CRepr]
		public struct IMAGEHLP_DUPLICATE_SYMBOL64
		{
			public uint32 SizeOfStruct;
			public uint32 NumberOfDups;
			public IMAGEHLP_SYMBOL64* Symbol;
			public uint32 SelectedSymbol;
		}
		[CRepr]
		public struct _IMAGEHLP_JIT_SYMBOL_MAP
		{
			public uint32 SizeOfStruct;
			public uint64 Address;
			public uint64 BaseOfImage;
		}
		[CRepr]
		public struct OMAP
		{
			public uint32 rva;
			public uint32 rvaTo;
		}
		[CRepr]
		public struct SRCCODEINFO
		{
			public uint32 SizeOfStruct;
			public void* Key;
			public uint64 ModBase;
			public char8[261] Obj;
			public char8[261] FileName;
			public uint32 LineNumber;
			public uint64 Address;
		}
		[CRepr]
		public struct SRCCODEINFOW
		{
			public uint32 SizeOfStruct;
			public void* Key;
			public uint64 ModBase;
			public char16[261] Obj;
			public char16[261] FileName;
			public uint32 LineNumber;
			public uint64 Address;
		}
		[CRepr]
		public struct IMAGEHLP_SYMBOL_SRC
		{
			public uint32 sizeofstruct;
			public uint32 type;
			public char8[260] file;
		}
		[CRepr]
		public struct MODULE_TYPE_INFO
		{
			public uint16 dataLength;
			public uint16 leaf;
			public uint8[0] data;
		}
		[CRepr]
		public struct SYMBOL_INFO
		{
			public uint32 SizeOfStruct;
			public uint32 TypeIndex;
			public uint64[2] Reserved;
			public uint32 Index;
			public uint32 Size;
			public uint64 ModBase;
			public SYMBOL_INFO_FLAGS Flags;
			public uint64 Value;
			public uint64 Address;
			public uint32 Register;
			public uint32 Scope;
			public uint32 Tag;
			public uint32 NameLen;
			public uint32 MaxNameLen;
			public char8[0] Name;
		}
		[CRepr]
		public struct SYMBOL_INFO_PACKAGE
		{
			public SYMBOL_INFO si;
			public char8[2001] name;
		}
		[CRepr]
		public struct SYMBOL_INFOW
		{
			public uint32 SizeOfStruct;
			public uint32 TypeIndex;
			public uint64[2] Reserved;
			public uint32 Index;
			public uint32 Size;
			public uint64 ModBase;
			public SYMBOL_INFO_FLAGS Flags;
			public uint64 Value;
			public uint64 Address;
			public uint32 Register;
			public uint32 Scope;
			public uint32 Tag;
			public uint32 NameLen;
			public uint32 MaxNameLen;
			public char16[0] Name;
		}
		[CRepr]
		public struct SYMBOL_INFO_PACKAGEW
		{
			public SYMBOL_INFOW si;
			public char16[2001] name;
		}
		[CRepr]
		public struct IMAGEHLP_STACK_FRAME
		{
			public uint64 InstructionOffset;
			public uint64 ReturnOffset;
			public uint64 FrameOffset;
			public uint64 StackOffset;
			public uint64 BackingStoreOffset;
			public uint64 FuncTableEntry;
			public uint64[4] Params;
			public uint64[5] Reserved;
			public IntBool Virtual;
			public uint32 Reserved2;
		}
		[CRepr]
		public struct TI_FINDCHILDREN_PARAMS
		{
			public uint32 Count;
			public uint32 Start;
			public uint32[0] ChildId;
		}
		[CRepr]
		public struct IMAGEHLP_GET_TYPE_INFO_PARAMS
		{
			public uint32 SizeOfStruct;
			public IMAGEHLP_GET_TYPE_INFO_FLAGS Flags;
			public uint32 NumIds;
			public uint32* TypeIds;
			public uint64 TagFilter;
			public uint32 NumReqs;
			public IMAGEHLP_SYMBOL_TYPE_INFO* ReqKinds;
			public uint* ReqOffsets;
			public uint32* ReqSizes;
			public uint ReqStride;
			public uint BufferSize;
			public void* Buffer;
			public uint32 EntriesMatched;
			public uint32 EntriesFilled;
			public uint64 TagsFound;
			public uint64 AllReqsValid;
			public uint32 NumReqsValid;
			public uint64* ReqsValid;
		}
		[CRepr]
		public struct SYMSRV_INDEX_INFO
		{
			public uint32 sizeofstruct;
			public char8[261] file;
			public IntBool stripped;
			public uint32 timestamp;
			public uint32 size;
			public char8[261] dbgfile;
			public char8[261] pdbfile;
			public Guid guid;
			public uint32 sig;
			public uint32 age;
		}
		[CRepr]
		public struct SYMSRV_INDEX_INFOW
		{
			public uint32 sizeofstruct;
			public char16[261] file;
			public IntBool stripped;
			public uint32 timestamp;
			public uint32 size;
			public char16[261] dbgfile;
			public char16[261] pdbfile;
			public Guid guid;
			public uint32 sig;
			public uint32 age;
		}
		[CRepr]
		public struct SYMSRV_EXTENDED_OUTPUT_DATA
		{
			public uint32 sizeOfStruct;
			public uint32 version;
			public char16[261] filePtrMsg;
		}
		[CRepr]
		public struct DBGHELP_DATA_REPORT_STRUCT
		{
			public char16* pBinPathNonExist;
			public char16* pSymbolPathNonExist;
		}
		[CRepr]
		public struct TEXT_DOCUMENT_ARRAY
		{
			public uint32 dwCount;
			public IDebugDocumentText** Members;
		}
		[CRepr]
		public struct JsDebugPropertyInfo
		{
			public char16* name;
			public char16* type;
			public char16* value;
			public char16* fullName;
			public JS_PROPERTY_ATTRIBUTES attr;
		}
		[CRepr]
		public struct __MIDL___MIDL_itf_jscript9diag_0000_0007_0001
		{
			public uint64 InstructionOffset;
			public uint64 ReturnOffset;
			public uint64 FrameOffset;
			public uint64 StackOffset;
		}
		[CRepr]
		public struct PHYSICAL_MEMORY_RUN32
		{
			public uint32 BasePage;
			public uint32 PageCount;
		}
		[CRepr]
		public struct PHYSICAL_MEMORY_DESCRIPTOR32
		{
			public uint32 NumberOfRuns;
			public uint32 NumberOfPages;
			public PHYSICAL_MEMORY_RUN32[0] Run;
		}
		[CRepr]
		public struct PHYSICAL_MEMORY_RUN64
		{
			public uint64 BasePage;
			public uint64 PageCount;
		}
		[CRepr]
		public struct PHYSICAL_MEMORY_DESCRIPTOR64
		{
			public uint32 NumberOfRuns;
			public uint64 NumberOfPages;
			public PHYSICAL_MEMORY_RUN64[0] Run;
		}
		[CRepr, Union]
		public struct DUMP_FILE_ATTRIBUTES
		{
			public _Anonymous_e__Struct Anonymous;
			public uint32 Attributes;
			
			[CRepr]
			public struct _Anonymous_e__Struct
			{
				public uint32 _bitfield;
			}
		}
		[CRepr]
		public struct DUMP_HEADER32
		{
			public uint32 Signature;
			public uint32 ValidDump;
			public uint32 MajorVersion;
			public uint32 MinorVersion;
			public uint32 DirectoryTableBase;
			public uint32 PfnDataBase;
			public uint32 PsLoadedModuleList;
			public uint32 PsActiveProcessHead;
			public uint32 MachineImageType;
			public uint32 NumberProcessors;
			public uint32 BugCheckCode;
			public uint32 BugCheckParameter1;
			public uint32 BugCheckParameter2;
			public uint32 BugCheckParameter3;
			public uint32 BugCheckParameter4;
			public char8[32] VersionUser;
			public uint8 PaeEnabled;
			public uint8 KdSecondaryVersion;
			public uint8[2] Spare3;
			public uint32 KdDebuggerDataBlock;
			public _Anonymous_e__Union Anonymous;
			public uint8[1200] ContextRecord;
			public EXCEPTION_RECORD32 Exception;
			public char8[128] Comment;
			public DUMP_FILE_ATTRIBUTES Attributes;
			public uint32 BootId;
			public uint8[1760] _reserved0;
			public uint32 DumpType;
			public uint32 MiniDumpFields;
			public uint32 SecondaryDataState;
			public uint32 ProductType;
			public uint32 SuiteMask;
			public uint32 WriterStatus;
			public LARGE_INTEGER RequiredDumpSpace;
			public uint8[16] _reserved2;
			public LARGE_INTEGER SystemUpTime;
			public LARGE_INTEGER SystemTime;
			public uint8[56] _reserved3;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public PHYSICAL_MEMORY_DESCRIPTOR32 PhysicalMemoryBlock;
				public uint8[700] PhysicalMemoryBlockBuffer;
			}
		}
		[CRepr]
		public struct DUMP_HEADER64
		{
			public uint32 Signature;
			public uint32 ValidDump;
			public uint32 MajorVersion;
			public uint32 MinorVersion;
			public uint64 DirectoryTableBase;
			public uint64 PfnDataBase;
			public uint64 PsLoadedModuleList;
			public uint64 PsActiveProcessHead;
			public uint32 MachineImageType;
			public uint32 NumberProcessors;
			public uint32 BugCheckCode;
			public uint64 BugCheckParameter1;
			public uint64 BugCheckParameter2;
			public uint64 BugCheckParameter3;
			public uint64 BugCheckParameter4;
			public char8[32] VersionUser;
			public uint64 KdDebuggerDataBlock;
			public _Anonymous_e__Union Anonymous;
			public uint8[3000] ContextRecord;
			public EXCEPTION_RECORD64 Exception;
			public uint32 DumpType;
			public LARGE_INTEGER RequiredDumpSpace;
			public LARGE_INTEGER SystemTime;
			public char8[128] Comment;
			public LARGE_INTEGER SystemUpTime;
			public uint32 MiniDumpFields;
			public uint32 SecondaryDataState;
			public uint32 ProductType;
			public uint32 SuiteMask;
			public uint32 WriterStatus;
			public uint8 Unused1;
			public uint8 KdSecondaryVersion;
			public uint8[2] Unused;
			public DUMP_FILE_ATTRIBUTES Attributes;
			public uint32 BootId;
			public uint8[4008] _reserved0;
			
			[CRepr, Union]
			public struct _Anonymous_e__Union
			{
				public PHYSICAL_MEMORY_DESCRIPTOR64 PhysicalMemoryBlock;
				public uint8[700] PhysicalMemoryBlockBuffer;
			}
		}
		[CRepr, Packed(1)]
		public struct WHEA_ERROR_SOURCE_CONFIGURATION_DD
		{
			public WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER Initialize;
			public WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER Uninitialize;
			public WHEA_ERROR_SOURCE_CORRECT_DEVICE_DRIVER Correct;
		}
		[CRepr, Packed(1)]
		public struct WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER_V1
		{
			public uint32 Version;
			public Guid SourceGuid;
			public uint16 LogTag;
			public uint8[6] Reserved;
			public WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER Initialize;
			public WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER Uninitialize;
		}
		[CRepr, Packed(1)]
		public struct WHEA_ERROR_SOURCE_CONFIGURATION_DEVICE_DRIVER
		{
			public uint32 Version;
			public Guid SourceGuid;
			public uint16 LogTag;
			public uint8[6] Reserved;
			public WHEA_ERROR_SOURCE_INITIALIZE_DEVICE_DRIVER Initialize;
			public WHEA_ERROR_SOURCE_UNINITIALIZE_DEVICE_DRIVER Uninitialize;
			public uint32 MaxSectionDataLength;
			public uint32 MaxSectionsPerReport;
			public Guid CreatorId;
			public Guid PartitionId;
		}
		[CRepr, Packed(1)]
		public struct WHEA_DRIVER_BUFFER_SET
		{
			public uint32 Version;
			public uint8* Data;
			public uint32 DataSize;
			public Guid* SectionTypeGuid;
			public uint8* SectionFriendlyName;
			public uint8* Flags;
		}
		[CRepr, Union, Packed(1)]
		public struct WHEA_NOTIFICATION_FLAGS
		{
			public _Anonymous_e__Struct Anonymous;
			public uint16 AsUSHORT;
			
			[CRepr, Packed(1)]
			public struct _Anonymous_e__Struct
			{
				public uint16 _bitfield;
			}
		}
		[CRepr, Union]
		public struct XPF_MC_BANK_FLAGS
		{
			public _Anonymous_e__Struct Anonymous;
			public uint8 AsUCHAR;
			
			[CRepr]
			public struct _Anonymous_e__Struct
			{
				public uint8 _bitfield;
			}
		}
		[CRepr, Union, Packed(1)]
		public struct XPF_MCE_FLAGS
		{
			public _Anonymous_e__Struct Anonymous;
			public uint32 AsULONG;
			
			[CRepr, Packed(1)]
			public struct _Anonymous_e__Struct
			{
				public uint32 _bitfield;
			}
		}
		[CRepr, Union, Packed(1)]
		public struct AER_ROOTPORT_DESCRIPTOR_FLAGS
		{
			public _Anonymous_e__Struct Anonymous;
			public uint16 AsUSHORT;
			
			[CRepr, Packed(1)]
			public struct _Anonymous_e__Struct
			{
				public uint16 _bitfield;
			}
		}
		[CRepr, Union, Packed(1)]
		public struct AER_ENDPOINT_DESCRIPTOR_FLAGS
		{
			public _Anonymous_e__Struct Anonymous;
			public uint16 AsUSHORT;
			
			[CRepr, Packed(1)]
			public struct _Anonymous_e__Struct
			{
				public uint16 _bitfield;
			}
		}
		[CRepr, Union, Packed(1)]
		public struct AER_BRIDGE_DESCRIPTOR_FLAGS
		{
			public _Anonymous_e__Struct Anonymous;
			public uint16 AsUSHORT;
			
			[CRepr, Packed(1)]
			public struct _Anonymous_e__Struct
			{
				public uint16 _bitfield;
			}
		}
		[CRepr]
		public struct WHEA_NOTIFICATION_DESCRIPTOR
		{
			public uint8 Type;
			public uint8 Length;
			public WHEA_NOTIFICATION_FLAGS Flags;
			public _u_e__Union u;
			
			[CRepr, Union]
			public struct _u_e__Union
			{
				public _Polled_e__Struct Polled;
				public _Interrupt_e__Struct Interrupt;
				public _LocalInterrupt_e__Struct LocalInterrupt;
				public _Sci_e__Struct Sci;
				public _Nmi_e__Struct Nmi;
				public _Sea_e__Struct Sea;
				public _Sei_e__Struct Sei;
				public _Gsiv_e__Struct Gsiv;
				
				[CRepr, Packed(1)]
				public struct _Sei_e__Struct
				{
					public uint32 PollInterval;
					public uint32 Vector;
					public uint32 SwitchToPollingThreshold;
					public uint32 SwitchToPollingWindow;
					public uint32 ErrorThreshold;
					public uint32 ErrorThresholdWindow;
				}
				[CRepr, Packed(1)]
				public struct _Nmi_e__Struct
				{
					public uint32 PollInterval;
					public uint32 Vector;
					public uint32 SwitchToPollingThreshold;
					public uint32 SwitchToPollingWindow;
					public uint32 ErrorThreshold;
					public uint32 ErrorThresholdWindow;
				}
				[CRepr, Packed(1)]
				public struct _LocalInterrupt_e__Struct
				{
					public uint32 PollInterval;
					public uint32 Vector;
					public uint32 SwitchToPollingThreshold;
					public uint32 SwitchToPollingWindow;
					public uint32 ErrorThreshold;
					public uint32 ErrorThresholdWindow;
				}
				[CRepr, Packed(1)]
				public struct _Polled_e__Struct
				{
					public uint32 PollInterval;
				}
				[CRepr, Packed(1)]
				public struct _Sea_e__Struct
				{
					public uint32 PollInterval;
					public uint32 Vector;
					public uint32 SwitchToPollingThreshold;
					public uint32 SwitchToPollingWindow;
					public uint32 ErrorThreshold;
					public uint32 ErrorThresholdWindow;
				}
				[CRepr, Packed(1)]
				public struct _Interrupt_e__Struct
				{
					public uint32 PollInterval;
					public uint32 Vector;
					public uint32 SwitchToPollingThreshold;
					public uint32 SwitchToPollingWindow;
					public uint32 ErrorThreshold;
					public uint32 ErrorThresholdWindow;
				}
				[CRepr, Packed(1)]
				public struct _Sci_e__Struct
				{
					public uint32 PollInterval;
					public uint32 Vector;
					public uint32 SwitchToPollingThreshold;
					public uint32 SwitchToPollingWindow;
					public uint32 ErrorThreshold;
					public uint32 ErrorThresholdWindow;
				}
				[CRepr, Packed(1)]
				public struct _Gsiv_e__Struct
				{
					public uint32 PollInterval;
					public uint32 Vector;
					public uint32 SwitchToPollingThreshold;
					public uint32 SwitchToPollingWindow;
					public uint32 ErrorThreshold;
					public uint32 ErrorThresholdWindow;
				}
			}
		}
		[CRepr, Packed(1)]
		public struct WHEA_XPF_MC_BANK_DESCRIPTOR
		{
			public uint8 BankNumber;
			public bool ClearOnInitialization;
			public uint8 StatusDataFormat;
			public XPF_MC_BANK_FLAGS Flags;
			public uint32 ControlMsr;
			public uint32 StatusMsr;
			public uint32 AddressMsr;
			public uint32 MiscMsr;
			public uint64 ControlData;
		}
		[CRepr, Packed(1)]
		public struct WHEA_XPF_MCE_DESCRIPTOR
		{
			public uint16 Type;
			public uint8 Enabled;
			public uint8 NumberOfBanks;
			public XPF_MCE_FLAGS Flags;
			public uint64 MCG_Capability;
			public uint64 MCG_GlobalControl;
			public WHEA_XPF_MC_BANK_DESCRIPTOR[32] Banks;
		}
		[CRepr, Packed(1)]
		public struct WHEA_XPF_CMC_DESCRIPTOR
		{
			public uint16 Type;
			public bool Enabled;
			public uint8 NumberOfBanks;
			public uint32 Reserved;
			public WHEA_NOTIFICATION_DESCRIPTOR Notify;
			public WHEA_XPF_MC_BANK_DESCRIPTOR[32] Banks;
		}
		[CRepr]
		public struct WHEA_PCI_SLOT_NUMBER
		{
			public _u_e__Union u;
			
			[CRepr, Union, Packed(1)]
			public struct _u_e__Union
			{
				public _bits_e__Struct bits;
				public uint32 AsULONG;
				
				[CRepr, Packed(1)]
				public struct _bits_e__Struct
				{
					public uint32 _bitfield;
				}
			}
		}
		[CRepr, Packed(1)]
		public struct WHEA_XPF_NMI_DESCRIPTOR
		{
			public uint16 Type;
			public bool Enabled;
		}
		[CRepr, Packed(1)]
		public struct WHEA_AER_ROOTPORT_DESCRIPTOR
		{
			public uint16 Type;
			public bool Enabled;
			public uint8 Reserved;
			public uint32 BusNumber;
			public WHEA_PCI_SLOT_NUMBER Slot;
			public uint16 DeviceControl;
			public AER_ROOTPORT_DESCRIPTOR_FLAGS Flags;
			public uint32 UncorrectableErrorMask;
			public uint32 UncorrectableErrorSeverity;
			public uint32 CorrectableErrorMask;
			public uint32 AdvancedCapsAndControl;
			public uint32 RootErrorCommand;
		}
		[CRepr, Packed(1)]
		public struct WHEA_AER_ENDPOINT_DESCRIPTOR
		{
			public uint16 Type;
			public bool Enabled;
			public uint8 Reserved;
			public uint32 BusNumber;
			public WHEA_PCI_SLOT_NUMBER Slot;
			public uint16 DeviceControl;
			public AER_ENDPOINT_DESCRIPTOR_FLAGS Flags;
			public uint32 UncorrectableErrorMask;
			public uint32 UncorrectableErrorSeverity;
			public uint32 CorrectableErrorMask;
			public uint32 AdvancedCapsAndControl;
		}
		[CRepr, Packed(1)]
		public struct WHEA_AER_BRIDGE_DESCRIPTOR
		{
			public uint16 Type;
			public bool Enabled;
			public uint8 Reserved;
			public uint32 BusNumber;
			public WHEA_PCI_SLOT_NUMBER Slot;
			public uint16 DeviceControl;
			public AER_BRIDGE_DESCRIPTOR_FLAGS Flags;
			public uint32 UncorrectableErrorMask;
			public uint32 UncorrectableErrorSeverity;
			public uint32 CorrectableErrorMask;
			public uint32 AdvancedCapsAndControl;
			public uint32 SecondaryUncorrectableErrorMask;
			public uint32 SecondaryUncorrectableErrorSev;
			public uint32 SecondaryCapsAndControl;
		}
		[CRepr, Packed(1)]
		public struct WHEA_GENERIC_ERROR_DESCRIPTOR
		{
			public uint16 Type;
			public uint8 Reserved;
			public uint8 Enabled;
			public uint32 ErrStatusBlockLength;
			public uint32 RelatedErrorSourceId;
			public uint8 ErrStatusAddressSpaceID;
			public uint8 ErrStatusAddressBitWidth;
			public uint8 ErrStatusAddressBitOffset;
			public uint8 ErrStatusAddressAccessSize;
			public LARGE_INTEGER ErrStatusAddress;
			public WHEA_NOTIFICATION_DESCRIPTOR Notify;
		}
		[CRepr, Packed(1)]
		public struct WHEA_GENERIC_ERROR_DESCRIPTOR_V2
		{
			public uint16 Type;
			public uint8 Reserved;
			public uint8 Enabled;
			public uint32 ErrStatusBlockLength;
			public uint32 RelatedErrorSourceId;
			public uint8 ErrStatusAddressSpaceID;
			public uint8 ErrStatusAddressBitWidth;
			public uint8 ErrStatusAddressBitOffset;
			public uint8 ErrStatusAddressAccessSize;
			public LARGE_INTEGER ErrStatusAddress;
			public WHEA_NOTIFICATION_DESCRIPTOR Notify;
			public uint8 ReadAckAddressSpaceID;
			public uint8 ReadAckAddressBitWidth;
			public uint8 ReadAckAddressBitOffset;
			public uint8 ReadAckAddressAccessSize;
			public LARGE_INTEGER ReadAckAddress;
			public uint64 ReadAckPreserveMask;
			public uint64 ReadAckWriteMask;
		}
		[CRepr, Packed(1)]
		public struct WHEA_DEVICE_DRIVER_DESCRIPTOR
		{
			public uint16 Type;
			public bool Enabled;
			public uint8 Reserved;
			public Guid SourceGuid;
			public uint16 LogTag;
			public uint16 Reserved2;
			public uint32 PacketLength;
			public uint32 PacketCount;
			public uint8* PacketBuffer;
			public WHEA_ERROR_SOURCE_CONFIGURATION_DD Config;
			public Guid CreatorId;
			public Guid PartitionId;
			public uint32 MaxSectionDataLength;
			public uint32 MaxSectionsPerRecord;
			public uint8* PacketStateBuffer;
			public int32 OpenHandles;
		}
		[CRepr, Packed(1)]
		public struct WHEA_IPF_MCA_DESCRIPTOR
		{
			public uint16 Type;
			public uint8 Enabled;
			public uint8 Reserved;
		}
		[CRepr, Packed(1)]
		public struct WHEA_IPF_CMC_DESCRIPTOR
		{
			public uint16 Type;
			public uint8 Enabled;
			public uint8 Reserved;
		}
		[CRepr, Packed(1)]
		public struct WHEA_IPF_CPE_DESCRIPTOR
		{
			public uint16 Type;
			public uint8 Enabled;
			public uint8 Reserved;
		}
		[CRepr, Packed(1)]
		public struct WHEA_ERROR_SOURCE_DESCRIPTOR
		{
			public uint32 Length;
			public uint32 Version;
			public WHEA_ERROR_SOURCE_TYPE Type;
			public WHEA_ERROR_SOURCE_STATE State;
			public uint32 MaxRawDataLength;
			public uint32 NumRecordsToPreallocate;
			public uint32 MaxSectionsPerRecord;
			public uint32 ErrorSourceId;
			public uint32 PlatformErrorSourceId;
			public uint32 Flags;
			public _Info_e__Union Info;
			
			[CRepr, Union]
			public struct _Info_e__Union
			{
				public WHEA_XPF_MCE_DESCRIPTOR XpfMceDescriptor;
				public WHEA_XPF_CMC_DESCRIPTOR XpfCmcDescriptor;
				public WHEA_XPF_NMI_DESCRIPTOR XpfNmiDescriptor;
				public WHEA_IPF_MCA_DESCRIPTOR IpfMcaDescriptor;
				public WHEA_IPF_CMC_DESCRIPTOR IpfCmcDescriptor;
				public WHEA_IPF_CPE_DESCRIPTOR IpfCpeDescriptor;
				public WHEA_AER_ROOTPORT_DESCRIPTOR AerRootportDescriptor;
				public WHEA_AER_ENDPOINT_DESCRIPTOR AerEndpointDescriptor;
				public WHEA_AER_BRIDGE_DESCRIPTOR AerBridgeDescriptor;
				public WHEA_GENERIC_ERROR_DESCRIPTOR GenErrDescriptor;
				public WHEA_GENERIC_ERROR_DESCRIPTOR_V2 GenErrDescriptorV2;
				public WHEA_DEVICE_DRIVER_DESCRIPTOR DeviceDriverDescriptor;
			}
		}
		[CRepr, Packed(1)]
		public struct IPMI_OS_SEL_RECORD
		{
			public uint32 Signature;
			public uint32 Version;
			public uint32 Length;
			public IPMI_OS_SEL_RECORD_TYPE RecordType;
			public uint32 DataLength;
			public uint8[0] Data;
		}
		[CRepr]
		public struct IMAGE_DEBUG_INFORMATION
		{
			public ListEntry List;
			public uint32 ReservedSize;
			public void* ReservedMappedBase;
			public uint16 ReservedMachine;
			public uint16 ReservedCharacteristics;
			public uint32 ReservedCheckSum;
			public uint32 ImageBase;
			public uint32 SizeOfImage;
			public uint32 ReservedNumberOfSections;
			public IMAGE_SECTION_HEADER* ReservedSections;
			public uint32 ReservedExportedNamesSize;
			public char8* ReservedExportedNames;
			public uint32 ReservedNumberOfFunctionTableEntries;
			public IMAGE_FUNCTION_ENTRY* ReservedFunctionTableEntries;
			public uint32 ReservedLowestFunctionStartingAddress;
			public uint32 ReservedHighestFunctionEndingAddress;
			public uint32 ReservedNumberOfFpoTableEntries;
			public FPO_DATA* ReservedFpoTableEntries;
			public uint32 SizeOfCoffSymbols;
			public IMAGE_COFF_SYMBOLS_HEADER* CoffSymbols;
			public uint32 ReservedSizeOfCodeViewSymbols;
			public void* ReservedCodeViewSymbols;
			public char8* ImageFilePath;
			public char8* ImageFileName;
			public char8* ReservedDebugFilePath;
			public uint32 ReservedTimeDateStamp;
			public IntBool ReservedRomImage;
			public IMAGE_DEBUG_DIRECTORY* ReservedDebugDirectory;
			public uint32 ReservedNumberOfDebugDirectories;
			public uint32 ReservedOriginalFunctionTableBaseAddress;
			public uint32[2] Reserved;
		}
		[CRepr]
		public struct ADDRESS
		{
			public uint32 Offset;
			public uint16 Segment;
			public ADDRESS_MODE Mode;
		}
		[CRepr]
		public struct KDHELP
		{
			public uint32 Thread;
			public uint32 ThCallbackStack;
			public uint32 NextCallback;
			public uint32 FramePointer;
			public uint32 KiCallUserMode;
			public uint32 KeUserCallbackDispatcher;
			public uint32 SystemRangeStart;
			public uint32 ThCallbackBStore;
			public uint32 KiUserExceptionDispatcher;
			public uint32 StackBase;
			public uint32 StackLimit;
			public uint32[5] Reserved;
		}
		[CRepr]
		public struct STACKFRAME
		{
			public ADDRESS AddrPC;
			public ADDRESS AddrReturn;
			public ADDRESS AddrFrame;
			public ADDRESS AddrStack;
			public void* FuncTableEntry;
			public uint32[4] Params;
			public IntBool Far;
			public IntBool Virtual;
			public uint32[3] Reserved;
			public KDHELP KdHelp;
			public ADDRESS AddrBStore;
		}
		[CRepr]
		public struct IMAGEHLP_SYMBOL
		{
			public uint32 SizeOfStruct;
			public uint32 Address;
			public uint32 Size;
			public uint32 Flags;
			public uint32 MaxNameLength;
			public char8[0] Name;
		}
		[CRepr]
		public struct IMAGEHLP_SYMBOL_PACKAGE
		{
			public IMAGEHLP_SYMBOL sym;
			public char8[2001] name;
		}
		[CRepr]
		public struct IMAGEHLP_SYMBOLW
		{
			public uint32 SizeOfStruct;
			public uint32 Address;
			public uint32 Size;
			public uint32 Flags;
			public uint32 MaxNameLength;
			public char16[0] Name;
		}
		[CRepr]
		public struct IMAGEHLP_SYMBOLW_PACKAGE
		{
			public IMAGEHLP_SYMBOLW sym;
			public char16[2001] name;
		}
		[CRepr]
		public struct IMAGEHLP_MODULE
		{
			public uint32 SizeOfStruct;
			public uint32 BaseOfImage;
			public uint32 ImageSize;
			public uint32 TimeDateStamp;
			public uint32 CheckSum;
			public uint32 NumSyms;
			public SYM_TYPE SymType;
			public char8[32] ModuleName;
			public char8[256] ImageName;
			public char8[256] LoadedImageName;
		}
		[CRepr]
		public struct IMAGEHLP_MODULEW
		{
			public uint32 SizeOfStruct;
			public uint32 BaseOfImage;
			public uint32 ImageSize;
			public uint32 TimeDateStamp;
			public uint32 CheckSum;
			public uint32 NumSyms;
			public SYM_TYPE SymType;
			public char16[32] ModuleName;
			public char16[256] ImageName;
			public char16[256] LoadedImageName;
		}
		[CRepr]
		public struct IMAGEHLP_LINE
		{
			public uint32 SizeOfStruct;
			public void* Key;
			public uint32 LineNumber;
			public char8* FileName;
			public uint32 Address;
		}
		[CRepr]
		public struct IMAGEHLP_LINEW
		{
			public uint32 SizeOfStruct;
			public void* Key;
			public uint32 LineNumber;
			public char8* FileName;
			public uint64 Address;
		}
		[CRepr]
		public struct IMAGEHLP_DEFERRED_SYMBOL_LOAD
		{
			public uint32 SizeOfStruct;
			public uint32 BaseOfImage;
			public uint32 CheckSum;
			public uint32 TimeDateStamp;
			public char8[260] FileName;
			public bool Reparse;
			public Handle hFile;
		}
		[CRepr]
		public struct IMAGEHLP_DUPLICATE_SYMBOL
		{
			public uint32 SizeOfStruct;
			public uint32 NumberOfDups;
			public IMAGEHLP_SYMBOL* Symbol;
			public uint32 SelectedSymbol;
		}
		
		// --- COM Class IDs ---
		
		public const Guid CLSID_ProcessDebugManager = .(0x78a51822, 0x51f4, 0x11d0, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
		public const Guid CLSID_DebugHelper = .(0x0bfcc060, 0x8c1d, 0x11d0, 0xac, 0xcd, 0x00, 0xaa, 0x00, 0x60, 0x27, 0x5c);
		public const Guid CLSID_CDebugDocumentHelper = .(0x83b8bca6, 0x687c, 0x11d0, 0xa4, 0x05, 0x00, 0xaa, 0x00, 0x60, 0x27, 0x5c);
		public const Guid CLSID_MachineDebugManager_RETAIL = .(0x0c0a3666, 0x30c9, 0x11d0, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
		public const Guid CLSID_MachineDebugManager_DEBUG = .(0x49769cec, 0x3a55, 0x4bb0, 0xb6, 0x97, 0x88, 0xfe, 0xde, 0x77, 0xe8, 0xea);
		public const Guid CLSID_DefaultDebugSessionProvider = .(0x834128a2, 0x51f4, 0x11d0, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
		
		// --- COM Interfaces ---
		
		[CRepr]
		public struct IDebugAdvanced : IUnknown
		{
			public const new Guid IID = .(0xf2df5f53, 0x071f, 0x47bd, 0x9d, 0xe6, 0x57, 0x34, 0xc3, 0xfe, 0xd6, 0x89);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetThreadContext(void* Context, uint32 ContextSize) mut => VT.GetThreadContext(ref this, Context, ContextSize);
			public HResult SetThreadContext(void* Context, uint32 ContextSize) mut => VT.SetThreadContext(ref this, Context, ContextSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced self, void* Context, uint32 ContextSize) GetThreadContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced self, void* Context, uint32 ContextSize) SetThreadContext;
			}
		}
		[CRepr]
		public struct IDebugAdvanced2 : IUnknown
		{
			public const new Guid IID = .(0x716d14c9, 0x119b, 0x4ba5, 0xaf, 0x1f, 0x08, 0x90, 0xe6, 0x72, 0x41, 0x6a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetThreadContext(void* Context, uint32 ContextSize) mut => VT.GetThreadContext(ref this, Context, ContextSize);
			public HResult SetThreadContext(void* Context, uint32 ContextSize) mut => VT.SetThreadContext(ref this, Context, ContextSize);
			public HResult Request(uint32 Request, void* InBuffer, uint32 InBufferSize, void* OutBuffer, uint32 OutBufferSize, uint32* OutSize) mut => VT.Request(ref this, Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
			public HResult GetSourceFileInformation(uint32 Which, char8* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) mut => VT.GetSourceFileInformation(ref this, Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
			public HResult FindSourceFileAndToken(uint32 StartElement, uint64 ModAddr, char8* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFileAndToken(ref this, StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSymbolInformation(uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, uint8* StringBuffer, uint32 StringBufferSize, uint32* StringSize) mut => VT.GetSymbolInformation(ref this, Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
			public HResult GetSystemObjectInformation(uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) mut => VT.GetSystemObjectInformation(ref this, Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced2 self, void* Context, uint32 ContextSize) GetThreadContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced2 self, void* Context, uint32 ContextSize) SetThreadContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced2 self, uint32 Request, void* InBuffer, uint32 InBufferSize, void* OutBuffer, uint32 OutBufferSize, uint32* OutSize) Request;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced2 self, uint32 Which, char8* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) GetSourceFileInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced2 self, uint32 StartElement, uint64 ModAddr, char8* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFileAndToken;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced2 self, uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, uint8* StringBuffer, uint32 StringBufferSize, uint32* StringSize) GetSymbolInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced2 self, uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) GetSystemObjectInformation;
			}
		}
		[CRepr]
		public struct IDebugAdvanced3 : IUnknown
		{
			public const new Guid IID = .(0xcba4abb4, 0x84c4, 0x444d, 0x87, 0xca, 0xa0, 0x4e, 0x13, 0x28, 0x67, 0x39);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetThreadContext(void* Context, uint32 ContextSize) mut => VT.GetThreadContext(ref this, Context, ContextSize);
			public HResult SetThreadContext(void* Context, uint32 ContextSize) mut => VT.SetThreadContext(ref this, Context, ContextSize);
			public HResult Request(uint32 Request, void* InBuffer, uint32 InBufferSize, void* OutBuffer, uint32 OutBufferSize, uint32* OutSize) mut => VT.Request(ref this, Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
			public HResult GetSourceFileInformation(uint32 Which, char8* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) mut => VT.GetSourceFileInformation(ref this, Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
			public HResult FindSourceFileAndToken(uint32 StartElement, uint64 ModAddr, char8* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFileAndToken(ref this, StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSymbolInformation(uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, uint8* StringBuffer, uint32 StringBufferSize, uint32* StringSize) mut => VT.GetSymbolInformation(ref this, Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
			public HResult GetSystemObjectInformation(uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) mut => VT.GetSystemObjectInformation(ref this, Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
			public HResult GetSourceFileInformationWide(uint32 Which, char16* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) mut => VT.GetSourceFileInformationWide(ref this, Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
			public HResult FindSourceFileAndTokenWide(uint32 StartElement, uint64 ModAddr, char16* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFileAndTokenWide(ref this, StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSymbolInformationWide(uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, char16* StringBuffer, uint32 StringBufferSize, uint32* StringSize) mut => VT.GetSymbolInformationWide(ref this, Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, void* Context, uint32 ContextSize) GetThreadContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, void* Context, uint32 ContextSize) SetThreadContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, uint32 Request, void* InBuffer, uint32 InBufferSize, void* OutBuffer, uint32 OutBufferSize, uint32* OutSize) Request;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, uint32 Which, char8* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) GetSourceFileInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, uint32 StartElement, uint64 ModAddr, char8* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFileAndToken;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, uint8* StringBuffer, uint32 StringBufferSize, uint32* StringSize) GetSymbolInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) GetSystemObjectInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, uint32 Which, char16* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) GetSourceFileInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, uint32 StartElement, uint64 ModAddr, char16* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFileAndTokenWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced3 self, uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, char16* StringBuffer, uint32 StringBufferSize, uint32* StringSize) GetSymbolInformationWide;
			}
		}
		[CRepr]
		public struct IDebugAdvanced4 : IUnknown
		{
			public const new Guid IID = .(0xd1069067, 0x2a65, 0x4bf0, 0xae, 0x97, 0x76, 0x18, 0x4b, 0x67, 0x85, 0x6b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetThreadContext(void* Context, uint32 ContextSize) mut => VT.GetThreadContext(ref this, Context, ContextSize);
			public HResult SetThreadContext(void* Context, uint32 ContextSize) mut => VT.SetThreadContext(ref this, Context, ContextSize);
			public HResult Request(uint32 Request, void* InBuffer, uint32 InBufferSize, void* OutBuffer, uint32 OutBufferSize, uint32* OutSize) mut => VT.Request(ref this, Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
			public HResult GetSourceFileInformation(uint32 Which, char8* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) mut => VT.GetSourceFileInformation(ref this, Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
			public HResult FindSourceFileAndToken(uint32 StartElement, uint64 ModAddr, char8* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFileAndToken(ref this, StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSymbolInformation(uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, uint8* StringBuffer, uint32 StringBufferSize, uint32* StringSize) mut => VT.GetSymbolInformation(ref this, Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
			public HResult GetSystemObjectInformation(uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) mut => VT.GetSystemObjectInformation(ref this, Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
			public HResult GetSourceFileInformationWide(uint32 Which, char16* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) mut => VT.GetSourceFileInformationWide(ref this, Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
			public HResult FindSourceFileAndTokenWide(uint32 StartElement, uint64 ModAddr, char16* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFileAndTokenWide(ref this, StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSymbolInformationWide(uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, char16* StringBuffer, uint32 StringBufferSize, uint32* StringSize) mut => VT.GetSymbolInformationWide(ref this, Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
			public HResult GetSymbolInformationWideEx(uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, char16* StringBuffer, uint32 StringBufferSize, uint32* StringSize, SYMBOL_INFO_EX* pInfoEx) mut => VT.GetSymbolInformationWideEx(ref this, Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize, pInfoEx);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, void* Context, uint32 ContextSize) GetThreadContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, void* Context, uint32 ContextSize) SetThreadContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, uint32 Request, void* InBuffer, uint32 InBufferSize, void* OutBuffer, uint32 OutBufferSize, uint32* OutSize) Request;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, uint32 Which, char8* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) GetSourceFileInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, uint32 StartElement, uint64 ModAddr, char8* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFileAndToken;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, uint8* StringBuffer, uint32 StringBufferSize, uint32* StringSize) GetSymbolInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) GetSystemObjectInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, uint32 Which, char16* SourceFile, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize) GetSourceFileInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, uint32 StartElement, uint64 ModAddr, char16* File, uint32 Flags, void* FileToken, uint32 FileTokenSize, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFileAndTokenWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, char16* StringBuffer, uint32 StringBufferSize, uint32* StringSize) GetSymbolInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAdvanced4 self, uint32 Which, uint64 Arg64, uint32 Arg32, void* Buffer, uint32 BufferSize, uint32* InfoSize, char16* StringBuffer, uint32 StringBufferSize, uint32* StringSize, SYMBOL_INFO_EX* pInfoEx) GetSymbolInformationWideEx;
			}
		}
		[CRepr]
		public struct IDebugBreakpoint : IUnknown
		{
			public const new Guid IID = .(0x5bd9d474, 0x5975, 0x423a, 0xb8, 0x8b, 0x65, 0xa8, 0xe7, 0x11, 0x0e, 0x65);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetId(out uint32 Id) mut => VT.GetId(ref this, out Id);
			public HResult ComGetType(out uint32 BreakType, out uint32 ProcType) mut => VT.ComGetType(ref this, out BreakType, out ProcType);
			public HResult GetAdder(out IDebugClient* Adder) mut => VT.GetAdder(ref this, out Adder);
			public HResult ComGetFlags(out uint32 Flags) mut => VT.ComGetFlags(ref this, out Flags);
			public HResult AddFlags(uint32 Flags) mut => VT.AddFlags(ref this, Flags);
			public HResult RemoveFlags(uint32 Flags) mut => VT.RemoveFlags(ref this, Flags);
			public HResult SetFlags(uint32 Flags) mut => VT.SetFlags(ref this, Flags);
			public HResult GetOffset(out uint64 Offset) mut => VT.GetOffset(ref this, out Offset);
			public HResult SetOffset(uint64 Offset) mut => VT.SetOffset(ref this, Offset);
			public HResult GetDataParameters(out uint32 Size, out uint32 AccessType) mut => VT.GetDataParameters(ref this, out Size, out AccessType);
			public HResult SetDataParameters(uint32 Size, uint32 AccessType) mut => VT.SetDataParameters(ref this, Size, AccessType);
			public HResult GetPassCount(out uint32 Count) mut => VT.GetPassCount(ref this, out Count);
			public HResult SetPassCount(uint32 Count) mut => VT.SetPassCount(ref this, Count);
			public HResult GetCurrentPassCount(out uint32 Count) mut => VT.GetCurrentPassCount(ref this, out Count);
			public HResult GetMatchThreadId(out uint32 Id) mut => VT.GetMatchThreadId(ref this, out Id);
			public HResult SetMatchThreadId(uint32 Thread) mut => VT.SetMatchThreadId(ref this, Thread);
			public HResult GetCommand(uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetCommand(ref this, Buffer, BufferSize, CommandSize);
			public HResult SetCommand(char8* Command) mut => VT.SetCommand(ref this, Command);
			public HResult GetOffsetExpression(uint8* Buffer, uint32 BufferSize, uint32* ExpressionSize) mut => VT.GetOffsetExpression(ref this, Buffer, BufferSize, ExpressionSize);
			public HResult SetOffsetExpression(char8* Expression) mut => VT.SetOffsetExpression(ref this, Expression);
			public HResult GetParameters(out DEBUG_BREAKPOINT_PARAMETERS Params) mut => VT.GetParameters(ref this, out Params);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out uint32 Id) GetId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out uint32 BreakType, out uint32 ProcType) ComGetType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out IDebugClient* Adder) GetAdder;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out uint32 Flags) ComGetFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, uint32 Flags) AddFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, uint32 Flags) RemoveFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, uint32 Flags) SetFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out uint64 Offset) GetOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, uint64 Offset) SetOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out uint32 Size, out uint32 AccessType) GetDataParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, uint32 Size, uint32 AccessType) SetDataParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out uint32 Count) GetPassCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, uint32 Count) SetPassCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out uint32 Count) GetCurrentPassCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out uint32 Id) GetMatchThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, uint32 Thread) SetMatchThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, char8* Command) SetCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, uint8* Buffer, uint32 BufferSize, uint32* ExpressionSize) GetOffsetExpression;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, char8* Expression) SetOffsetExpression;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint self, out DEBUG_BREAKPOINT_PARAMETERS Params) GetParameters;
			}
		}
		[CRepr]
		public struct IDebugBreakpoint2 : IUnknown
		{
			public const new Guid IID = .(0x1b278d20, 0x79f2, 0x426e, 0xa3, 0xf9, 0xc1, 0xdd, 0xf3, 0x75, 0xd4, 0x8e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetId(out uint32 Id) mut => VT.GetId(ref this, out Id);
			public HResult ComGetType(out uint32 BreakType, out uint32 ProcType) mut => VT.ComGetType(ref this, out BreakType, out ProcType);
			public HResult GetAdder(out IDebugClient* Adder) mut => VT.GetAdder(ref this, out Adder);
			public HResult ComGetFlags(out uint32 Flags) mut => VT.ComGetFlags(ref this, out Flags);
			public HResult AddFlags(uint32 Flags) mut => VT.AddFlags(ref this, Flags);
			public HResult RemoveFlags(uint32 Flags) mut => VT.RemoveFlags(ref this, Flags);
			public HResult SetFlags(uint32 Flags) mut => VT.SetFlags(ref this, Flags);
			public HResult GetOffset(out uint64 Offset) mut => VT.GetOffset(ref this, out Offset);
			public HResult SetOffset(uint64 Offset) mut => VT.SetOffset(ref this, Offset);
			public HResult GetDataParameters(out uint32 Size, out uint32 AccessType) mut => VT.GetDataParameters(ref this, out Size, out AccessType);
			public HResult SetDataParameters(uint32 Size, uint32 AccessType) mut => VT.SetDataParameters(ref this, Size, AccessType);
			public HResult GetPassCount(out uint32 Count) mut => VT.GetPassCount(ref this, out Count);
			public HResult SetPassCount(uint32 Count) mut => VT.SetPassCount(ref this, Count);
			public HResult GetCurrentPassCount(out uint32 Count) mut => VT.GetCurrentPassCount(ref this, out Count);
			public HResult GetMatchThreadId(out uint32 Id) mut => VT.GetMatchThreadId(ref this, out Id);
			public HResult SetMatchThreadId(uint32 Thread) mut => VT.SetMatchThreadId(ref this, Thread);
			public HResult GetCommand(uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetCommand(ref this, Buffer, BufferSize, CommandSize);
			public HResult SetCommand(char8* Command) mut => VT.SetCommand(ref this, Command);
			public HResult GetOffsetExpression(uint8* Buffer, uint32 BufferSize, uint32* ExpressionSize) mut => VT.GetOffsetExpression(ref this, Buffer, BufferSize, ExpressionSize);
			public HResult SetOffsetExpression(char8* Expression) mut => VT.SetOffsetExpression(ref this, Expression);
			public HResult GetParameters(out DEBUG_BREAKPOINT_PARAMETERS Params) mut => VT.GetParameters(ref this, out Params);
			public HResult GetCommandWide(char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetCommandWide(ref this, Buffer, BufferSize, CommandSize);
			public HResult SetCommandWide(char16* Command) mut => VT.SetCommandWide(ref this, Command);
			public HResult GetOffsetExpressionWide(char16* Buffer, uint32 BufferSize, uint32* ExpressionSize) mut => VT.GetOffsetExpressionWide(ref this, Buffer, BufferSize, ExpressionSize);
			public HResult SetOffsetExpressionWide(char16* Expression) mut => VT.SetOffsetExpressionWide(ref this, Expression);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out uint32 Id) GetId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out uint32 BreakType, out uint32 ProcType) ComGetType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out IDebugClient* Adder) GetAdder;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out uint32 Flags) ComGetFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, uint32 Flags) AddFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, uint32 Flags) RemoveFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, uint32 Flags) SetFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out uint64 Offset) GetOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, uint64 Offset) SetOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out uint32 Size, out uint32 AccessType) GetDataParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, uint32 Size, uint32 AccessType) SetDataParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out uint32 Count) GetPassCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, uint32 Count) SetPassCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out uint32 Count) GetCurrentPassCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out uint32 Id) GetMatchThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, uint32 Thread) SetMatchThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, char8* Command) SetCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, uint8* Buffer, uint32 BufferSize, uint32* ExpressionSize) GetOffsetExpression;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, char8* Expression) SetOffsetExpression;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, out DEBUG_BREAKPOINT_PARAMETERS Params) GetParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, char16* Command) SetCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, char16* Buffer, uint32 BufferSize, uint32* ExpressionSize) GetOffsetExpressionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint2 self, char16* Expression) SetOffsetExpressionWide;
			}
		}
		[CRepr]
		public struct IDebugBreakpoint3 : IUnknown
		{
			public const new Guid IID = .(0x38f5c249, 0xb448, 0x43bb, 0x98, 0x35, 0x57, 0x9d, 0x4e, 0xc0, 0x22, 0x49);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetId(out uint32 Id) mut => VT.GetId(ref this, out Id);
			public HResult ComGetType(out uint32 BreakType, out uint32 ProcType) mut => VT.ComGetType(ref this, out BreakType, out ProcType);
			public HResult GetAdder(out IDebugClient* Adder) mut => VT.GetAdder(ref this, out Adder);
			public HResult ComGetFlags(out uint32 Flags) mut => VT.ComGetFlags(ref this, out Flags);
			public HResult AddFlags(uint32 Flags) mut => VT.AddFlags(ref this, Flags);
			public HResult RemoveFlags(uint32 Flags) mut => VT.RemoveFlags(ref this, Flags);
			public HResult SetFlags(uint32 Flags) mut => VT.SetFlags(ref this, Flags);
			public HResult GetOffset(out uint64 Offset) mut => VT.GetOffset(ref this, out Offset);
			public HResult SetOffset(uint64 Offset) mut => VT.SetOffset(ref this, Offset);
			public HResult GetDataParameters(out uint32 Size, out uint32 AccessType) mut => VT.GetDataParameters(ref this, out Size, out AccessType);
			public HResult SetDataParameters(uint32 Size, uint32 AccessType) mut => VT.SetDataParameters(ref this, Size, AccessType);
			public HResult GetPassCount(out uint32 Count) mut => VT.GetPassCount(ref this, out Count);
			public HResult SetPassCount(uint32 Count) mut => VT.SetPassCount(ref this, Count);
			public HResult GetCurrentPassCount(out uint32 Count) mut => VT.GetCurrentPassCount(ref this, out Count);
			public HResult GetMatchThreadId(out uint32 Id) mut => VT.GetMatchThreadId(ref this, out Id);
			public HResult SetMatchThreadId(uint32 Thread) mut => VT.SetMatchThreadId(ref this, Thread);
			public HResult GetCommand(uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetCommand(ref this, Buffer, BufferSize, CommandSize);
			public HResult SetCommand(char8* Command) mut => VT.SetCommand(ref this, Command);
			public HResult GetOffsetExpression(uint8* Buffer, uint32 BufferSize, uint32* ExpressionSize) mut => VT.GetOffsetExpression(ref this, Buffer, BufferSize, ExpressionSize);
			public HResult SetOffsetExpression(char8* Expression) mut => VT.SetOffsetExpression(ref this, Expression);
			public HResult GetParameters(out DEBUG_BREAKPOINT_PARAMETERS Params) mut => VT.GetParameters(ref this, out Params);
			public HResult GetCommandWide(char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetCommandWide(ref this, Buffer, BufferSize, CommandSize);
			public HResult SetCommandWide(char16* Command) mut => VT.SetCommandWide(ref this, Command);
			public HResult GetOffsetExpressionWide(char16* Buffer, uint32 BufferSize, uint32* ExpressionSize) mut => VT.GetOffsetExpressionWide(ref this, Buffer, BufferSize, ExpressionSize);
			public HResult SetOffsetExpressionWide(char16* Expression) mut => VT.SetOffsetExpressionWide(ref this, Expression);
			public HResult GetGuid(out Guid Guid) mut => VT.GetGuid(ref this, out Guid);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out uint32 Id) GetId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out uint32 BreakType, out uint32 ProcType) ComGetType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out IDebugClient* Adder) GetAdder;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out uint32 Flags) ComGetFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, uint32 Flags) AddFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, uint32 Flags) RemoveFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, uint32 Flags) SetFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out uint64 Offset) GetOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, uint64 Offset) SetOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out uint32 Size, out uint32 AccessType) GetDataParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, uint32 Size, uint32 AccessType) SetDataParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out uint32 Count) GetPassCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, uint32 Count) SetPassCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out uint32 Count) GetCurrentPassCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out uint32 Id) GetMatchThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, uint32 Thread) SetMatchThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, char8* Command) SetCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, uint8* Buffer, uint32 BufferSize, uint32* ExpressionSize) GetOffsetExpression;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, char8* Expression) SetOffsetExpression;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out DEBUG_BREAKPOINT_PARAMETERS Params) GetParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, char16* Command) SetCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, char16* Buffer, uint32 BufferSize, uint32* ExpressionSize) GetOffsetExpressionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, char16* Expression) SetOffsetExpressionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugBreakpoint3 self, out Guid Guid) GetGuid;
			}
		}
		[CRepr]
		public struct IDebugClient : IUnknown
		{
			public const new Guid IID = .(0x27fe5639, 0x8407, 0x4f47, 0x83, 0x64, 0xee, 0x11, 0x8f, 0xb0, 0x8a, 0xc8);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AttachKernel(uint32 Flags, char8* ConnectOptions) mut => VT.AttachKernel(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptions(uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptions(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptions(char8* Options) mut => VT.SetKernelConnectionOptions(ref this, Options);
			public HResult StartProcessServer(uint32 Flags, char8* Options, void* Reserved) mut => VT.StartProcessServer(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServer(char8* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServer(ref this, RemoteOptions, out Server);
			public HResult DisconnectProcessServer(uint64 Server) mut => VT.DisconnectProcessServer(ref this, Server);
			public HResult GetRunningProcessSystemIds(uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) mut => VT.GetRunningProcessSystemIds(ref this, Server, Ids, Count, ActualCount);
			public HResult GetRunningProcessSystemIdByExecutableName(uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableName(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescription(uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescription(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult AttachProcess(uint64 Server, uint32 ProcessId, uint32 AttachFlags) mut => VT.AttachProcess(ref this, Server, ProcessId, AttachFlags);
			public HResult CreateProcessA(uint64 Server, char8* CommandLine, uint32 CreateFlags) mut => VT._CreateProcessA(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttach(uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult GetProcessOptions(out uint32 Options) mut => VT.GetProcessOptions(ref this, out Options);
			public HResult AddProcessOptions(uint32 Options) mut => VT.AddProcessOptions(ref this, Options);
			public HResult RemoveProcessOptions(uint32 Options) mut => VT.RemoveProcessOptions(ref this, Options);
			public HResult SetProcessOptions(uint32 Options) mut => VT.SetProcessOptions(ref this, Options);
			public HResult OpenDumpFile(char8* DumpFile) mut => VT.OpenDumpFile(ref this, DumpFile);
			public HResult WriteDumpFile(char8* DumpFile, uint32 Qualifier) mut => VT.WriteDumpFile(ref this, DumpFile, Qualifier);
			public HResult ConnectSession(uint32 Flags, uint32 HistoryLimit) mut => VT.ConnectSession(ref this, Flags, HistoryLimit);
			public HResult StartServer(char8* Options) mut => VT.StartServer(ref this, Options);
			public HResult OutputServers(uint32 OutputControl, char8* Machine, uint32 Flags) mut => VT.OutputServers(ref this, OutputControl, Machine, Flags);
			public HResult TerminateProcesses() mut => VT.TerminateProcesses(ref this);
			public HResult DetachProcesses() mut => VT.DetachProcesses(ref this);
			public HResult EndSession(uint32 Flags) mut => VT.EndSession(ref this, Flags);
			public HResult GetExitCode(out uint32 Code) mut => VT.GetExitCode(ref this, out Code);
			public HResult DispatchCallbacks(uint32 Timeout) mut => VT.DispatchCallbacks(ref this, Timeout);
			public HResult ExitDispatch(ref IDebugClient Client) mut => VT.ExitDispatch(ref this, ref Client);
			public HResult CreateClient(out IDebugClient* Client) mut => VT.CreateClient(ref this, out Client);
			public HResult GetInputCallbacks(out IDebugInputCallbacks* Callbacks) mut => VT.GetInputCallbacks(ref this, out Callbacks);
			public HResult SetInputCallbacks(IDebugInputCallbacks* Callbacks) mut => VT.SetInputCallbacks(ref this, Callbacks);
			public HResult GetOutputCallbacks(out IDebugOutputCallbacks* Callbacks) mut => VT.GetOutputCallbacks(ref this, out Callbacks);
			public HResult SetOutputCallbacks(IDebugOutputCallbacks* Callbacks) mut => VT.SetOutputCallbacks(ref this, Callbacks);
			public HResult GetOutputMask(out uint32 Mask) mut => VT.GetOutputMask(ref this, out Mask);
			public HResult SetOutputMask(uint32 Mask) mut => VT.SetOutputMask(ref this, Mask);
			public HResult GetOtherOutputMask(ref IDebugClient Client, out uint32 Mask) mut => VT.GetOtherOutputMask(ref this, ref Client, out Mask);
			public HResult SetOtherOutputMask(ref IDebugClient Client, uint32 Mask) mut => VT.SetOtherOutputMask(ref this, ref Client, Mask);
			public HResult GetOutputWidth(out uint32 Columns) mut => VT.GetOutputWidth(ref this, out Columns);
			public HResult SetOutputWidth(uint32 Columns) mut => VT.SetOutputWidth(ref this, Columns);
			public HResult GetOutputLinePrefix(uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefix(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefix(char8* Prefix) mut => VT.SetOutputLinePrefix(ref this, Prefix);
			public HResult GetIdentity(uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentity(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentity(uint32 OutputControl, uint32 Flags, char8* Format) mut => VT.OutputIdentity(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacks(out IDebugEventCallbacks* Callbacks) mut => VT.GetEventCallbacks(ref this, out Callbacks);
			public HResult SetEventCallbacks(IDebugEventCallbacks* Callbacks) mut => VT.SetEventCallbacks(ref this, Callbacks);
			public HResult FlushCallbacks() mut => VT.FlushCallbacks(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Flags, char8* ConnectOptions) AttachKernel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, char8* Options) SetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Flags, char8* Options, void* Reserved) StartProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, char8* RemoteOptions, out uint64 Server) ConnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint64 Server) DisconnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) GetRunningProcessSystemIds;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint64 Server, uint32 ProcessId, uint32 AttachFlags) AttachProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint64 Server, char8* CommandLine, uint32 CreateFlags) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, out uint32 Options) GetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Options) AddProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Options) RemoveProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Options) SetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, char8* DumpFile) OpenDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, char8* DumpFile, uint32 Qualifier) WriteDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Flags, uint32 HistoryLimit) ConnectSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, char8* Options) StartServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 OutputControl, char8* Machine, uint32 Flags) OutputServers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self) TerminateProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self) DetachProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Flags) EndSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, out uint32 Code) GetExitCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Timeout) DispatchCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, ref IDebugClient Client) ExitDispatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, out IDebugClient* Client) CreateClient;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, out IDebugInputCallbacks* Callbacks) GetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, IDebugInputCallbacks* Callbacks) SetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, out IDebugOutputCallbacks* Callbacks) GetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, IDebugOutputCallbacks* Callbacks) SetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, out uint32 Mask) GetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Mask) SetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, ref IDebugClient Client, out uint32 Mask) GetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, ref IDebugClient Client, uint32 Mask) SetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, out uint32 Columns) GetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 Columns) SetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, char8* Prefix) SetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, uint32 OutputControl, uint32 Flags, char8* Format) OutputIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, out IDebugEventCallbacks* Callbacks) GetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self, IDebugEventCallbacks* Callbacks) SetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient self) FlushCallbacks;
			}
		}
		[CRepr]
		public struct IDebugClient2 : IUnknown
		{
			public const new Guid IID = .(0xedbed635, 0x372e, 0x4dab, 0xbb, 0xfe, 0xed, 0x0d, 0x2f, 0x63, 0xbe, 0x81);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AttachKernel(uint32 Flags, char8* ConnectOptions) mut => VT.AttachKernel(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptions(uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptions(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptions(char8* Options) mut => VT.SetKernelConnectionOptions(ref this, Options);
			public HResult StartProcessServer(uint32 Flags, char8* Options, void* Reserved) mut => VT.StartProcessServer(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServer(char8* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServer(ref this, RemoteOptions, out Server);
			public HResult DisconnectProcessServer(uint64 Server) mut => VT.DisconnectProcessServer(ref this, Server);
			public HResult GetRunningProcessSystemIds(uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) mut => VT.GetRunningProcessSystemIds(ref this, Server, Ids, Count, ActualCount);
			public HResult GetRunningProcessSystemIdByExecutableName(uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableName(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescription(uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescription(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult AttachProcess(uint64 Server, uint32 ProcessId, uint32 AttachFlags) mut => VT.AttachProcess(ref this, Server, ProcessId, AttachFlags);
			public HResult CreateProcessA(uint64 Server, char8* CommandLine, uint32 CreateFlags) mut => VT._CreateProcessA(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttach(uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult GetProcessOptions(out uint32 Options) mut => VT.GetProcessOptions(ref this, out Options);
			public HResult AddProcessOptions(uint32 Options) mut => VT.AddProcessOptions(ref this, Options);
			public HResult RemoveProcessOptions(uint32 Options) mut => VT.RemoveProcessOptions(ref this, Options);
			public HResult SetProcessOptions(uint32 Options) mut => VT.SetProcessOptions(ref this, Options);
			public HResult OpenDumpFile(char8* DumpFile) mut => VT.OpenDumpFile(ref this, DumpFile);
			public HResult WriteDumpFile(char8* DumpFile, uint32 Qualifier) mut => VT.WriteDumpFile(ref this, DumpFile, Qualifier);
			public HResult ConnectSession(uint32 Flags, uint32 HistoryLimit) mut => VT.ConnectSession(ref this, Flags, HistoryLimit);
			public HResult StartServer(char8* Options) mut => VT.StartServer(ref this, Options);
			public HResult OutputServers(uint32 OutputControl, char8* Machine, uint32 Flags) mut => VT.OutputServers(ref this, OutputControl, Machine, Flags);
			public HResult TerminateProcesses() mut => VT.TerminateProcesses(ref this);
			public HResult DetachProcesses() mut => VT.DetachProcesses(ref this);
			public HResult EndSession(uint32 Flags) mut => VT.EndSession(ref this, Flags);
			public HResult GetExitCode(out uint32 Code) mut => VT.GetExitCode(ref this, out Code);
			public HResult DispatchCallbacks(uint32 Timeout) mut => VT.DispatchCallbacks(ref this, Timeout);
			public HResult ExitDispatch(ref IDebugClient Client) mut => VT.ExitDispatch(ref this, ref Client);
			public HResult CreateClient(out IDebugClient* Client) mut => VT.CreateClient(ref this, out Client);
			public HResult GetInputCallbacks(out IDebugInputCallbacks* Callbacks) mut => VT.GetInputCallbacks(ref this, out Callbacks);
			public HResult SetInputCallbacks(IDebugInputCallbacks* Callbacks) mut => VT.SetInputCallbacks(ref this, Callbacks);
			public HResult GetOutputCallbacks(out IDebugOutputCallbacks* Callbacks) mut => VT.GetOutputCallbacks(ref this, out Callbacks);
			public HResult SetOutputCallbacks(IDebugOutputCallbacks* Callbacks) mut => VT.SetOutputCallbacks(ref this, Callbacks);
			public HResult GetOutputMask(out uint32 Mask) mut => VT.GetOutputMask(ref this, out Mask);
			public HResult SetOutputMask(uint32 Mask) mut => VT.SetOutputMask(ref this, Mask);
			public HResult GetOtherOutputMask(ref IDebugClient Client, out uint32 Mask) mut => VT.GetOtherOutputMask(ref this, ref Client, out Mask);
			public HResult SetOtherOutputMask(ref IDebugClient Client, uint32 Mask) mut => VT.SetOtherOutputMask(ref this, ref Client, Mask);
			public HResult GetOutputWidth(out uint32 Columns) mut => VT.GetOutputWidth(ref this, out Columns);
			public HResult SetOutputWidth(uint32 Columns) mut => VT.SetOutputWidth(ref this, Columns);
			public HResult GetOutputLinePrefix(uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefix(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefix(char8* Prefix) mut => VT.SetOutputLinePrefix(ref this, Prefix);
			public HResult GetIdentity(uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentity(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentity(uint32 OutputControl, uint32 Flags, char8* Format) mut => VT.OutputIdentity(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacks(out IDebugEventCallbacks* Callbacks) mut => VT.GetEventCallbacks(ref this, out Callbacks);
			public HResult SetEventCallbacks(IDebugEventCallbacks* Callbacks) mut => VT.SetEventCallbacks(ref this, Callbacks);
			public HResult FlushCallbacks() mut => VT.FlushCallbacks(ref this);
			public HResult WriteDumpFile2(char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) mut => VT.WriteDumpFile2(ref this, DumpFile, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFile(char8* InfoFile, uint32 Type) mut => VT.AddDumpInformationFile(ref this, InfoFile, Type);
			public HResult EndProcessServer(uint64 Server) mut => VT.EndProcessServer(ref this, Server);
			public HResult WaitForProcessServerEnd(uint32 Timeout) mut => VT.WaitForProcessServerEnd(ref this, Timeout);
			public HResult IsKernelDebuggerEnabled() mut => VT.IsKernelDebuggerEnabled(ref this);
			public HResult TerminateCurrentProcess() mut => VT.TerminateCurrentProcess(ref this);
			public HResult DetachCurrentProcess() mut => VT.DetachCurrentProcess(ref this);
			public HResult AbandonCurrentProcess() mut => VT.AbandonCurrentProcess(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Flags, char8* ConnectOptions) AttachKernel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, char8* Options) SetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Flags, char8* Options, void* Reserved) StartProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, char8* RemoteOptions, out uint64 Server) ConnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint64 Server) DisconnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) GetRunningProcessSystemIds;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint64 Server, uint32 ProcessId, uint32 AttachFlags) AttachProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint64 Server, char8* CommandLine, uint32 CreateFlags) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, out uint32 Options) GetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Options) AddProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Options) RemoveProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Options) SetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, char8* DumpFile) OpenDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, char8* DumpFile, uint32 Qualifier) WriteDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Flags, uint32 HistoryLimit) ConnectSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, char8* Options) StartServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 OutputControl, char8* Machine, uint32 Flags) OutputServers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self) TerminateProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self) DetachProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Flags) EndSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, out uint32 Code) GetExitCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Timeout) DispatchCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, ref IDebugClient Client) ExitDispatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, out IDebugClient* Client) CreateClient;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, out IDebugInputCallbacks* Callbacks) GetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, IDebugInputCallbacks* Callbacks) SetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, out IDebugOutputCallbacks* Callbacks) GetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, IDebugOutputCallbacks* Callbacks) SetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, out uint32 Mask) GetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Mask) SetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, ref IDebugClient Client, out uint32 Mask) GetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, ref IDebugClient Client, uint32 Mask) SetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, out uint32 Columns) GetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Columns) SetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, char8* Prefix) SetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 OutputControl, uint32 Flags, char8* Format) OutputIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, out IDebugEventCallbacks* Callbacks) GetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, IDebugEventCallbacks* Callbacks) SetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self) FlushCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) WriteDumpFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, char8* InfoFile, uint32 Type) AddDumpInformationFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint64 Server) EndProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self, uint32 Timeout) WaitForProcessServerEnd;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self) IsKernelDebuggerEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self) TerminateCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self) DetachCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient2 self) AbandonCurrentProcess;
			}
		}
		[CRepr]
		public struct IDebugClient3 : IUnknown
		{
			public const new Guid IID = .(0xdd492d7f, 0x71b8, 0x4ad6, 0xa8, 0xdc, 0x1c, 0x88, 0x74, 0x79, 0xff, 0x91);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AttachKernel(uint32 Flags, char8* ConnectOptions) mut => VT.AttachKernel(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptions(uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptions(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptions(char8* Options) mut => VT.SetKernelConnectionOptions(ref this, Options);
			public HResult StartProcessServer(uint32 Flags, char8* Options, void* Reserved) mut => VT.StartProcessServer(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServer(char8* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServer(ref this, RemoteOptions, out Server);
			public HResult DisconnectProcessServer(uint64 Server) mut => VT.DisconnectProcessServer(ref this, Server);
			public HResult GetRunningProcessSystemIds(uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) mut => VT.GetRunningProcessSystemIds(ref this, Server, Ids, Count, ActualCount);
			public HResult GetRunningProcessSystemIdByExecutableName(uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableName(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescription(uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescription(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult AttachProcess(uint64 Server, uint32 ProcessId, uint32 AttachFlags) mut => VT.AttachProcess(ref this, Server, ProcessId, AttachFlags);
			public HResult CreateProcessA(uint64 Server, char8* CommandLine, uint32 CreateFlags) mut => VT._CreateProcessA(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttach(uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult GetProcessOptions(out uint32 Options) mut => VT.GetProcessOptions(ref this, out Options);
			public HResult AddProcessOptions(uint32 Options) mut => VT.AddProcessOptions(ref this, Options);
			public HResult RemoveProcessOptions(uint32 Options) mut => VT.RemoveProcessOptions(ref this, Options);
			public HResult SetProcessOptions(uint32 Options) mut => VT.SetProcessOptions(ref this, Options);
			public HResult OpenDumpFile(char8* DumpFile) mut => VT.OpenDumpFile(ref this, DumpFile);
			public HResult WriteDumpFile(char8* DumpFile, uint32 Qualifier) mut => VT.WriteDumpFile(ref this, DumpFile, Qualifier);
			public HResult ConnectSession(uint32 Flags, uint32 HistoryLimit) mut => VT.ConnectSession(ref this, Flags, HistoryLimit);
			public HResult StartServer(char8* Options) mut => VT.StartServer(ref this, Options);
			public HResult OutputServers(uint32 OutputControl, char8* Machine, uint32 Flags) mut => VT.OutputServers(ref this, OutputControl, Machine, Flags);
			public HResult TerminateProcesses() mut => VT.TerminateProcesses(ref this);
			public HResult DetachProcesses() mut => VT.DetachProcesses(ref this);
			public HResult EndSession(uint32 Flags) mut => VT.EndSession(ref this, Flags);
			public HResult GetExitCode(out uint32 Code) mut => VT.GetExitCode(ref this, out Code);
			public HResult DispatchCallbacks(uint32 Timeout) mut => VT.DispatchCallbacks(ref this, Timeout);
			public HResult ExitDispatch(ref IDebugClient Client) mut => VT.ExitDispatch(ref this, ref Client);
			public HResult CreateClient(out IDebugClient* Client) mut => VT.CreateClient(ref this, out Client);
			public HResult GetInputCallbacks(out IDebugInputCallbacks* Callbacks) mut => VT.GetInputCallbacks(ref this, out Callbacks);
			public HResult SetInputCallbacks(IDebugInputCallbacks* Callbacks) mut => VT.SetInputCallbacks(ref this, Callbacks);
			public HResult GetOutputCallbacks(out IDebugOutputCallbacks* Callbacks) mut => VT.GetOutputCallbacks(ref this, out Callbacks);
			public HResult SetOutputCallbacks(IDebugOutputCallbacks* Callbacks) mut => VT.SetOutputCallbacks(ref this, Callbacks);
			public HResult GetOutputMask(out uint32 Mask) mut => VT.GetOutputMask(ref this, out Mask);
			public HResult SetOutputMask(uint32 Mask) mut => VT.SetOutputMask(ref this, Mask);
			public HResult GetOtherOutputMask(ref IDebugClient Client, out uint32 Mask) mut => VT.GetOtherOutputMask(ref this, ref Client, out Mask);
			public HResult SetOtherOutputMask(ref IDebugClient Client, uint32 Mask) mut => VT.SetOtherOutputMask(ref this, ref Client, Mask);
			public HResult GetOutputWidth(out uint32 Columns) mut => VT.GetOutputWidth(ref this, out Columns);
			public HResult SetOutputWidth(uint32 Columns) mut => VT.SetOutputWidth(ref this, Columns);
			public HResult GetOutputLinePrefix(uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefix(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefix(char8* Prefix) mut => VT.SetOutputLinePrefix(ref this, Prefix);
			public HResult GetIdentity(uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentity(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentity(uint32 OutputControl, uint32 Flags, char8* Format) mut => VT.OutputIdentity(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacks(out IDebugEventCallbacks* Callbacks) mut => VT.GetEventCallbacks(ref this, out Callbacks);
			public HResult SetEventCallbacks(IDebugEventCallbacks* Callbacks) mut => VT.SetEventCallbacks(ref this, Callbacks);
			public HResult FlushCallbacks() mut => VT.FlushCallbacks(ref this);
			public HResult WriteDumpFile2(char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) mut => VT.WriteDumpFile2(ref this, DumpFile, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFile(char8* InfoFile, uint32 Type) mut => VT.AddDumpInformationFile(ref this, InfoFile, Type);
			public HResult EndProcessServer(uint64 Server) mut => VT.EndProcessServer(ref this, Server);
			public HResult WaitForProcessServerEnd(uint32 Timeout) mut => VT.WaitForProcessServerEnd(ref this, Timeout);
			public HResult IsKernelDebuggerEnabled() mut => VT.IsKernelDebuggerEnabled(ref this);
			public HResult TerminateCurrentProcess() mut => VT.TerminateCurrentProcess(ref this);
			public HResult DetachCurrentProcess() mut => VT.DetachCurrentProcess(ref this);
			public HResult AbandonCurrentProcess() mut => VT.AbandonCurrentProcess(ref this);
			public HResult GetRunningProcessSystemIdByExecutableNameWide(uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableNameWide(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescriptionWide(uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescriptionWide(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult CreateProcessWide(uint64 Server, char16* CommandLine, uint32 CreateFlags) mut => VT.CreateProcessWide(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttachWide(uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttachWide(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Flags, char8* ConnectOptions) AttachKernel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, char8* Options) SetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Flags, char8* Options, void* Reserved) StartProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, char8* RemoteOptions, out uint64 Server) ConnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server) DisconnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) GetRunningProcessSystemIds;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, uint32 ProcessId, uint32 AttachFlags) AttachProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, char8* CommandLine, uint32 CreateFlags) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, out uint32 Options) GetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Options) AddProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Options) RemoveProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Options) SetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, char8* DumpFile) OpenDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, char8* DumpFile, uint32 Qualifier) WriteDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Flags, uint32 HistoryLimit) ConnectSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, char8* Options) StartServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 OutputControl, char8* Machine, uint32 Flags) OutputServers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self) TerminateProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self) DetachProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Flags) EndSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, out uint32 Code) GetExitCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Timeout) DispatchCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, ref IDebugClient Client) ExitDispatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, out IDebugClient* Client) CreateClient;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, out IDebugInputCallbacks* Callbacks) GetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, IDebugInputCallbacks* Callbacks) SetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, out IDebugOutputCallbacks* Callbacks) GetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, IDebugOutputCallbacks* Callbacks) SetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, out uint32 Mask) GetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Mask) SetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, ref IDebugClient Client, out uint32 Mask) GetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, ref IDebugClient Client, uint32 Mask) SetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, out uint32 Columns) GetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Columns) SetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, char8* Prefix) SetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 OutputControl, uint32 Flags, char8* Format) OutputIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, out IDebugEventCallbacks* Callbacks) GetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, IDebugEventCallbacks* Callbacks) SetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self) FlushCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) WriteDumpFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, char8* InfoFile, uint32 Type) AddDumpInformationFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server) EndProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint32 Timeout) WaitForProcessServerEnd;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self) IsKernelDebuggerEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self) TerminateCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self) DetachCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self) AbandonCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, char16* CommandLine, uint32 CreateFlags) CreateProcessWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient3 self, uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttachWide;
			}
		}
		[CRepr]
		public struct IDebugClient4 : IUnknown
		{
			public const new Guid IID = .(0xca83c3de, 0x5089, 0x4cf8, 0x93, 0xc8, 0xd8, 0x92, 0x38, 0x7f, 0x2a, 0x5e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AttachKernel(uint32 Flags, char8* ConnectOptions) mut => VT.AttachKernel(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptions(uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptions(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptions(char8* Options) mut => VT.SetKernelConnectionOptions(ref this, Options);
			public HResult StartProcessServer(uint32 Flags, char8* Options, void* Reserved) mut => VT.StartProcessServer(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServer(char8* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServer(ref this, RemoteOptions, out Server);
			public HResult DisconnectProcessServer(uint64 Server) mut => VT.DisconnectProcessServer(ref this, Server);
			public HResult GetRunningProcessSystemIds(uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) mut => VT.GetRunningProcessSystemIds(ref this, Server, Ids, Count, ActualCount);
			public HResult GetRunningProcessSystemIdByExecutableName(uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableName(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescription(uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescription(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult AttachProcess(uint64 Server, uint32 ProcessId, uint32 AttachFlags) mut => VT.AttachProcess(ref this, Server, ProcessId, AttachFlags);
			public HResult CreateProcessA(uint64 Server, char8* CommandLine, uint32 CreateFlags) mut => VT._CreateProcessA(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttach(uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult GetProcessOptions(out uint32 Options) mut => VT.GetProcessOptions(ref this, out Options);
			public HResult AddProcessOptions(uint32 Options) mut => VT.AddProcessOptions(ref this, Options);
			public HResult RemoveProcessOptions(uint32 Options) mut => VT.RemoveProcessOptions(ref this, Options);
			public HResult SetProcessOptions(uint32 Options) mut => VT.SetProcessOptions(ref this, Options);
			public HResult OpenDumpFile(char8* DumpFile) mut => VT.OpenDumpFile(ref this, DumpFile);
			public HResult WriteDumpFile(char8* DumpFile, uint32 Qualifier) mut => VT.WriteDumpFile(ref this, DumpFile, Qualifier);
			public HResult ConnectSession(uint32 Flags, uint32 HistoryLimit) mut => VT.ConnectSession(ref this, Flags, HistoryLimit);
			public HResult StartServer(char8* Options) mut => VT.StartServer(ref this, Options);
			public HResult OutputServers(uint32 OutputControl, char8* Machine, uint32 Flags) mut => VT.OutputServers(ref this, OutputControl, Machine, Flags);
			public HResult TerminateProcesses() mut => VT.TerminateProcesses(ref this);
			public HResult DetachProcesses() mut => VT.DetachProcesses(ref this);
			public HResult EndSession(uint32 Flags) mut => VT.EndSession(ref this, Flags);
			public HResult GetExitCode(out uint32 Code) mut => VT.GetExitCode(ref this, out Code);
			public HResult DispatchCallbacks(uint32 Timeout) mut => VT.DispatchCallbacks(ref this, Timeout);
			public HResult ExitDispatch(ref IDebugClient Client) mut => VT.ExitDispatch(ref this, ref Client);
			public HResult CreateClient(out IDebugClient* Client) mut => VT.CreateClient(ref this, out Client);
			public HResult GetInputCallbacks(out IDebugInputCallbacks* Callbacks) mut => VT.GetInputCallbacks(ref this, out Callbacks);
			public HResult SetInputCallbacks(IDebugInputCallbacks* Callbacks) mut => VT.SetInputCallbacks(ref this, Callbacks);
			public HResult GetOutputCallbacks(out IDebugOutputCallbacks* Callbacks) mut => VT.GetOutputCallbacks(ref this, out Callbacks);
			public HResult SetOutputCallbacks(IDebugOutputCallbacks* Callbacks) mut => VT.SetOutputCallbacks(ref this, Callbacks);
			public HResult GetOutputMask(out uint32 Mask) mut => VT.GetOutputMask(ref this, out Mask);
			public HResult SetOutputMask(uint32 Mask) mut => VT.SetOutputMask(ref this, Mask);
			public HResult GetOtherOutputMask(ref IDebugClient Client, out uint32 Mask) mut => VT.GetOtherOutputMask(ref this, ref Client, out Mask);
			public HResult SetOtherOutputMask(ref IDebugClient Client, uint32 Mask) mut => VT.SetOtherOutputMask(ref this, ref Client, Mask);
			public HResult GetOutputWidth(out uint32 Columns) mut => VT.GetOutputWidth(ref this, out Columns);
			public HResult SetOutputWidth(uint32 Columns) mut => VT.SetOutputWidth(ref this, Columns);
			public HResult GetOutputLinePrefix(uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefix(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefix(char8* Prefix) mut => VT.SetOutputLinePrefix(ref this, Prefix);
			public HResult GetIdentity(uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentity(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentity(uint32 OutputControl, uint32 Flags, char8* Format) mut => VT.OutputIdentity(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacks(out IDebugEventCallbacks* Callbacks) mut => VT.GetEventCallbacks(ref this, out Callbacks);
			public HResult SetEventCallbacks(IDebugEventCallbacks* Callbacks) mut => VT.SetEventCallbacks(ref this, Callbacks);
			public HResult FlushCallbacks() mut => VT.FlushCallbacks(ref this);
			public HResult WriteDumpFile2(char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) mut => VT.WriteDumpFile2(ref this, DumpFile, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFile(char8* InfoFile, uint32 Type) mut => VT.AddDumpInformationFile(ref this, InfoFile, Type);
			public HResult EndProcessServer(uint64 Server) mut => VT.EndProcessServer(ref this, Server);
			public HResult WaitForProcessServerEnd(uint32 Timeout) mut => VT.WaitForProcessServerEnd(ref this, Timeout);
			public HResult IsKernelDebuggerEnabled() mut => VT.IsKernelDebuggerEnabled(ref this);
			public HResult TerminateCurrentProcess() mut => VT.TerminateCurrentProcess(ref this);
			public HResult DetachCurrentProcess() mut => VT.DetachCurrentProcess(ref this);
			public HResult AbandonCurrentProcess() mut => VT.AbandonCurrentProcess(ref this);
			public HResult GetRunningProcessSystemIdByExecutableNameWide(uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableNameWide(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescriptionWide(uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescriptionWide(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult CreateProcessWide(uint64 Server, char16* CommandLine, uint32 CreateFlags) mut => VT.CreateProcessWide(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttachWide(uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttachWide(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult OpenDumpFileWide(char16* FileName, uint64 FileHandle) mut => VT.OpenDumpFileWide(ref this, FileName, FileHandle);
			public HResult WriteDumpFileWide(char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) mut => VT.WriteDumpFileWide(ref this, FileName, FileHandle, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFileWide(char16* FileName, uint64 FileHandle, uint32 Type) mut => VT.AddDumpInformationFileWide(ref this, FileName, FileHandle, Type);
			public HResult GetNumberDumpFiles(out uint32 Number) mut => VT.GetNumberDumpFiles(ref this, out Number);
			public HResult GetDumpFile(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFile(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);
			public HResult GetDumpFileWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFileWide(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Flags, char8* ConnectOptions) AttachKernel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char8* Options) SetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Flags, char8* Options, void* Reserved) StartProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char8* RemoteOptions, out uint64 Server) ConnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server) DisconnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) GetRunningProcessSystemIds;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, uint32 ProcessId, uint32 AttachFlags) AttachProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, char8* CommandLine, uint32 CreateFlags) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, out uint32 Options) GetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Options) AddProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Options) RemoveProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Options) SetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char8* DumpFile) OpenDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char8* DumpFile, uint32 Qualifier) WriteDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Flags, uint32 HistoryLimit) ConnectSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char8* Options) StartServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 OutputControl, char8* Machine, uint32 Flags) OutputServers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self) TerminateProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self) DetachProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Flags) EndSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, out uint32 Code) GetExitCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Timeout) DispatchCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, ref IDebugClient Client) ExitDispatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, out IDebugClient* Client) CreateClient;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, out IDebugInputCallbacks* Callbacks) GetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, IDebugInputCallbacks* Callbacks) SetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, out IDebugOutputCallbacks* Callbacks) GetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, IDebugOutputCallbacks* Callbacks) SetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, out uint32 Mask) GetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Mask) SetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, ref IDebugClient Client, out uint32 Mask) GetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, ref IDebugClient Client, uint32 Mask) SetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, out uint32 Columns) GetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Columns) SetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char8* Prefix) SetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 OutputControl, uint32 Flags, char8* Format) OutputIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, out IDebugEventCallbacks* Callbacks) GetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, IDebugEventCallbacks* Callbacks) SetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self) FlushCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) WriteDumpFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char8* InfoFile, uint32 Type) AddDumpInformationFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server) EndProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Timeout) WaitForProcessServerEnd;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self) IsKernelDebuggerEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self) TerminateCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self) DetachCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self) AbandonCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, char16* CommandLine, uint32 CreateFlags) CreateProcessWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttachWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char16* FileName, uint64 FileHandle) OpenDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) WriteDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, char16* FileName, uint64 FileHandle, uint32 Type) AddDumpInformationFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, out uint32 Number) GetNumberDumpFiles;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient4 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFileWide;
			}
		}
		[CRepr]
		public struct IDebugClient5 : IUnknown
		{
			public const new Guid IID = .(0xe3acb9d7, 0x7ec2, 0x4f0c, 0xa0, 0xda, 0xe8, 0x1e, 0x0c, 0xbb, 0xe6, 0x28);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AttachKernel(uint32 Flags, char8* ConnectOptions) mut => VT.AttachKernel(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptions(uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptions(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptions(char8* Options) mut => VT.SetKernelConnectionOptions(ref this, Options);
			public HResult StartProcessServer(uint32 Flags, char8* Options, void* Reserved) mut => VT.StartProcessServer(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServer(char8* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServer(ref this, RemoteOptions, out Server);
			public HResult DisconnectProcessServer(uint64 Server) mut => VT.DisconnectProcessServer(ref this, Server);
			public HResult GetRunningProcessSystemIds(uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) mut => VT.GetRunningProcessSystemIds(ref this, Server, Ids, Count, ActualCount);
			public HResult GetRunningProcessSystemIdByExecutableName(uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableName(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescription(uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescription(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult AttachProcess(uint64 Server, uint32 ProcessId, uint32 AttachFlags) mut => VT.AttachProcess(ref this, Server, ProcessId, AttachFlags);
			public HResult CreateProcessA(uint64 Server, char8* CommandLine, uint32 CreateFlags) mut => VT._CreateProcessA(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttach(uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult GetProcessOptions(out uint32 Options) mut => VT.GetProcessOptions(ref this, out Options);
			public HResult AddProcessOptions(uint32 Options) mut => VT.AddProcessOptions(ref this, Options);
			public HResult RemoveProcessOptions(uint32 Options) mut => VT.RemoveProcessOptions(ref this, Options);
			public HResult SetProcessOptions(uint32 Options) mut => VT.SetProcessOptions(ref this, Options);
			public HResult OpenDumpFile(char8* DumpFile) mut => VT.OpenDumpFile(ref this, DumpFile);
			public HResult WriteDumpFile(char8* DumpFile, uint32 Qualifier) mut => VT.WriteDumpFile(ref this, DumpFile, Qualifier);
			public HResult ConnectSession(uint32 Flags, uint32 HistoryLimit) mut => VT.ConnectSession(ref this, Flags, HistoryLimit);
			public HResult StartServer(char8* Options) mut => VT.StartServer(ref this, Options);
			public HResult OutputServers(uint32 OutputControl, char8* Machine, uint32 Flags) mut => VT.OutputServers(ref this, OutputControl, Machine, Flags);
			public HResult TerminateProcesses() mut => VT.TerminateProcesses(ref this);
			public HResult DetachProcesses() mut => VT.DetachProcesses(ref this);
			public HResult EndSession(uint32 Flags) mut => VT.EndSession(ref this, Flags);
			public HResult GetExitCode(out uint32 Code) mut => VT.GetExitCode(ref this, out Code);
			public HResult DispatchCallbacks(uint32 Timeout) mut => VT.DispatchCallbacks(ref this, Timeout);
			public HResult ExitDispatch(ref IDebugClient Client) mut => VT.ExitDispatch(ref this, ref Client);
			public HResult CreateClient(out IDebugClient* Client) mut => VT.CreateClient(ref this, out Client);
			public HResult GetInputCallbacks(out IDebugInputCallbacks* Callbacks) mut => VT.GetInputCallbacks(ref this, out Callbacks);
			public HResult SetInputCallbacks(IDebugInputCallbacks* Callbacks) mut => VT.SetInputCallbacks(ref this, Callbacks);
			public HResult GetOutputCallbacks(out IDebugOutputCallbacks* Callbacks) mut => VT.GetOutputCallbacks(ref this, out Callbacks);
			public HResult SetOutputCallbacks(IDebugOutputCallbacks* Callbacks) mut => VT.SetOutputCallbacks(ref this, Callbacks);
			public HResult GetOutputMask(out uint32 Mask) mut => VT.GetOutputMask(ref this, out Mask);
			public HResult SetOutputMask(uint32 Mask) mut => VT.SetOutputMask(ref this, Mask);
			public HResult GetOtherOutputMask(ref IDebugClient Client, out uint32 Mask) mut => VT.GetOtherOutputMask(ref this, ref Client, out Mask);
			public HResult SetOtherOutputMask(ref IDebugClient Client, uint32 Mask) mut => VT.SetOtherOutputMask(ref this, ref Client, Mask);
			public HResult GetOutputWidth(out uint32 Columns) mut => VT.GetOutputWidth(ref this, out Columns);
			public HResult SetOutputWidth(uint32 Columns) mut => VT.SetOutputWidth(ref this, Columns);
			public HResult GetOutputLinePrefix(uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefix(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefix(char8* Prefix) mut => VT.SetOutputLinePrefix(ref this, Prefix);
			public HResult GetIdentity(uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentity(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentity(uint32 OutputControl, uint32 Flags, char8* Format) mut => VT.OutputIdentity(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacks(out IDebugEventCallbacks* Callbacks) mut => VT.GetEventCallbacks(ref this, out Callbacks);
			public HResult SetEventCallbacks(IDebugEventCallbacks* Callbacks) mut => VT.SetEventCallbacks(ref this, Callbacks);
			public HResult FlushCallbacks() mut => VT.FlushCallbacks(ref this);
			public HResult WriteDumpFile2(char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) mut => VT.WriteDumpFile2(ref this, DumpFile, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFile(char8* InfoFile, uint32 Type) mut => VT.AddDumpInformationFile(ref this, InfoFile, Type);
			public HResult EndProcessServer(uint64 Server) mut => VT.EndProcessServer(ref this, Server);
			public HResult WaitForProcessServerEnd(uint32 Timeout) mut => VT.WaitForProcessServerEnd(ref this, Timeout);
			public HResult IsKernelDebuggerEnabled() mut => VT.IsKernelDebuggerEnabled(ref this);
			public HResult TerminateCurrentProcess() mut => VT.TerminateCurrentProcess(ref this);
			public HResult DetachCurrentProcess() mut => VT.DetachCurrentProcess(ref this);
			public HResult AbandonCurrentProcess() mut => VT.AbandonCurrentProcess(ref this);
			public HResult GetRunningProcessSystemIdByExecutableNameWide(uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableNameWide(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescriptionWide(uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescriptionWide(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult CreateProcessWide(uint64 Server, char16* CommandLine, uint32 CreateFlags) mut => VT.CreateProcessWide(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttachWide(uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttachWide(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult OpenDumpFileWide(char16* FileName, uint64 FileHandle) mut => VT.OpenDumpFileWide(ref this, FileName, FileHandle);
			public HResult WriteDumpFileWide(char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) mut => VT.WriteDumpFileWide(ref this, FileName, FileHandle, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFileWide(char16* FileName, uint64 FileHandle, uint32 Type) mut => VT.AddDumpInformationFileWide(ref this, FileName, FileHandle, Type);
			public HResult GetNumberDumpFiles(out uint32 Number) mut => VT.GetNumberDumpFiles(ref this, out Number);
			public HResult GetDumpFile(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFile(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);
			public HResult GetDumpFileWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFileWide(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);
			public HResult AttachKernelWide(uint32 Flags, char16* ConnectOptions) mut => VT.AttachKernelWide(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptionsWide(char16* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptionsWide(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptionsWide(char16* Options) mut => VT.SetKernelConnectionOptionsWide(ref this, Options);
			public HResult StartProcessServerWide(uint32 Flags, char16* Options, void* Reserved) mut => VT.StartProcessServerWide(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServerWide(char16* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServerWide(ref this, RemoteOptions, out Server);
			public HResult StartServerWide(char16* Options) mut => VT.StartServerWide(ref this, Options);
			public HResult OutputServersWide(uint32 OutputControl, char16* Machine, uint32 Flags) mut => VT.OutputServersWide(ref this, OutputControl, Machine, Flags);
			public HResult GetOutputCallbacksWide(out IDebugOutputCallbacksWide* Callbacks) mut => VT.GetOutputCallbacksWide(ref this, out Callbacks);
			public HResult SetOutputCallbacksWide(ref IDebugOutputCallbacksWide Callbacks) mut => VT.SetOutputCallbacksWide(ref this, ref Callbacks);
			public HResult GetOutputLinePrefixWide(char16* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefixWide(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefixWide(char16* Prefix) mut => VT.SetOutputLinePrefixWide(ref this, Prefix);
			public HResult GetIdentityWide(char16* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentityWide(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentityWide(uint32 OutputControl, uint32 Flags, char16* Format) mut => VT.OutputIdentityWide(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacksWide(out IDebugEventCallbacksWide* Callbacks) mut => VT.GetEventCallbacksWide(ref this, out Callbacks);
			public HResult SetEventCallbacksWide(ref IDebugEventCallbacksWide Callbacks) mut => VT.SetEventCallbacksWide(ref this, ref Callbacks);
			public HResult CreateProcess2(uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment) mut => VT.CreateProcess2(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
			public HResult CreateProcess2Wide(uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment) mut => VT.CreateProcess2Wide(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
			public HResult CreateProcessAndAttach2(uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach2(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
			public HResult CreateProcessAndAttach2Wide(uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach2Wide(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
			public HResult PushOutputLinePrefix(char8* NewPrefix, out uint64 Handle) mut => VT.PushOutputLinePrefix(ref this, NewPrefix, out Handle);
			public HResult PushOutputLinePrefixWide(char16* NewPrefix, out uint64 Handle) mut => VT.PushOutputLinePrefixWide(ref this, NewPrefix, out Handle);
			public HResult PopOutputLinePrefix(uint64 Handle) mut => VT.PopOutputLinePrefix(ref this, Handle);
			public HResult GetNumberInputCallbacks(out uint32 Count) mut => VT.GetNumberInputCallbacks(ref this, out Count);
			public HResult GetNumberOutputCallbacks(out uint32 Count) mut => VT.GetNumberOutputCallbacks(ref this, out Count);
			public HResult GetNumberEventCallbacks(uint32 EventFlags, out uint32 Count) mut => VT.GetNumberEventCallbacks(ref this, EventFlags, out Count);
			public HResult GetQuitLockString(uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetQuitLockString(ref this, Buffer, BufferSize, StringSize);
			public HResult SetQuitLockString(char8* String) mut => VT.SetQuitLockString(ref this, String);
			public HResult GetQuitLockStringWide(char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetQuitLockStringWide(ref this, Buffer, BufferSize, StringSize);
			public HResult SetQuitLockStringWide(char16* String) mut => VT.SetQuitLockStringWide(ref this, String);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Flags, char8* ConnectOptions) AttachKernel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* Options) SetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Flags, char8* Options, void* Reserved) StartProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* RemoteOptions, out uint64 Server) ConnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server) DisconnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) GetRunningProcessSystemIds;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, uint32 ProcessId, uint32 AttachFlags) AttachProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char8* CommandLine, uint32 CreateFlags) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out uint32 Options) GetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Options) AddProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Options) RemoveProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Options) SetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* DumpFile) OpenDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* DumpFile, uint32 Qualifier) WriteDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Flags, uint32 HistoryLimit) ConnectSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* Options) StartServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 OutputControl, char8* Machine, uint32 Flags) OutputServers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self) TerminateProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self) DetachProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Flags) EndSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out uint32 Code) GetExitCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Timeout) DispatchCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, ref IDebugClient Client) ExitDispatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out IDebugClient* Client) CreateClient;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out IDebugInputCallbacks* Callbacks) GetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, IDebugInputCallbacks* Callbacks) SetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out IDebugOutputCallbacks* Callbacks) GetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, IDebugOutputCallbacks* Callbacks) SetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out uint32 Mask) GetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Mask) SetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, ref IDebugClient Client, out uint32 Mask) GetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, ref IDebugClient Client, uint32 Mask) SetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out uint32 Columns) GetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Columns) SetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* Prefix) SetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 OutputControl, uint32 Flags, char8* Format) OutputIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out IDebugEventCallbacks* Callbacks) GetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, IDebugEventCallbacks* Callbacks) SetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self) FlushCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) WriteDumpFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* InfoFile, uint32 Type) AddDumpInformationFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server) EndProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Timeout) WaitForProcessServerEnd;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self) IsKernelDebuggerEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self) TerminateCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self) DetachCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self) AbandonCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char16* CommandLine, uint32 CreateFlags) CreateProcessWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttachWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* FileName, uint64 FileHandle) OpenDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) WriteDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* FileName, uint64 FileHandle, uint32 Type) AddDumpInformationFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out uint32 Number) GetNumberDumpFiles;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Flags, char16* ConnectOptions) AttachKernelWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptionsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* Options) SetKernelConnectionOptionsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 Flags, char16* Options, void* Reserved) StartProcessServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* RemoteOptions, out uint64 Server) ConnectProcessServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* Options) StartServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 OutputControl, char16* Machine, uint32 Flags) OutputServersWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out IDebugOutputCallbacksWide* Callbacks) GetOutputCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, ref IDebugOutputCallbacksWide Callbacks) SetOutputCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* Prefix) SetOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentityWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 OutputControl, uint32 Flags, char16* Format) OutputIdentityWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out IDebugEventCallbacksWide* Callbacks) GetEventCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, ref IDebugEventCallbacksWide Callbacks) SetEventCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment) CreateProcess2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment) CreateProcess2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* NewPrefix, out uint64 Handle) PushOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* NewPrefix, out uint64 Handle) PushOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint64 Handle) PopOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out uint32 Count) GetNumberInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, out uint32 Count) GetNumberOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint32 EventFlags, out uint32 Count) GetNumberEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetQuitLockString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char8* String) SetQuitLockString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetQuitLockStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient5 self, char16* String) SetQuitLockStringWide;
			}
		}
		[CRepr]
		public struct IDebugClient6 : IUnknown
		{
			public const new Guid IID = .(0xfd28b4c5, 0xc498, 0x4686, 0xa2, 0x8e, 0x62, 0xca, 0xd2, 0x15, 0x4e, 0xb3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AttachKernel(uint32 Flags, char8* ConnectOptions) mut => VT.AttachKernel(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptions(uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptions(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptions(char8* Options) mut => VT.SetKernelConnectionOptions(ref this, Options);
			public HResult StartProcessServer(uint32 Flags, char8* Options, void* Reserved) mut => VT.StartProcessServer(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServer(char8* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServer(ref this, RemoteOptions, out Server);
			public HResult DisconnectProcessServer(uint64 Server) mut => VT.DisconnectProcessServer(ref this, Server);
			public HResult GetRunningProcessSystemIds(uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) mut => VT.GetRunningProcessSystemIds(ref this, Server, Ids, Count, ActualCount);
			public HResult GetRunningProcessSystemIdByExecutableName(uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableName(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescription(uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescription(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult AttachProcess(uint64 Server, uint32 ProcessId, uint32 AttachFlags) mut => VT.AttachProcess(ref this, Server, ProcessId, AttachFlags);
			public HResult CreateProcessA(uint64 Server, char8* CommandLine, uint32 CreateFlags) mut => VT._CreateProcessA(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttach(uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult GetProcessOptions(out uint32 Options) mut => VT.GetProcessOptions(ref this, out Options);
			public HResult AddProcessOptions(uint32 Options) mut => VT.AddProcessOptions(ref this, Options);
			public HResult RemoveProcessOptions(uint32 Options) mut => VT.RemoveProcessOptions(ref this, Options);
			public HResult SetProcessOptions(uint32 Options) mut => VT.SetProcessOptions(ref this, Options);
			public HResult OpenDumpFile(char8* DumpFile) mut => VT.OpenDumpFile(ref this, DumpFile);
			public HResult WriteDumpFile(char8* DumpFile, uint32 Qualifier) mut => VT.WriteDumpFile(ref this, DumpFile, Qualifier);
			public HResult ConnectSession(uint32 Flags, uint32 HistoryLimit) mut => VT.ConnectSession(ref this, Flags, HistoryLimit);
			public HResult StartServer(char8* Options) mut => VT.StartServer(ref this, Options);
			public HResult OutputServers(uint32 OutputControl, char8* Machine, uint32 Flags) mut => VT.OutputServers(ref this, OutputControl, Machine, Flags);
			public HResult TerminateProcesses() mut => VT.TerminateProcesses(ref this);
			public HResult DetachProcesses() mut => VT.DetachProcesses(ref this);
			public HResult EndSession(uint32 Flags) mut => VT.EndSession(ref this, Flags);
			public HResult GetExitCode(out uint32 Code) mut => VT.GetExitCode(ref this, out Code);
			public HResult DispatchCallbacks(uint32 Timeout) mut => VT.DispatchCallbacks(ref this, Timeout);
			public HResult ExitDispatch(ref IDebugClient Client) mut => VT.ExitDispatch(ref this, ref Client);
			public HResult CreateClient(out IDebugClient* Client) mut => VT.CreateClient(ref this, out Client);
			public HResult GetInputCallbacks(out IDebugInputCallbacks* Callbacks) mut => VT.GetInputCallbacks(ref this, out Callbacks);
			public HResult SetInputCallbacks(IDebugInputCallbacks* Callbacks) mut => VT.SetInputCallbacks(ref this, Callbacks);
			public HResult GetOutputCallbacks(out IDebugOutputCallbacks* Callbacks) mut => VT.GetOutputCallbacks(ref this, out Callbacks);
			public HResult SetOutputCallbacks(IDebugOutputCallbacks* Callbacks) mut => VT.SetOutputCallbacks(ref this, Callbacks);
			public HResult GetOutputMask(out uint32 Mask) mut => VT.GetOutputMask(ref this, out Mask);
			public HResult SetOutputMask(uint32 Mask) mut => VT.SetOutputMask(ref this, Mask);
			public HResult GetOtherOutputMask(ref IDebugClient Client, out uint32 Mask) mut => VT.GetOtherOutputMask(ref this, ref Client, out Mask);
			public HResult SetOtherOutputMask(ref IDebugClient Client, uint32 Mask) mut => VT.SetOtherOutputMask(ref this, ref Client, Mask);
			public HResult GetOutputWidth(out uint32 Columns) mut => VT.GetOutputWidth(ref this, out Columns);
			public HResult SetOutputWidth(uint32 Columns) mut => VT.SetOutputWidth(ref this, Columns);
			public HResult GetOutputLinePrefix(uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefix(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefix(char8* Prefix) mut => VT.SetOutputLinePrefix(ref this, Prefix);
			public HResult GetIdentity(uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentity(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentity(uint32 OutputControl, uint32 Flags, char8* Format) mut => VT.OutputIdentity(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacks(out IDebugEventCallbacks* Callbacks) mut => VT.GetEventCallbacks(ref this, out Callbacks);
			public HResult SetEventCallbacks(IDebugEventCallbacks* Callbacks) mut => VT.SetEventCallbacks(ref this, Callbacks);
			public HResult FlushCallbacks() mut => VT.FlushCallbacks(ref this);
			public HResult WriteDumpFile2(char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) mut => VT.WriteDumpFile2(ref this, DumpFile, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFile(char8* InfoFile, uint32 Type) mut => VT.AddDumpInformationFile(ref this, InfoFile, Type);
			public HResult EndProcessServer(uint64 Server) mut => VT.EndProcessServer(ref this, Server);
			public HResult WaitForProcessServerEnd(uint32 Timeout) mut => VT.WaitForProcessServerEnd(ref this, Timeout);
			public HResult IsKernelDebuggerEnabled() mut => VT.IsKernelDebuggerEnabled(ref this);
			public HResult TerminateCurrentProcess() mut => VT.TerminateCurrentProcess(ref this);
			public HResult DetachCurrentProcess() mut => VT.DetachCurrentProcess(ref this);
			public HResult AbandonCurrentProcess() mut => VT.AbandonCurrentProcess(ref this);
			public HResult GetRunningProcessSystemIdByExecutableNameWide(uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableNameWide(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescriptionWide(uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescriptionWide(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult CreateProcessWide(uint64 Server, char16* CommandLine, uint32 CreateFlags) mut => VT.CreateProcessWide(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttachWide(uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttachWide(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult OpenDumpFileWide(char16* FileName, uint64 FileHandle) mut => VT.OpenDumpFileWide(ref this, FileName, FileHandle);
			public HResult WriteDumpFileWide(char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) mut => VT.WriteDumpFileWide(ref this, FileName, FileHandle, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFileWide(char16* FileName, uint64 FileHandle, uint32 Type) mut => VT.AddDumpInformationFileWide(ref this, FileName, FileHandle, Type);
			public HResult GetNumberDumpFiles(out uint32 Number) mut => VT.GetNumberDumpFiles(ref this, out Number);
			public HResult GetDumpFile(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFile(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);
			public HResult GetDumpFileWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFileWide(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);
			public HResult AttachKernelWide(uint32 Flags, char16* ConnectOptions) mut => VT.AttachKernelWide(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptionsWide(char16* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptionsWide(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptionsWide(char16* Options) mut => VT.SetKernelConnectionOptionsWide(ref this, Options);
			public HResult StartProcessServerWide(uint32 Flags, char16* Options, void* Reserved) mut => VT.StartProcessServerWide(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServerWide(char16* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServerWide(ref this, RemoteOptions, out Server);
			public HResult StartServerWide(char16* Options) mut => VT.StartServerWide(ref this, Options);
			public HResult OutputServersWide(uint32 OutputControl, char16* Machine, uint32 Flags) mut => VT.OutputServersWide(ref this, OutputControl, Machine, Flags);
			public HResult GetOutputCallbacksWide(out IDebugOutputCallbacksWide* Callbacks) mut => VT.GetOutputCallbacksWide(ref this, out Callbacks);
			public HResult SetOutputCallbacksWide(ref IDebugOutputCallbacksWide Callbacks) mut => VT.SetOutputCallbacksWide(ref this, ref Callbacks);
			public HResult GetOutputLinePrefixWide(char16* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefixWide(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefixWide(char16* Prefix) mut => VT.SetOutputLinePrefixWide(ref this, Prefix);
			public HResult GetIdentityWide(char16* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentityWide(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentityWide(uint32 OutputControl, uint32 Flags, char16* Format) mut => VT.OutputIdentityWide(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacksWide(out IDebugEventCallbacksWide* Callbacks) mut => VT.GetEventCallbacksWide(ref this, out Callbacks);
			public HResult SetEventCallbacksWide(ref IDebugEventCallbacksWide Callbacks) mut => VT.SetEventCallbacksWide(ref this, ref Callbacks);
			public HResult CreateProcess2(uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment) mut => VT.CreateProcess2(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
			public HResult CreateProcess2Wide(uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment) mut => VT.CreateProcess2Wide(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
			public HResult CreateProcessAndAttach2(uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach2(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
			public HResult CreateProcessAndAttach2Wide(uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach2Wide(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
			public HResult PushOutputLinePrefix(char8* NewPrefix, out uint64 Handle) mut => VT.PushOutputLinePrefix(ref this, NewPrefix, out Handle);
			public HResult PushOutputLinePrefixWide(char16* NewPrefix, out uint64 Handle) mut => VT.PushOutputLinePrefixWide(ref this, NewPrefix, out Handle);
			public HResult PopOutputLinePrefix(uint64 Handle) mut => VT.PopOutputLinePrefix(ref this, Handle);
			public HResult GetNumberInputCallbacks(out uint32 Count) mut => VT.GetNumberInputCallbacks(ref this, out Count);
			public HResult GetNumberOutputCallbacks(out uint32 Count) mut => VT.GetNumberOutputCallbacks(ref this, out Count);
			public HResult GetNumberEventCallbacks(uint32 EventFlags, out uint32 Count) mut => VT.GetNumberEventCallbacks(ref this, EventFlags, out Count);
			public HResult GetQuitLockString(uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetQuitLockString(ref this, Buffer, BufferSize, StringSize);
			public HResult SetQuitLockString(char8* String) mut => VT.SetQuitLockString(ref this, String);
			public HResult GetQuitLockStringWide(char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetQuitLockStringWide(ref this, Buffer, BufferSize, StringSize);
			public HResult SetQuitLockStringWide(char16* String) mut => VT.SetQuitLockStringWide(ref this, String);
			public HResult SetEventContextCallbacks(IDebugEventContextCallbacks* Callbacks) mut => VT.SetEventContextCallbacks(ref this, Callbacks);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Flags, char8* ConnectOptions) AttachKernel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* Options) SetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Flags, char8* Options, void* Reserved) StartProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* RemoteOptions, out uint64 Server) ConnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server) DisconnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) GetRunningProcessSystemIds;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, uint32 ProcessId, uint32 AttachFlags) AttachProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char8* CommandLine, uint32 CreateFlags) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out uint32 Options) GetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Options) AddProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Options) RemoveProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Options) SetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* DumpFile) OpenDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* DumpFile, uint32 Qualifier) WriteDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Flags, uint32 HistoryLimit) ConnectSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* Options) StartServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 OutputControl, char8* Machine, uint32 Flags) OutputServers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self) TerminateProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self) DetachProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Flags) EndSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out uint32 Code) GetExitCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Timeout) DispatchCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, ref IDebugClient Client) ExitDispatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out IDebugClient* Client) CreateClient;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out IDebugInputCallbacks* Callbacks) GetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, IDebugInputCallbacks* Callbacks) SetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out IDebugOutputCallbacks* Callbacks) GetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, IDebugOutputCallbacks* Callbacks) SetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out uint32 Mask) GetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Mask) SetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, ref IDebugClient Client, out uint32 Mask) GetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, ref IDebugClient Client, uint32 Mask) SetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out uint32 Columns) GetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Columns) SetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* Prefix) SetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 OutputControl, uint32 Flags, char8* Format) OutputIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out IDebugEventCallbacks* Callbacks) GetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, IDebugEventCallbacks* Callbacks) SetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self) FlushCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) WriteDumpFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* InfoFile, uint32 Type) AddDumpInformationFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server) EndProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Timeout) WaitForProcessServerEnd;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self) IsKernelDebuggerEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self) TerminateCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self) DetachCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self) AbandonCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char16* CommandLine, uint32 CreateFlags) CreateProcessWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttachWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* FileName, uint64 FileHandle) OpenDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) WriteDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* FileName, uint64 FileHandle, uint32 Type) AddDumpInformationFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out uint32 Number) GetNumberDumpFiles;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Flags, char16* ConnectOptions) AttachKernelWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptionsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* Options) SetKernelConnectionOptionsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 Flags, char16* Options, void* Reserved) StartProcessServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* RemoteOptions, out uint64 Server) ConnectProcessServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* Options) StartServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 OutputControl, char16* Machine, uint32 Flags) OutputServersWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out IDebugOutputCallbacksWide* Callbacks) GetOutputCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, ref IDebugOutputCallbacksWide Callbacks) SetOutputCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* Prefix) SetOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentityWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 OutputControl, uint32 Flags, char16* Format) OutputIdentityWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out IDebugEventCallbacksWide* Callbacks) GetEventCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, ref IDebugEventCallbacksWide Callbacks) SetEventCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment) CreateProcess2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment) CreateProcess2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* NewPrefix, out uint64 Handle) PushOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* NewPrefix, out uint64 Handle) PushOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint64 Handle) PopOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out uint32 Count) GetNumberInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, out uint32 Count) GetNumberOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint32 EventFlags, out uint32 Count) GetNumberEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetQuitLockString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char8* String) SetQuitLockString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetQuitLockStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, char16* String) SetQuitLockStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient6 self, IDebugEventContextCallbacks* Callbacks) SetEventContextCallbacks;
			}
		}
		[CRepr]
		public struct IDebugClient7 : IUnknown
		{
			public const new Guid IID = .(0x13586be3, 0x542e, 0x481e, 0xb1, 0xf2, 0x84, 0x97, 0xba, 0x74, 0xf9, 0xa9);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AttachKernel(uint32 Flags, char8* ConnectOptions) mut => VT.AttachKernel(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptions(uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptions(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptions(char8* Options) mut => VT.SetKernelConnectionOptions(ref this, Options);
			public HResult StartProcessServer(uint32 Flags, char8* Options, void* Reserved) mut => VT.StartProcessServer(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServer(char8* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServer(ref this, RemoteOptions, out Server);
			public HResult DisconnectProcessServer(uint64 Server) mut => VT.DisconnectProcessServer(ref this, Server);
			public HResult GetRunningProcessSystemIds(uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) mut => VT.GetRunningProcessSystemIds(ref this, Server, Ids, Count, ActualCount);
			public HResult GetRunningProcessSystemIdByExecutableName(uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableName(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescription(uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescription(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult AttachProcess(uint64 Server, uint32 ProcessId, uint32 AttachFlags) mut => VT.AttachProcess(ref this, Server, ProcessId, AttachFlags);
			public HResult CreateProcessA(uint64 Server, char8* CommandLine, uint32 CreateFlags) mut => VT._CreateProcessA(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttach(uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult GetProcessOptions(out uint32 Options) mut => VT.GetProcessOptions(ref this, out Options);
			public HResult AddProcessOptions(uint32 Options) mut => VT.AddProcessOptions(ref this, Options);
			public HResult RemoveProcessOptions(uint32 Options) mut => VT.RemoveProcessOptions(ref this, Options);
			public HResult SetProcessOptions(uint32 Options) mut => VT.SetProcessOptions(ref this, Options);
			public HResult OpenDumpFile(char8* DumpFile) mut => VT.OpenDumpFile(ref this, DumpFile);
			public HResult WriteDumpFile(char8* DumpFile, uint32 Qualifier) mut => VT.WriteDumpFile(ref this, DumpFile, Qualifier);
			public HResult ConnectSession(uint32 Flags, uint32 HistoryLimit) mut => VT.ConnectSession(ref this, Flags, HistoryLimit);
			public HResult StartServer(char8* Options) mut => VT.StartServer(ref this, Options);
			public HResult OutputServers(uint32 OutputControl, char8* Machine, uint32 Flags) mut => VT.OutputServers(ref this, OutputControl, Machine, Flags);
			public HResult TerminateProcesses() mut => VT.TerminateProcesses(ref this);
			public HResult DetachProcesses() mut => VT.DetachProcesses(ref this);
			public HResult EndSession(uint32 Flags) mut => VT.EndSession(ref this, Flags);
			public HResult GetExitCode(out uint32 Code) mut => VT.GetExitCode(ref this, out Code);
			public HResult DispatchCallbacks(uint32 Timeout) mut => VT.DispatchCallbacks(ref this, Timeout);
			public HResult ExitDispatch(ref IDebugClient Client) mut => VT.ExitDispatch(ref this, ref Client);
			public HResult CreateClient(out IDebugClient* Client) mut => VT.CreateClient(ref this, out Client);
			public HResult GetInputCallbacks(out IDebugInputCallbacks* Callbacks) mut => VT.GetInputCallbacks(ref this, out Callbacks);
			public HResult SetInputCallbacks(IDebugInputCallbacks* Callbacks) mut => VT.SetInputCallbacks(ref this, Callbacks);
			public HResult GetOutputCallbacks(out IDebugOutputCallbacks* Callbacks) mut => VT.GetOutputCallbacks(ref this, out Callbacks);
			public HResult SetOutputCallbacks(IDebugOutputCallbacks* Callbacks) mut => VT.SetOutputCallbacks(ref this, Callbacks);
			public HResult GetOutputMask(out uint32 Mask) mut => VT.GetOutputMask(ref this, out Mask);
			public HResult SetOutputMask(uint32 Mask) mut => VT.SetOutputMask(ref this, Mask);
			public HResult GetOtherOutputMask(ref IDebugClient Client, out uint32 Mask) mut => VT.GetOtherOutputMask(ref this, ref Client, out Mask);
			public HResult SetOtherOutputMask(ref IDebugClient Client, uint32 Mask) mut => VT.SetOtherOutputMask(ref this, ref Client, Mask);
			public HResult GetOutputWidth(out uint32 Columns) mut => VT.GetOutputWidth(ref this, out Columns);
			public HResult SetOutputWidth(uint32 Columns) mut => VT.SetOutputWidth(ref this, Columns);
			public HResult GetOutputLinePrefix(uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefix(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefix(char8* Prefix) mut => VT.SetOutputLinePrefix(ref this, Prefix);
			public HResult GetIdentity(uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentity(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentity(uint32 OutputControl, uint32 Flags, char8* Format) mut => VT.OutputIdentity(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacks(out IDebugEventCallbacks* Callbacks) mut => VT.GetEventCallbacks(ref this, out Callbacks);
			public HResult SetEventCallbacks(IDebugEventCallbacks* Callbacks) mut => VT.SetEventCallbacks(ref this, Callbacks);
			public HResult FlushCallbacks() mut => VT.FlushCallbacks(ref this);
			public HResult WriteDumpFile2(char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) mut => VT.WriteDumpFile2(ref this, DumpFile, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFile(char8* InfoFile, uint32 Type) mut => VT.AddDumpInformationFile(ref this, InfoFile, Type);
			public HResult EndProcessServer(uint64 Server) mut => VT.EndProcessServer(ref this, Server);
			public HResult WaitForProcessServerEnd(uint32 Timeout) mut => VT.WaitForProcessServerEnd(ref this, Timeout);
			public HResult IsKernelDebuggerEnabled() mut => VT.IsKernelDebuggerEnabled(ref this);
			public HResult TerminateCurrentProcess() mut => VT.TerminateCurrentProcess(ref this);
			public HResult DetachCurrentProcess() mut => VT.DetachCurrentProcess(ref this);
			public HResult AbandonCurrentProcess() mut => VT.AbandonCurrentProcess(ref this);
			public HResult GetRunningProcessSystemIdByExecutableNameWide(uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableNameWide(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescriptionWide(uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescriptionWide(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult CreateProcessWide(uint64 Server, char16* CommandLine, uint32 CreateFlags) mut => VT.CreateProcessWide(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttachWide(uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttachWide(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult OpenDumpFileWide(char16* FileName, uint64 FileHandle) mut => VT.OpenDumpFileWide(ref this, FileName, FileHandle);
			public HResult WriteDumpFileWide(char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) mut => VT.WriteDumpFileWide(ref this, FileName, FileHandle, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFileWide(char16* FileName, uint64 FileHandle, uint32 Type) mut => VT.AddDumpInformationFileWide(ref this, FileName, FileHandle, Type);
			public HResult GetNumberDumpFiles(out uint32 Number) mut => VT.GetNumberDumpFiles(ref this, out Number);
			public HResult GetDumpFile(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFile(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);
			public HResult GetDumpFileWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFileWide(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);
			public HResult AttachKernelWide(uint32 Flags, char16* ConnectOptions) mut => VT.AttachKernelWide(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptionsWide(char16* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptionsWide(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptionsWide(char16* Options) mut => VT.SetKernelConnectionOptionsWide(ref this, Options);
			public HResult StartProcessServerWide(uint32 Flags, char16* Options, void* Reserved) mut => VT.StartProcessServerWide(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServerWide(char16* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServerWide(ref this, RemoteOptions, out Server);
			public HResult StartServerWide(char16* Options) mut => VT.StartServerWide(ref this, Options);
			public HResult OutputServersWide(uint32 OutputControl, char16* Machine, uint32 Flags) mut => VT.OutputServersWide(ref this, OutputControl, Machine, Flags);
			public HResult GetOutputCallbacksWide(out IDebugOutputCallbacksWide* Callbacks) mut => VT.GetOutputCallbacksWide(ref this, out Callbacks);
			public HResult SetOutputCallbacksWide(ref IDebugOutputCallbacksWide Callbacks) mut => VT.SetOutputCallbacksWide(ref this, ref Callbacks);
			public HResult GetOutputLinePrefixWide(char16* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefixWide(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefixWide(char16* Prefix) mut => VT.SetOutputLinePrefixWide(ref this, Prefix);
			public HResult GetIdentityWide(char16* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentityWide(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentityWide(uint32 OutputControl, uint32 Flags, char16* Format) mut => VT.OutputIdentityWide(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacksWide(out IDebugEventCallbacksWide* Callbacks) mut => VT.GetEventCallbacksWide(ref this, out Callbacks);
			public HResult SetEventCallbacksWide(ref IDebugEventCallbacksWide Callbacks) mut => VT.SetEventCallbacksWide(ref this, ref Callbacks);
			public HResult CreateProcess2(uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment) mut => VT.CreateProcess2(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
			public HResult CreateProcess2Wide(uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment) mut => VT.CreateProcess2Wide(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
			public HResult CreateProcessAndAttach2(uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach2(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
			public HResult CreateProcessAndAttach2Wide(uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach2Wide(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
			public HResult PushOutputLinePrefix(char8* NewPrefix, out uint64 Handle) mut => VT.PushOutputLinePrefix(ref this, NewPrefix, out Handle);
			public HResult PushOutputLinePrefixWide(char16* NewPrefix, out uint64 Handle) mut => VT.PushOutputLinePrefixWide(ref this, NewPrefix, out Handle);
			public HResult PopOutputLinePrefix(uint64 Handle) mut => VT.PopOutputLinePrefix(ref this, Handle);
			public HResult GetNumberInputCallbacks(out uint32 Count) mut => VT.GetNumberInputCallbacks(ref this, out Count);
			public HResult GetNumberOutputCallbacks(out uint32 Count) mut => VT.GetNumberOutputCallbacks(ref this, out Count);
			public HResult GetNumberEventCallbacks(uint32 EventFlags, out uint32 Count) mut => VT.GetNumberEventCallbacks(ref this, EventFlags, out Count);
			public HResult GetQuitLockString(uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetQuitLockString(ref this, Buffer, BufferSize, StringSize);
			public HResult SetQuitLockString(char8* String) mut => VT.SetQuitLockString(ref this, String);
			public HResult GetQuitLockStringWide(char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetQuitLockStringWide(ref this, Buffer, BufferSize, StringSize);
			public HResult SetQuitLockStringWide(char16* String) mut => VT.SetQuitLockStringWide(ref this, String);
			public HResult SetEventContextCallbacks(IDebugEventContextCallbacks* Callbacks) mut => VT.SetEventContextCallbacks(ref this, Callbacks);
			public HResult SetClientContext(void* Context, uint32 ContextSize) mut => VT.SetClientContext(ref this, Context, ContextSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Flags, char8* ConnectOptions) AttachKernel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* Options) SetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Flags, char8* Options, void* Reserved) StartProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* RemoteOptions, out uint64 Server) ConnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server) DisconnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) GetRunningProcessSystemIds;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, uint32 ProcessId, uint32 AttachFlags) AttachProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char8* CommandLine, uint32 CreateFlags) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out uint32 Options) GetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Options) AddProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Options) RemoveProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Options) SetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* DumpFile) OpenDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* DumpFile, uint32 Qualifier) WriteDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Flags, uint32 HistoryLimit) ConnectSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* Options) StartServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 OutputControl, char8* Machine, uint32 Flags) OutputServers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self) TerminateProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self) DetachProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Flags) EndSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out uint32 Code) GetExitCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Timeout) DispatchCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, ref IDebugClient Client) ExitDispatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out IDebugClient* Client) CreateClient;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out IDebugInputCallbacks* Callbacks) GetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, IDebugInputCallbacks* Callbacks) SetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out IDebugOutputCallbacks* Callbacks) GetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, IDebugOutputCallbacks* Callbacks) SetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out uint32 Mask) GetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Mask) SetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, ref IDebugClient Client, out uint32 Mask) GetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, ref IDebugClient Client, uint32 Mask) SetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out uint32 Columns) GetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Columns) SetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* Prefix) SetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 OutputControl, uint32 Flags, char8* Format) OutputIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out IDebugEventCallbacks* Callbacks) GetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, IDebugEventCallbacks* Callbacks) SetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self) FlushCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) WriteDumpFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* InfoFile, uint32 Type) AddDumpInformationFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server) EndProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Timeout) WaitForProcessServerEnd;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self) IsKernelDebuggerEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self) TerminateCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self) DetachCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self) AbandonCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char16* CommandLine, uint32 CreateFlags) CreateProcessWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttachWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* FileName, uint64 FileHandle) OpenDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) WriteDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* FileName, uint64 FileHandle, uint32 Type) AddDumpInformationFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out uint32 Number) GetNumberDumpFiles;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Flags, char16* ConnectOptions) AttachKernelWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptionsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* Options) SetKernelConnectionOptionsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 Flags, char16* Options, void* Reserved) StartProcessServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* RemoteOptions, out uint64 Server) ConnectProcessServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* Options) StartServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 OutputControl, char16* Machine, uint32 Flags) OutputServersWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out IDebugOutputCallbacksWide* Callbacks) GetOutputCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, ref IDebugOutputCallbacksWide Callbacks) SetOutputCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* Prefix) SetOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentityWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 OutputControl, uint32 Flags, char16* Format) OutputIdentityWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out IDebugEventCallbacksWide* Callbacks) GetEventCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, ref IDebugEventCallbacksWide Callbacks) SetEventCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment) CreateProcess2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment) CreateProcess2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* NewPrefix, out uint64 Handle) PushOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* NewPrefix, out uint64 Handle) PushOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint64 Handle) PopOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out uint32 Count) GetNumberInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, out uint32 Count) GetNumberOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint32 EventFlags, out uint32 Count) GetNumberEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetQuitLockString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char8* String) SetQuitLockString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetQuitLockStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, char16* String) SetQuitLockStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, IDebugEventContextCallbacks* Callbacks) SetEventContextCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient7 self, void* Context, uint32 ContextSize) SetClientContext;
			}
		}
		[CRepr]
		public struct IDebugClient8 : IUnknown
		{
			public const new Guid IID = .(0xcec43add, 0x6375, 0x469e, 0x83, 0xd5, 0x41, 0x4e, 0x40, 0x33, 0xc1, 0x9a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AttachKernel(uint32 Flags, char8* ConnectOptions) mut => VT.AttachKernel(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptions(uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptions(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptions(char8* Options) mut => VT.SetKernelConnectionOptions(ref this, Options);
			public HResult StartProcessServer(uint32 Flags, char8* Options, void* Reserved) mut => VT.StartProcessServer(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServer(char8* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServer(ref this, RemoteOptions, out Server);
			public HResult DisconnectProcessServer(uint64 Server) mut => VT.DisconnectProcessServer(ref this, Server);
			public HResult GetRunningProcessSystemIds(uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) mut => VT.GetRunningProcessSystemIds(ref this, Server, Ids, Count, ActualCount);
			public HResult GetRunningProcessSystemIdByExecutableName(uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableName(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescription(uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescription(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult AttachProcess(uint64 Server, uint32 ProcessId, uint32 AttachFlags) mut => VT.AttachProcess(ref this, Server, ProcessId, AttachFlags);
			public HResult CreateProcessA(uint64 Server, char8* CommandLine, uint32 CreateFlags) mut => VT._CreateProcessA(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttach(uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult GetProcessOptions(out uint32 Options) mut => VT.GetProcessOptions(ref this, out Options);
			public HResult AddProcessOptions(uint32 Options) mut => VT.AddProcessOptions(ref this, Options);
			public HResult RemoveProcessOptions(uint32 Options) mut => VT.RemoveProcessOptions(ref this, Options);
			public HResult SetProcessOptions(uint32 Options) mut => VT.SetProcessOptions(ref this, Options);
			public HResult OpenDumpFile(char8* DumpFile) mut => VT.OpenDumpFile(ref this, DumpFile);
			public HResult WriteDumpFile(char8* DumpFile, uint32 Qualifier) mut => VT.WriteDumpFile(ref this, DumpFile, Qualifier);
			public HResult ConnectSession(uint32 Flags, uint32 HistoryLimit) mut => VT.ConnectSession(ref this, Flags, HistoryLimit);
			public HResult StartServer(char8* Options) mut => VT.StartServer(ref this, Options);
			public HResult OutputServers(uint32 OutputControl, char8* Machine, uint32 Flags) mut => VT.OutputServers(ref this, OutputControl, Machine, Flags);
			public HResult TerminateProcesses() mut => VT.TerminateProcesses(ref this);
			public HResult DetachProcesses() mut => VT.DetachProcesses(ref this);
			public HResult EndSession(uint32 Flags) mut => VT.EndSession(ref this, Flags);
			public HResult GetExitCode(out uint32 Code) mut => VT.GetExitCode(ref this, out Code);
			public HResult DispatchCallbacks(uint32 Timeout) mut => VT.DispatchCallbacks(ref this, Timeout);
			public HResult ExitDispatch(ref IDebugClient Client) mut => VT.ExitDispatch(ref this, ref Client);
			public HResult CreateClient(out IDebugClient* Client) mut => VT.CreateClient(ref this, out Client);
			public HResult GetInputCallbacks(out IDebugInputCallbacks* Callbacks) mut => VT.GetInputCallbacks(ref this, out Callbacks);
			public HResult SetInputCallbacks(IDebugInputCallbacks* Callbacks) mut => VT.SetInputCallbacks(ref this, Callbacks);
			public HResult GetOutputCallbacks(out IDebugOutputCallbacks* Callbacks) mut => VT.GetOutputCallbacks(ref this, out Callbacks);
			public HResult SetOutputCallbacks(IDebugOutputCallbacks* Callbacks) mut => VT.SetOutputCallbacks(ref this, Callbacks);
			public HResult GetOutputMask(out uint32 Mask) mut => VT.GetOutputMask(ref this, out Mask);
			public HResult SetOutputMask(uint32 Mask) mut => VT.SetOutputMask(ref this, Mask);
			public HResult GetOtherOutputMask(ref IDebugClient Client, out uint32 Mask) mut => VT.GetOtherOutputMask(ref this, ref Client, out Mask);
			public HResult SetOtherOutputMask(ref IDebugClient Client, uint32 Mask) mut => VT.SetOtherOutputMask(ref this, ref Client, Mask);
			public HResult GetOutputWidth(out uint32 Columns) mut => VT.GetOutputWidth(ref this, out Columns);
			public HResult SetOutputWidth(uint32 Columns) mut => VT.SetOutputWidth(ref this, Columns);
			public HResult GetOutputLinePrefix(uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefix(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefix(char8* Prefix) mut => VT.SetOutputLinePrefix(ref this, Prefix);
			public HResult GetIdentity(uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentity(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentity(uint32 OutputControl, uint32 Flags, char8* Format) mut => VT.OutputIdentity(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacks(out IDebugEventCallbacks* Callbacks) mut => VT.GetEventCallbacks(ref this, out Callbacks);
			public HResult SetEventCallbacks(IDebugEventCallbacks* Callbacks) mut => VT.SetEventCallbacks(ref this, Callbacks);
			public HResult FlushCallbacks() mut => VT.FlushCallbacks(ref this);
			public HResult WriteDumpFile2(char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) mut => VT.WriteDumpFile2(ref this, DumpFile, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFile(char8* InfoFile, uint32 Type) mut => VT.AddDumpInformationFile(ref this, InfoFile, Type);
			public HResult EndProcessServer(uint64 Server) mut => VT.EndProcessServer(ref this, Server);
			public HResult WaitForProcessServerEnd(uint32 Timeout) mut => VT.WaitForProcessServerEnd(ref this, Timeout);
			public HResult IsKernelDebuggerEnabled() mut => VT.IsKernelDebuggerEnabled(ref this);
			public HResult TerminateCurrentProcess() mut => VT.TerminateCurrentProcess(ref this);
			public HResult DetachCurrentProcess() mut => VT.DetachCurrentProcess(ref this);
			public HResult AbandonCurrentProcess() mut => VT.AbandonCurrentProcess(ref this);
			public HResult GetRunningProcessSystemIdByExecutableNameWide(uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) mut => VT.GetRunningProcessSystemIdByExecutableNameWide(ref this, Server, ExeName, Flags, out Id);
			public HResult GetRunningProcessDescriptionWide(uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) mut => VT.GetRunningProcessDescriptionWide(ref this, Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
			public HResult CreateProcessWide(uint64 Server, char16* CommandLine, uint32 CreateFlags) mut => VT.CreateProcessWide(ref this, Server, CommandLine, CreateFlags);
			public HResult CreateProcessAndAttachWide(uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttachWide(ref this, Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
			public HResult OpenDumpFileWide(char16* FileName, uint64 FileHandle) mut => VT.OpenDumpFileWide(ref this, FileName, FileHandle);
			public HResult WriteDumpFileWide(char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) mut => VT.WriteDumpFileWide(ref this, FileName, FileHandle, Qualifier, FormatFlags, Comment);
			public HResult AddDumpInformationFileWide(char16* FileName, uint64 FileHandle, uint32 Type) mut => VT.AddDumpInformationFileWide(ref this, FileName, FileHandle, Type);
			public HResult GetNumberDumpFiles(out uint32 Number) mut => VT.GetNumberDumpFiles(ref this, out Number);
			public HResult GetDumpFile(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFile(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);
			public HResult GetDumpFileWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) mut => VT.GetDumpFileWide(ref this, Index, Buffer, BufferSize, NameSize, Handle, out Type);
			public HResult AttachKernelWide(uint32 Flags, char16* ConnectOptions) mut => VT.AttachKernelWide(ref this, Flags, ConnectOptions);
			public HResult GetKernelConnectionOptionsWide(char16* Buffer, uint32 BufferSize, uint32* OptionsSize) mut => VT.GetKernelConnectionOptionsWide(ref this, Buffer, BufferSize, OptionsSize);
			public HResult SetKernelConnectionOptionsWide(char16* Options) mut => VT.SetKernelConnectionOptionsWide(ref this, Options);
			public HResult StartProcessServerWide(uint32 Flags, char16* Options, void* Reserved) mut => VT.StartProcessServerWide(ref this, Flags, Options, Reserved);
			public HResult ConnectProcessServerWide(char16* RemoteOptions, out uint64 Server) mut => VT.ConnectProcessServerWide(ref this, RemoteOptions, out Server);
			public HResult StartServerWide(char16* Options) mut => VT.StartServerWide(ref this, Options);
			public HResult OutputServersWide(uint32 OutputControl, char16* Machine, uint32 Flags) mut => VT.OutputServersWide(ref this, OutputControl, Machine, Flags);
			public HResult GetOutputCallbacksWide(out IDebugOutputCallbacksWide* Callbacks) mut => VT.GetOutputCallbacksWide(ref this, out Callbacks);
			public HResult SetOutputCallbacksWide(ref IDebugOutputCallbacksWide Callbacks) mut => VT.SetOutputCallbacksWide(ref this, ref Callbacks);
			public HResult GetOutputLinePrefixWide(char16* Buffer, uint32 BufferSize, uint32* PrefixSize) mut => VT.GetOutputLinePrefixWide(ref this, Buffer, BufferSize, PrefixSize);
			public HResult SetOutputLinePrefixWide(char16* Prefix) mut => VT.SetOutputLinePrefixWide(ref this, Prefix);
			public HResult GetIdentityWide(char16* Buffer, uint32 BufferSize, uint32* IdentitySize) mut => VT.GetIdentityWide(ref this, Buffer, BufferSize, IdentitySize);
			public HResult OutputIdentityWide(uint32 OutputControl, uint32 Flags, char16* Format) mut => VT.OutputIdentityWide(ref this, OutputControl, Flags, Format);
			public HResult GetEventCallbacksWide(out IDebugEventCallbacksWide* Callbacks) mut => VT.GetEventCallbacksWide(ref this, out Callbacks);
			public HResult SetEventCallbacksWide(ref IDebugEventCallbacksWide Callbacks) mut => VT.SetEventCallbacksWide(ref this, ref Callbacks);
			public HResult CreateProcess2(uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment) mut => VT.CreateProcess2(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
			public HResult CreateProcess2Wide(uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment) mut => VT.CreateProcess2Wide(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
			public HResult CreateProcessAndAttach2(uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach2(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
			public HResult CreateProcessAndAttach2Wide(uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment, uint32 ProcessId, uint32 AttachFlags) mut => VT.CreateProcessAndAttach2Wide(ref this, Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
			public HResult PushOutputLinePrefix(char8* NewPrefix, out uint64 Handle) mut => VT.PushOutputLinePrefix(ref this, NewPrefix, out Handle);
			public HResult PushOutputLinePrefixWide(char16* NewPrefix, out uint64 Handle) mut => VT.PushOutputLinePrefixWide(ref this, NewPrefix, out Handle);
			public HResult PopOutputLinePrefix(uint64 Handle) mut => VT.PopOutputLinePrefix(ref this, Handle);
			public HResult GetNumberInputCallbacks(out uint32 Count) mut => VT.GetNumberInputCallbacks(ref this, out Count);
			public HResult GetNumberOutputCallbacks(out uint32 Count) mut => VT.GetNumberOutputCallbacks(ref this, out Count);
			public HResult GetNumberEventCallbacks(uint32 EventFlags, out uint32 Count) mut => VT.GetNumberEventCallbacks(ref this, EventFlags, out Count);
			public HResult GetQuitLockString(uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetQuitLockString(ref this, Buffer, BufferSize, StringSize);
			public HResult SetQuitLockString(char8* String) mut => VT.SetQuitLockString(ref this, String);
			public HResult GetQuitLockStringWide(char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetQuitLockStringWide(ref this, Buffer, BufferSize, StringSize);
			public HResult SetQuitLockStringWide(char16* String) mut => VT.SetQuitLockStringWide(ref this, String);
			public HResult SetEventContextCallbacks(IDebugEventContextCallbacks* Callbacks) mut => VT.SetEventContextCallbacks(ref this, Callbacks);
			public HResult SetClientContext(void* Context, uint32 ContextSize) mut => VT.SetClientContext(ref this, Context, ContextSize);
			public HResult OpenDumpFileWide2(char16* FileName, uint64 FileHandle, uint32 AlternateArch) mut => VT.OpenDumpFileWide2(ref this, FileName, FileHandle, AlternateArch);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Flags, char8* ConnectOptions) AttachKernel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint8* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* Options) SetKernelConnectionOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Flags, char8* Options, void* Reserved) StartProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* RemoteOptions, out uint64 Server) ConnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server) DisconnectProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, uint32* Ids, uint32 Count, uint32* ActualCount) GetRunningProcessSystemIds;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char8* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, uint32 SystemId, uint32 Flags, uint8* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, uint8* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, uint32 ProcessId, uint32 AttachFlags) AttachProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char8* CommandLine, uint32 CreateFlags) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char8* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out uint32 Options) GetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Options) AddProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Options) RemoveProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Options) SetProcessOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* DumpFile) OpenDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* DumpFile, uint32 Qualifier) WriteDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Flags, uint32 HistoryLimit) ConnectSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* Options) StartServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 OutputControl, char8* Machine, uint32 Flags) OutputServers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self) TerminateProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self) DetachProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Flags) EndSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out uint32 Code) GetExitCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Timeout) DispatchCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, ref IDebugClient Client) ExitDispatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out IDebugClient* Client) CreateClient;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out IDebugInputCallbacks* Callbacks) GetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, IDebugInputCallbacks* Callbacks) SetInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out IDebugOutputCallbacks* Callbacks) GetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, IDebugOutputCallbacks* Callbacks) SetOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out uint32 Mask) GetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Mask) SetOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, ref IDebugClient Client, out uint32 Mask) GetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, ref IDebugClient Client, uint32 Mask) SetOtherOutputMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out uint32 Columns) GetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Columns) SetOutputWidth;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint8* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* Prefix) SetOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint8* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 OutputControl, uint32 Flags, char8* Format) OutputIdentity;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out IDebugEventCallbacks* Callbacks) GetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, IDebugEventCallbacks* Callbacks) SetEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self) FlushCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* DumpFile, uint32 Qualifier, uint32 FormatFlags, char8* Comment) WriteDumpFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* InfoFile, uint32 Type) AddDumpInformationFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server) EndProcessServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Timeout) WaitForProcessServerEnd;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self) IsKernelDebuggerEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self) TerminateCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self) DetachCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self) AbandonCurrentProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char16* ExeName, uint32 Flags, out uint32 Id) GetRunningProcessSystemIdByExecutableNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, uint32 SystemId, uint32 Flags, char16* ExeName, uint32 ExeNameSize, uint32* ActualExeNameSize, char16* Description, uint32 DescriptionSize, uint32* ActualDescriptionSize) GetRunningProcessDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char16* CommandLine, uint32 CreateFlags) CreateProcessWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char16* CommandLine, uint32 CreateFlags, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttachWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* FileName, uint64 FileHandle) OpenDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* FileName, uint64 FileHandle, uint32 Qualifier, uint32 FormatFlags, char16* Comment) WriteDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* FileName, uint64 FileHandle, uint32 Type) AddDumpInformationFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out uint32 Number) GetNumberDumpFiles;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize, uint64* Handle, out uint32 Type) GetDumpFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Flags, char16* ConnectOptions) AttachKernelWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* Buffer, uint32 BufferSize, uint32* OptionsSize) GetKernelConnectionOptionsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* Options) SetKernelConnectionOptionsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 Flags, char16* Options, void* Reserved) StartProcessServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* RemoteOptions, out uint64 Server) ConnectProcessServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* Options) StartServerWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 OutputControl, char16* Machine, uint32 Flags) OutputServersWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out IDebugOutputCallbacksWide* Callbacks) GetOutputCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, ref IDebugOutputCallbacksWide Callbacks) SetOutputCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* Buffer, uint32 BufferSize, uint32* PrefixSize) GetOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* Prefix) SetOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* Buffer, uint32 BufferSize, uint32* IdentitySize) GetIdentityWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 OutputControl, uint32 Flags, char16* Format) OutputIdentityWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out IDebugEventCallbacksWide* Callbacks) GetEventCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, ref IDebugEventCallbacksWide Callbacks) SetEventCallbacksWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment) CreateProcess2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment) CreateProcess2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char8* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char8* InitialDirectory, char8* Environment, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Server, char16* CommandLine, void* OptionsBuffer, uint32 OptionsBufferSize, char16* InitialDirectory, char16* Environment, uint32 ProcessId, uint32 AttachFlags) CreateProcessAndAttach2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* NewPrefix, out uint64 Handle) PushOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* NewPrefix, out uint64 Handle) PushOutputLinePrefixWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint64 Handle) PopOutputLinePrefix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out uint32 Count) GetNumberInputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, out uint32 Count) GetNumberOutputCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint32 EventFlags, out uint32 Count) GetNumberEventCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetQuitLockString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char8* String) SetQuitLockString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetQuitLockStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* String) SetQuitLockStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, IDebugEventContextCallbacks* Callbacks) SetEventContextCallbacks;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, void* Context, uint32 ContextSize) SetClientContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugClient8 self, char16* FileName, uint64 FileHandle, uint32 AlternateArch) OpenDumpFileWide2;
			}
		}
		[CRepr]
		public struct IDebugPlmClient : IUnknown
		{
			public const new Guid IID = .(0xa02b66c4, 0xaea3, 0x4234, 0xa9, 0xf7, 0xfe, 0x4c, 0x38, 0x3d, 0x4e, 0x29);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult LaunchPlmPackageForDebugWide(uint64 Server, uint32 Timeout, char16* PackageFullName, char16* AppName, char16* Arguments, out uint32 ProcessId, out uint32 ThreadId) mut => VT.LaunchPlmPackageForDebugWide(ref this, Server, Timeout, PackageFullName, AppName, Arguments, out ProcessId, out ThreadId);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient self, uint64 Server, uint32 Timeout, char16* PackageFullName, char16* AppName, char16* Arguments, out uint32 ProcessId, out uint32 ThreadId) LaunchPlmPackageForDebugWide;
			}
		}
		[CRepr]
		public struct IDebugPlmClient2 : IUnknown
		{
			public const new Guid IID = .(0x597c980d, 0xe7bd, 0x4309, 0x96, 0x2c, 0x9d, 0x9b, 0x69, 0xa7, 0x37, 0x2c);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult LaunchPlmPackageForDebugWide(uint64 Server, uint32 Timeout, char16* PackageFullName, char16* AppName, char16* Arguments, out uint32 ProcessId, out uint32 ThreadId) mut => VT.LaunchPlmPackageForDebugWide(ref this, Server, Timeout, PackageFullName, AppName, Arguments, out ProcessId, out ThreadId);
			public HResult LaunchPlmBgTaskForDebugWide(uint64 Server, uint32 Timeout, char16* PackageFullName, char16* BackgroundTaskId, out uint32 ProcessId, out uint32 ThreadId) mut => VT.LaunchPlmBgTaskForDebugWide(ref this, Server, Timeout, PackageFullName, BackgroundTaskId, out ProcessId, out ThreadId);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient2 self, uint64 Server, uint32 Timeout, char16* PackageFullName, char16* AppName, char16* Arguments, out uint32 ProcessId, out uint32 ThreadId) LaunchPlmPackageForDebugWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient2 self, uint64 Server, uint32 Timeout, char16* PackageFullName, char16* BackgroundTaskId, out uint32 ProcessId, out uint32 ThreadId) LaunchPlmBgTaskForDebugWide;
			}
		}
		[CRepr]
		public struct IDebugPlmClient3 : IUnknown
		{
			public const new Guid IID = .(0xd4a5dbd1, 0xca02, 0x4d90, 0x85, 0x6a, 0x2a, 0x92, 0xbf, 0xd0, 0xf2, 0x0f);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult LaunchPlmPackageForDebugWide(uint64 Server, uint32 Timeout, char16* PackageFullName, char16* AppName, char16* Arguments, out uint32 ProcessId, out uint32 ThreadId) mut => VT.LaunchPlmPackageForDebugWide(ref this, Server, Timeout, PackageFullName, AppName, Arguments, out ProcessId, out ThreadId);
			public HResult LaunchPlmBgTaskForDebugWide(uint64 Server, uint32 Timeout, char16* PackageFullName, char16* BackgroundTaskId, out uint32 ProcessId, out uint32 ThreadId) mut => VT.LaunchPlmBgTaskForDebugWide(ref this, Server, Timeout, PackageFullName, BackgroundTaskId, out ProcessId, out ThreadId);
			public HResult QueryPlmPackageWide(uint64 Server, char16* PackageFullName, ref IDebugOutputStream Stream) mut => VT.QueryPlmPackageWide(ref this, Server, PackageFullName, ref Stream);
			public HResult QueryPlmPackageList(uint64 Server, ref IDebugOutputStream Stream) mut => VT.QueryPlmPackageList(ref this, Server, ref Stream);
			public HResult EnablePlmPackageDebugWide(uint64 Server, char16* PackageFullName) mut => VT.EnablePlmPackageDebugWide(ref this, Server, PackageFullName);
			public HResult DisablePlmPackageDebugWide(uint64 Server, char16* PackageFullName) mut => VT.DisablePlmPackageDebugWide(ref this, Server, PackageFullName);
			public HResult SuspendPlmPackageWide(uint64 Server, char16* PackageFullName) mut => VT.SuspendPlmPackageWide(ref this, Server, PackageFullName);
			public HResult ResumePlmPackageWide(uint64 Server, char16* PackageFullName) mut => VT.ResumePlmPackageWide(ref this, Server, PackageFullName);
			public HResult TerminatePlmPackageWide(uint64 Server, char16* PackageFullName) mut => VT.TerminatePlmPackageWide(ref this, Server, PackageFullName);
			public HResult LaunchAndDebugPlmAppWide(uint64 Server, char16* PackageFullName, char16* AppName, char16* Arguments) mut => VT.LaunchAndDebugPlmAppWide(ref this, Server, PackageFullName, AppName, Arguments);
			public HResult ActivateAndDebugPlmBgTaskWide(uint64 Server, char16* PackageFullName, char16* BackgroundTaskId) mut => VT.ActivateAndDebugPlmBgTaskWide(ref this, Server, PackageFullName, BackgroundTaskId);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, uint32 Timeout, char16* PackageFullName, char16* AppName, char16* Arguments, out uint32 ProcessId, out uint32 ThreadId) LaunchPlmPackageForDebugWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, uint32 Timeout, char16* PackageFullName, char16* BackgroundTaskId, out uint32 ProcessId, out uint32 ThreadId) LaunchPlmBgTaskForDebugWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, char16* PackageFullName, ref IDebugOutputStream Stream) QueryPlmPackageWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, ref IDebugOutputStream Stream) QueryPlmPackageList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, char16* PackageFullName) EnablePlmPackageDebugWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, char16* PackageFullName) DisablePlmPackageDebugWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, char16* PackageFullName) SuspendPlmPackageWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, char16* PackageFullName) ResumePlmPackageWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, char16* PackageFullName) TerminatePlmPackageWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, char16* PackageFullName, char16* AppName, char16* Arguments) LaunchAndDebugPlmAppWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPlmClient3 self, uint64 Server, char16* PackageFullName, char16* BackgroundTaskId) ActivateAndDebugPlmBgTaskWide;
			}
		}
		[CRepr]
		public struct IDebugOutputStream : IUnknown
		{
			public const new Guid IID = .(0x7782d8f2, 0x2b85, 0x4059, 0xab, 0x88, 0x28, 0xce, 0xdd, 0xca, 0x1c, 0x80);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Write(char16* psz) mut => VT.Write(ref this, psz);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugOutputStream self, char16* psz) Write;
			}
		}
		[CRepr]
		public struct IDebugControl : IUnknown
		{
			public const new Guid IID = .(0x5182e668, 0x105e, 0x416e, 0xad, 0x92, 0x24, 0xef, 0x80, 0x04, 0x24, 0xba);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterrupt() mut => VT.GetInterrupt(ref this);
			public HResult SetInterrupt(uint32 Flags) mut => VT.SetInterrupt(ref this, Flags);
			public HResult GetInterruptTimeout(out uint32 Seconds) mut => VT.GetInterruptTimeout(ref this, out Seconds);
			public HResult SetInterruptTimeout(uint32 Seconds) mut => VT.SetInterruptTimeout(ref this, Seconds);
			public HResult GetLogFile(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFile(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFile(char8* File, IntBool Append) mut => VT.OpenLogFile(ref this, File, Append);
			public HResult CloseLogFile() mut => VT.CloseLogFile(ref this);
			public HResult GetLogMask(out uint32 Mask) mut => VT.GetLogMask(ref this, out Mask);
			public HResult SetLogMask(uint32 Mask) mut => VT.SetLogMask(ref this, Mask);
			public HResult Input(uint8* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.Input(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInput(char8* Buffer) mut => VT.ReturnInput(ref this, Buffer);
			public HResult Output(uint32 Mask, char8* Format) mut => VT.Output(ref this, Mask, Format);
			public HResult OutputVaList(uint32 Mask, char8* Format, ref int8 Args) mut => VT.OutputVaList(ref this, Mask, Format, ref Args);
			public HResult ControlledOutput(uint32 OutputControl, uint32 Mask, char8* Format) mut => VT.ControlledOutput(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaList(uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) mut => VT.ControlledOutputVaList(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPrompt(uint32 OutputControl, char8* Format) mut => VT.OutputPrompt(ref this, OutputControl, Format);
			public HResult OutputPromptVaList(uint32 OutputControl, char8* Format, ref int8 Args) mut => VT.OutputPromptVaList(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptText(uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptText(ref this, Buffer, BufferSize, TextSize);
			public HResult OutputCurrentState(uint32 OutputControl, uint32 Flags) mut => VT.OutputCurrentState(ref this, OutputControl, Flags);
			public HResult OutputVersionInformation(uint32 OutputControl) mut => VT.OutputVersionInformation(ref this, OutputControl);
			public HResult GetNotifyEventHandle(out uint64 Handle) mut => VT.GetNotifyEventHandle(ref this, out Handle);
			public HResult SetNotifyEventHandle(uint64 Handle) mut => VT.SetNotifyEventHandle(ref this, Handle);
			public HResult Assemble(uint64 Offset, char8* Instr, out uint64 EndOffset) mut => VT.Assemble(ref this, Offset, Instr, out EndOffset);
			public HResult Disassemble(uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.Disassemble(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetDisassembleEffectiveOffset(out uint64 Offset) mut => VT.GetDisassembleEffectiveOffset(ref this, out Offset);
			public HResult OutputDisassembly(uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) mut => VT.OutputDisassembly(ref this, OutputControl, Offset, Flags, out EndOffset);
			public HResult OutputDisassemblyLines(uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) mut => VT.OutputDisassemblyLines(ref this, OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
			public HResult GetNearInstruction(uint64 Offset, int32 Delta, out uint64 NearOffset) mut => VT.GetNearInstruction(ref this, Offset, Delta, out NearOffset);
			public HResult GetStackTrace(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTrace(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult GetReturnOffset(out uint64 Offset) mut => VT.GetReturnOffset(ref this, out Offset);
			public HResult OutputStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTrace(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetDebuggeeType(out uint32 Class, out uint32 Qualifier) mut => VT.GetDebuggeeType(ref this, out Class, out Qualifier);
			public HResult GetActualProcessorType(out uint32 Type) mut => VT.GetActualProcessorType(ref this, out Type);
			public HResult GetExecutingProcessorType(out uint32 Type) mut => VT.GetExecutingProcessorType(ref this, out Type);
			public HResult GetNumberPossibleExecutingProcessorTypes(out uint32 Number) mut => VT.GetNumberPossibleExecutingProcessorTypes(ref this, out Number);
			public HResult GetPossibleExecutingProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetPossibleExecutingProcessorTypes(ref this, Start, Count, Types);
			public HResult GetNumberProcessors(out uint32 Number) mut => VT.GetNumberProcessors(ref this, out Number);
			public HResult GetSystemVersion(out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) mut => VT.GetSystemVersion(ref this, out PlatformId, out Major, out Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, out ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
			public HResult GetPageSize(out uint32 Size) mut => VT.GetPageSize(ref this, out Size);
			public HResult IsPointer64Bit() mut => VT.IsPointer64Bit(ref this);
			public HResult ReadBugCheckData(out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) mut => VT.ReadBugCheckData(ref this, out Code, out Arg1, out Arg2, out Arg3, out Arg4);
			public HResult GetNumberSupportedProcessorTypes(out uint32 Number) mut => VT.GetNumberSupportedProcessorTypes(ref this, out Number);
			public HResult GetSupportedProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetSupportedProcessorTypes(ref this, Start, Count, Types);
			public HResult GetProcessorTypeNames(uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNames(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEffectiveProcessorType(out uint32 Type) mut => VT.GetEffectiveProcessorType(ref this, out Type);
			public HResult SetEffectiveProcessorType(uint32 Type) mut => VT.SetEffectiveProcessorType(ref this, Type);
			public HResult GetExecutionStatus(out uint32 Status) mut => VT.GetExecutionStatus(ref this, out Status);
			public HResult SetExecutionStatus(uint32 Status) mut => VT.SetExecutionStatus(ref this, Status);
			public HResult GetCodeLevel(out uint32 Level) mut => VT.GetCodeLevel(ref this, out Level);
			public HResult SetCodeLevel(uint32 Level) mut => VT.SetCodeLevel(ref this, Level);
			public HResult GetEngineOptions(out uint32 Options) mut => VT.GetEngineOptions(ref this, out Options);
			public HResult AddEngineOptions(uint32 Options) mut => VT.AddEngineOptions(ref this, Options);
			public HResult RemoveEngineOptions(uint32 Options) mut => VT.RemoveEngineOptions(ref this, Options);
			public HResult SetEngineOptions(uint32 Options) mut => VT.SetEngineOptions(ref this, Options);
			public HResult GetSystemErrorControl(out uint32 OutputLevel, out uint32 BreakLevel) mut => VT.GetSystemErrorControl(ref this, out OutputLevel, out BreakLevel);
			public HResult SetSystemErrorControl(uint32 OutputLevel, uint32 BreakLevel) mut => VT.SetSystemErrorControl(ref this, OutputLevel, BreakLevel);
			public HResult GetTextMacro(uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacro(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacro(uint32 Slot, char8* Macro) mut => VT.SetTextMacro(ref this, Slot, Macro);
			public HResult GetRadix(out uint32 Radix) mut => VT.GetRadix(ref this, out Radix);
			public HResult SetRadix(uint32 Radix) mut => VT.SetRadix(ref this, Radix);
			public HResult Evaluate(char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.Evaluate(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult CoerceValue(ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) mut => VT.CoerceValue(ref this, ref In, OutType, out Out);
			public HResult CoerceValues(uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) mut => VT.CoerceValues(ref this, Count, In, OutTypes, Out);
			public HResult Execute(uint32 OutputControl, char8* Command, uint32 Flags) mut => VT.Execute(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFile(uint32 OutputControl, char8* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFile(ref this, OutputControl, CommandFile, Flags);
			public HResult GetNumberBreakpoints(out uint32 Number) mut => VT.GetNumberBreakpoints(ref this, out Number);
			public HResult GetBreakpointByIndex(uint32 Index, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointByIndex(ref this, Index, out Bp);
			public HResult GetBreakpointById(uint32 Id, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointById(ref this, Id, out Bp);
			public HResult GetBreakpointParameters(uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) mut => VT.GetBreakpointParameters(ref this, Count, Ids, Start, Params);
			public HResult AddBreakpoint(uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) mut => VT.AddBreakpoint(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint(ref IDebugBreakpoint Bp) mut => VT.RemoveBreakpoint(ref this, ref Bp);
			public HResult AddExtension(char8* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtension(ref this, Path, Flags, out Handle);
			public HResult RemoveExtension(uint64 Handle) mut => VT.RemoveExtension(ref this, Handle);
			public HResult GetExtensionByPath(char8* Path, out uint64 Handle) mut => VT.GetExtensionByPath(ref this, Path, out Handle);
			public HResult CallExtension(uint64 Handle, char8* Function, char8* Arguments) mut => VT.CallExtension(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunction(uint64 Handle, char8* FuncName, out FARPROC Function) mut => VT.GetExtensionFunction(ref this, Handle, FuncName, out Function);
			public HResult GetWindbgExtensionApis32(out WINDBG_EXTENSION_APIS32 Api) mut => VT.GetWindbgExtensionApis32(ref this, out Api);
			public HResult GetWindbgExtensionApis64(out WINDBG_EXTENSION_APIS64 Api) mut => VT.GetWindbgExtensionApis64(ref this, out Api);
			public HResult GetNumberEventFilters(out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) mut => VT.GetNumberEventFilters(ref this, out SpecificEvents, out SpecificExceptions, out ArbitraryExceptions);
			public HResult GetEventFilterText(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterText(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommand(uint32 Index, char8* Command) mut => VT.SetEventFilterCommand(ref this, Index, Command);
			public HResult GetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.GetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult SetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.SetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult GetSpecificFilterArgument(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgument(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgument(uint32 Index, char8* Argument) mut => VT.SetSpecificFilterArgument(ref this, Index, Argument);
			public HResult GetExceptionFilterParameters(uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.GetExceptionFilterParameters(ref this, Count, Codes, Start, Params);
			public HResult SetExceptionFilterParameters(uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.SetExceptionFilterParameters(ref this, Count, Params);
			public HResult GetExceptionFilterSecondCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommand(uint32 Index, char8* Command) mut => VT.SetExceptionFilterSecondCommand(ref this, Index, Command);
			public HResult WaitForEvent(uint32 Flags, uint32 Timeout) mut => VT.WaitForEvent(ref this, Flags, Timeout);
			public HResult GetLastEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformation(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self) GetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Flags) SetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Seconds) GetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Seconds) SetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, char8* File, IntBool Append) OpenLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self) CloseLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Mask) GetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Mask) SetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint8* Buffer, uint32 BufferSize, uint32* InputSize) Input;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, char8* Buffer) ReturnInput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Mask, char8* Format) Output;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Mask, char8* Format, ref int8 Args) OutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, uint32 Mask, char8* Format) ControlledOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) ControlledOutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, char8* Format) OutputPrompt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, char8* Format, ref int8 Args) OutputPromptVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, uint32 Flags) OutputCurrentState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl) OutputVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint64 Handle) GetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint64 Handle) SetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint64 Offset, char8* Instr, out uint64 EndOffset) Assemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) Disassemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint64 Offset) GetDisassembleEffectiveOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) OutputDisassembly;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) OutputDisassemblyLines;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint64 Offset, int32 Delta, out uint64 NearOffset) GetNearInstruction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint64 Offset) GetReturnOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) OutputStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Class, out uint32 Qualifier) GetDebuggeeType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Type) GetActualProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Type) GetExecutingProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Number) GetNumberPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Start, uint32 Count, uint32* Types) GetPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Number) GetNumberProcessors;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) GetSystemVersion;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Size) GetPageSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self) IsPointer64Bit;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) ReadBugCheckData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Number) GetNumberSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Start, uint32 Count, uint32* Types) GetSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Type) GetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Type) SetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Status) GetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Status) SetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Level) GetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Level) SetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Options) GetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Options) AddEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Options) RemoveEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Options) SetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 OutputLevel, out uint32 BreakLevel) GetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputLevel, uint32 BreakLevel) SetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Slot, char8* Macro) SetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Radix) GetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Radix) SetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) Evaluate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) CoerceValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) CoerceValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, char8* Command, uint32 Flags) Execute;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 OutputControl, char8* CommandFile, uint32 Flags) ExecuteCommandFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Number) GetNumberBreakpoints;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Index, out IDebugBreakpoint* Bp) GetBreakpointByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Id, out IDebugBreakpoint* Bp) GetBreakpointById;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) GetBreakpointParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) AddBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, ref IDebugBreakpoint Bp) RemoveBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, char8* Path, uint32 Flags, out uint64 Handle) AddExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint64 Handle) RemoveExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, char8* Path, out uint64 Handle) GetExtensionByPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint64 Handle, char8* Function, char8* Arguments) CallExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint64 Handle, char8* FuncName, out FARPROC Function) GetExtensionFunction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out WINDBG_EXTENSION_APIS32 Api) GetWindbgExtensionApis32;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out WINDBG_EXTENSION_APIS64 Api) GetWindbgExtensionApis64;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) GetNumberEventFilters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Index, char8* Command) SetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) GetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) SetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Index, char8* Argument) SetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) GetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) SetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Index, char8* Command) SetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, uint32 Flags, uint32 Timeout) WaitForEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformation;
			}
		}
		[CRepr]
		public struct IDebugControl2 : IUnknown
		{
			public const new Guid IID = .(0xd4366723, 0x44df, 0x4bed, 0x8c, 0x7e, 0x4c, 0x05, 0x42, 0x4f, 0x45, 0x88);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterrupt() mut => VT.GetInterrupt(ref this);
			public HResult SetInterrupt(uint32 Flags) mut => VT.SetInterrupt(ref this, Flags);
			public HResult GetInterruptTimeout(out uint32 Seconds) mut => VT.GetInterruptTimeout(ref this, out Seconds);
			public HResult SetInterruptTimeout(uint32 Seconds) mut => VT.SetInterruptTimeout(ref this, Seconds);
			public HResult GetLogFile(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFile(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFile(char8* File, IntBool Append) mut => VT.OpenLogFile(ref this, File, Append);
			public HResult CloseLogFile() mut => VT.CloseLogFile(ref this);
			public HResult GetLogMask(out uint32 Mask) mut => VT.GetLogMask(ref this, out Mask);
			public HResult SetLogMask(uint32 Mask) mut => VT.SetLogMask(ref this, Mask);
			public HResult Input(uint8* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.Input(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInput(char8* Buffer) mut => VT.ReturnInput(ref this, Buffer);
			public HResult Output(uint32 Mask, char8* Format) mut => VT.Output(ref this, Mask, Format);
			public HResult OutputVaList(uint32 Mask, char8* Format, ref int8 Args) mut => VT.OutputVaList(ref this, Mask, Format, ref Args);
			public HResult ControlledOutput(uint32 OutputControl, uint32 Mask, char8* Format) mut => VT.ControlledOutput(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaList(uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) mut => VT.ControlledOutputVaList(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPrompt(uint32 OutputControl, char8* Format) mut => VT.OutputPrompt(ref this, OutputControl, Format);
			public HResult OutputPromptVaList(uint32 OutputControl, char8* Format, ref int8 Args) mut => VT.OutputPromptVaList(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptText(uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptText(ref this, Buffer, BufferSize, TextSize);
			public HResult OutputCurrentState(uint32 OutputControl, uint32 Flags) mut => VT.OutputCurrentState(ref this, OutputControl, Flags);
			public HResult OutputVersionInformation(uint32 OutputControl) mut => VT.OutputVersionInformation(ref this, OutputControl);
			public HResult GetNotifyEventHandle(out uint64 Handle) mut => VT.GetNotifyEventHandle(ref this, out Handle);
			public HResult SetNotifyEventHandle(uint64 Handle) mut => VT.SetNotifyEventHandle(ref this, Handle);
			public HResult Assemble(uint64 Offset, char8* Instr, out uint64 EndOffset) mut => VT.Assemble(ref this, Offset, Instr, out EndOffset);
			public HResult Disassemble(uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.Disassemble(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetDisassembleEffectiveOffset(out uint64 Offset) mut => VT.GetDisassembleEffectiveOffset(ref this, out Offset);
			public HResult OutputDisassembly(uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) mut => VT.OutputDisassembly(ref this, OutputControl, Offset, Flags, out EndOffset);
			public HResult OutputDisassemblyLines(uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) mut => VT.OutputDisassemblyLines(ref this, OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
			public HResult GetNearInstruction(uint64 Offset, int32 Delta, out uint64 NearOffset) mut => VT.GetNearInstruction(ref this, Offset, Delta, out NearOffset);
			public HResult GetStackTrace(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTrace(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult GetReturnOffset(out uint64 Offset) mut => VT.GetReturnOffset(ref this, out Offset);
			public HResult OutputStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTrace(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetDebuggeeType(out uint32 Class, out uint32 Qualifier) mut => VT.GetDebuggeeType(ref this, out Class, out Qualifier);
			public HResult GetActualProcessorType(out uint32 Type) mut => VT.GetActualProcessorType(ref this, out Type);
			public HResult GetExecutingProcessorType(out uint32 Type) mut => VT.GetExecutingProcessorType(ref this, out Type);
			public HResult GetNumberPossibleExecutingProcessorTypes(out uint32 Number) mut => VT.GetNumberPossibleExecutingProcessorTypes(ref this, out Number);
			public HResult GetPossibleExecutingProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetPossibleExecutingProcessorTypes(ref this, Start, Count, Types);
			public HResult GetNumberProcessors(out uint32 Number) mut => VT.GetNumberProcessors(ref this, out Number);
			public HResult GetSystemVersion(out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) mut => VT.GetSystemVersion(ref this, out PlatformId, out Major, out Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, out ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
			public HResult GetPageSize(out uint32 Size) mut => VT.GetPageSize(ref this, out Size);
			public HResult IsPointer64Bit() mut => VT.IsPointer64Bit(ref this);
			public HResult ReadBugCheckData(out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) mut => VT.ReadBugCheckData(ref this, out Code, out Arg1, out Arg2, out Arg3, out Arg4);
			public HResult GetNumberSupportedProcessorTypes(out uint32 Number) mut => VT.GetNumberSupportedProcessorTypes(ref this, out Number);
			public HResult GetSupportedProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetSupportedProcessorTypes(ref this, Start, Count, Types);
			public HResult GetProcessorTypeNames(uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNames(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEffectiveProcessorType(out uint32 Type) mut => VT.GetEffectiveProcessorType(ref this, out Type);
			public HResult SetEffectiveProcessorType(uint32 Type) mut => VT.SetEffectiveProcessorType(ref this, Type);
			public HResult GetExecutionStatus(out uint32 Status) mut => VT.GetExecutionStatus(ref this, out Status);
			public HResult SetExecutionStatus(uint32 Status) mut => VT.SetExecutionStatus(ref this, Status);
			public HResult GetCodeLevel(out uint32 Level) mut => VT.GetCodeLevel(ref this, out Level);
			public HResult SetCodeLevel(uint32 Level) mut => VT.SetCodeLevel(ref this, Level);
			public HResult GetEngineOptions(out uint32 Options) mut => VT.GetEngineOptions(ref this, out Options);
			public HResult AddEngineOptions(uint32 Options) mut => VT.AddEngineOptions(ref this, Options);
			public HResult RemoveEngineOptions(uint32 Options) mut => VT.RemoveEngineOptions(ref this, Options);
			public HResult SetEngineOptions(uint32 Options) mut => VT.SetEngineOptions(ref this, Options);
			public HResult GetSystemErrorControl(out uint32 OutputLevel, out uint32 BreakLevel) mut => VT.GetSystemErrorControl(ref this, out OutputLevel, out BreakLevel);
			public HResult SetSystemErrorControl(uint32 OutputLevel, uint32 BreakLevel) mut => VT.SetSystemErrorControl(ref this, OutputLevel, BreakLevel);
			public HResult GetTextMacro(uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacro(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacro(uint32 Slot, char8* Macro) mut => VT.SetTextMacro(ref this, Slot, Macro);
			public HResult GetRadix(out uint32 Radix) mut => VT.GetRadix(ref this, out Radix);
			public HResult SetRadix(uint32 Radix) mut => VT.SetRadix(ref this, Radix);
			public HResult Evaluate(char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.Evaluate(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult CoerceValue(ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) mut => VT.CoerceValue(ref this, ref In, OutType, out Out);
			public HResult CoerceValues(uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) mut => VT.CoerceValues(ref this, Count, In, OutTypes, Out);
			public HResult Execute(uint32 OutputControl, char8* Command, uint32 Flags) mut => VT.Execute(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFile(uint32 OutputControl, char8* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFile(ref this, OutputControl, CommandFile, Flags);
			public HResult GetNumberBreakpoints(out uint32 Number) mut => VT.GetNumberBreakpoints(ref this, out Number);
			public HResult GetBreakpointByIndex(uint32 Index, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointByIndex(ref this, Index, out Bp);
			public HResult GetBreakpointById(uint32 Id, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointById(ref this, Id, out Bp);
			public HResult GetBreakpointParameters(uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) mut => VT.GetBreakpointParameters(ref this, Count, Ids, Start, Params);
			public HResult AddBreakpoint(uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) mut => VT.AddBreakpoint(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint(ref IDebugBreakpoint Bp) mut => VT.RemoveBreakpoint(ref this, ref Bp);
			public HResult AddExtension(char8* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtension(ref this, Path, Flags, out Handle);
			public HResult RemoveExtension(uint64 Handle) mut => VT.RemoveExtension(ref this, Handle);
			public HResult GetExtensionByPath(char8* Path, out uint64 Handle) mut => VT.GetExtensionByPath(ref this, Path, out Handle);
			public HResult CallExtension(uint64 Handle, char8* Function, char8* Arguments) mut => VT.CallExtension(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunction(uint64 Handle, char8* FuncName, out FARPROC Function) mut => VT.GetExtensionFunction(ref this, Handle, FuncName, out Function);
			public HResult GetWindbgExtensionApis32(out WINDBG_EXTENSION_APIS32 Api) mut => VT.GetWindbgExtensionApis32(ref this, out Api);
			public HResult GetWindbgExtensionApis64(out WINDBG_EXTENSION_APIS64 Api) mut => VT.GetWindbgExtensionApis64(ref this, out Api);
			public HResult GetNumberEventFilters(out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) mut => VT.GetNumberEventFilters(ref this, out SpecificEvents, out SpecificExceptions, out ArbitraryExceptions);
			public HResult GetEventFilterText(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterText(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommand(uint32 Index, char8* Command) mut => VT.SetEventFilterCommand(ref this, Index, Command);
			public HResult GetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.GetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult SetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.SetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult GetSpecificFilterArgument(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgument(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgument(uint32 Index, char8* Argument) mut => VT.SetSpecificFilterArgument(ref this, Index, Argument);
			public HResult GetExceptionFilterParameters(uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.GetExceptionFilterParameters(ref this, Count, Codes, Start, Params);
			public HResult SetExceptionFilterParameters(uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.SetExceptionFilterParameters(ref this, Count, Params);
			public HResult GetExceptionFilterSecondCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommand(uint32 Index, char8* Command) mut => VT.SetExceptionFilterSecondCommand(ref this, Index, Command);
			public HResult WaitForEvent(uint32 Flags, uint32 Timeout) mut => VT.WaitForEvent(ref this, Flags, Timeout);
			public HResult GetLastEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformation(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetCurrentTimeDate(out uint32 TimeDate) mut => VT.GetCurrentTimeDate(ref this, out TimeDate);
			public HResult GetCurrentSystemUpTime(out uint32 UpTime) mut => VT.GetCurrentSystemUpTime(ref this, out UpTime);
			public HResult GetDumpFormatFlags(out uint32 FormatFlags) mut => VT.GetDumpFormatFlags(ref this, out FormatFlags);
			public HResult GetNumberTextReplacements(out uint32 NumRepl) mut => VT.GetNumberTextReplacements(ref this, out NumRepl);
			public HResult GetTextReplacement(char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacement(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacement(char8* SrcText, char8* DstText) mut => VT.SetTextReplacement(ref this, SrcText, DstText);
			public HResult RemoveTextReplacements() mut => VT.RemoveTextReplacements(ref this);
			public HResult OutputTextReplacements(uint32 OutputControl, uint32 Flags) mut => VT.OutputTextReplacements(ref this, OutputControl, Flags);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self) GetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Flags) SetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Seconds) GetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Seconds) SetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, char8* File, IntBool Append) OpenLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self) CloseLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Mask) GetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Mask) SetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint8* Buffer, uint32 BufferSize, uint32* InputSize) Input;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, char8* Buffer) ReturnInput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Mask, char8* Format) Output;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Mask, char8* Format, ref int8 Args) OutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, uint32 Mask, char8* Format) ControlledOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) ControlledOutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, char8* Format) OutputPrompt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, char8* Format, ref int8 Args) OutputPromptVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, uint32 Flags) OutputCurrentState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl) OutputVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint64 Handle) GetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint64 Handle) SetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint64 Offset, char8* Instr, out uint64 EndOffset) Assemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) Disassemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint64 Offset) GetDisassembleEffectiveOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) OutputDisassembly;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) OutputDisassemblyLines;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint64 Offset, int32 Delta, out uint64 NearOffset) GetNearInstruction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint64 Offset) GetReturnOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) OutputStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Class, out uint32 Qualifier) GetDebuggeeType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Type) GetActualProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Type) GetExecutingProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Number) GetNumberPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Start, uint32 Count, uint32* Types) GetPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Number) GetNumberProcessors;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) GetSystemVersion;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Size) GetPageSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self) IsPointer64Bit;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) ReadBugCheckData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Number) GetNumberSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Start, uint32 Count, uint32* Types) GetSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Type) GetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Type) SetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Status) GetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Status) SetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Level) GetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Level) SetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Options) GetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Options) AddEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Options) RemoveEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Options) SetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 OutputLevel, out uint32 BreakLevel) GetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputLevel, uint32 BreakLevel) SetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Slot, char8* Macro) SetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Radix) GetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Radix) SetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) Evaluate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) CoerceValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) CoerceValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, char8* Command, uint32 Flags) Execute;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, char8* CommandFile, uint32 Flags) ExecuteCommandFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Number) GetNumberBreakpoints;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Index, out IDebugBreakpoint* Bp) GetBreakpointByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Id, out IDebugBreakpoint* Bp) GetBreakpointById;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) GetBreakpointParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) AddBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, ref IDebugBreakpoint Bp) RemoveBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, char8* Path, uint32 Flags, out uint64 Handle) AddExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint64 Handle) RemoveExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, char8* Path, out uint64 Handle) GetExtensionByPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint64 Handle, char8* Function, char8* Arguments) CallExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint64 Handle, char8* FuncName, out FARPROC Function) GetExtensionFunction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out WINDBG_EXTENSION_APIS32 Api) GetWindbgExtensionApis32;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out WINDBG_EXTENSION_APIS64 Api) GetWindbgExtensionApis64;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) GetNumberEventFilters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Index, char8* Command) SetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) GetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) SetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Index, char8* Argument) SetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) GetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) SetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Index, char8* Command) SetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 Flags, uint32 Timeout) WaitForEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 TimeDate) GetCurrentTimeDate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 UpTime) GetCurrentSystemUpTime;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 FormatFlags) GetDumpFormatFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, out uint32 NumRepl) GetNumberTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, char8* SrcText, char8* DstText) SetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self) RemoveTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl2 self, uint32 OutputControl, uint32 Flags) OutputTextReplacements;
			}
		}
		[CRepr]
		public struct IDebugControl3 : IUnknown
		{
			public const new Guid IID = .(0x7df74a86, 0xb03f, 0x407f, 0x90, 0xab, 0xa2, 0x0d, 0xad, 0xce, 0xad, 0x08);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterrupt() mut => VT.GetInterrupt(ref this);
			public HResult SetInterrupt(uint32 Flags) mut => VT.SetInterrupt(ref this, Flags);
			public HResult GetInterruptTimeout(out uint32 Seconds) mut => VT.GetInterruptTimeout(ref this, out Seconds);
			public HResult SetInterruptTimeout(uint32 Seconds) mut => VT.SetInterruptTimeout(ref this, Seconds);
			public HResult GetLogFile(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFile(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFile(char8* File, IntBool Append) mut => VT.OpenLogFile(ref this, File, Append);
			public HResult CloseLogFile() mut => VT.CloseLogFile(ref this);
			public HResult GetLogMask(out uint32 Mask) mut => VT.GetLogMask(ref this, out Mask);
			public HResult SetLogMask(uint32 Mask) mut => VT.SetLogMask(ref this, Mask);
			public HResult Input(uint8* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.Input(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInput(char8* Buffer) mut => VT.ReturnInput(ref this, Buffer);
			public HResult Output(uint32 Mask, char8* Format) mut => VT.Output(ref this, Mask, Format);
			public HResult OutputVaList(uint32 Mask, char8* Format, ref int8 Args) mut => VT.OutputVaList(ref this, Mask, Format, ref Args);
			public HResult ControlledOutput(uint32 OutputControl, uint32 Mask, char8* Format) mut => VT.ControlledOutput(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaList(uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) mut => VT.ControlledOutputVaList(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPrompt(uint32 OutputControl, char8* Format) mut => VT.OutputPrompt(ref this, OutputControl, Format);
			public HResult OutputPromptVaList(uint32 OutputControl, char8* Format, ref int8 Args) mut => VT.OutputPromptVaList(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptText(uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptText(ref this, Buffer, BufferSize, TextSize);
			public HResult OutputCurrentState(uint32 OutputControl, uint32 Flags) mut => VT.OutputCurrentState(ref this, OutputControl, Flags);
			public HResult OutputVersionInformation(uint32 OutputControl) mut => VT.OutputVersionInformation(ref this, OutputControl);
			public HResult GetNotifyEventHandle(out uint64 Handle) mut => VT.GetNotifyEventHandle(ref this, out Handle);
			public HResult SetNotifyEventHandle(uint64 Handle) mut => VT.SetNotifyEventHandle(ref this, Handle);
			public HResult Assemble(uint64 Offset, char8* Instr, out uint64 EndOffset) mut => VT.Assemble(ref this, Offset, Instr, out EndOffset);
			public HResult Disassemble(uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.Disassemble(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetDisassembleEffectiveOffset(out uint64 Offset) mut => VT.GetDisassembleEffectiveOffset(ref this, out Offset);
			public HResult OutputDisassembly(uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) mut => VT.OutputDisassembly(ref this, OutputControl, Offset, Flags, out EndOffset);
			public HResult OutputDisassemblyLines(uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) mut => VT.OutputDisassemblyLines(ref this, OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
			public HResult GetNearInstruction(uint64 Offset, int32 Delta, out uint64 NearOffset) mut => VT.GetNearInstruction(ref this, Offset, Delta, out NearOffset);
			public HResult GetStackTrace(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTrace(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult GetReturnOffset(out uint64 Offset) mut => VT.GetReturnOffset(ref this, out Offset);
			public HResult OutputStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTrace(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetDebuggeeType(out uint32 Class, out uint32 Qualifier) mut => VT.GetDebuggeeType(ref this, out Class, out Qualifier);
			public HResult GetActualProcessorType(out uint32 Type) mut => VT.GetActualProcessorType(ref this, out Type);
			public HResult GetExecutingProcessorType(out uint32 Type) mut => VT.GetExecutingProcessorType(ref this, out Type);
			public HResult GetNumberPossibleExecutingProcessorTypes(out uint32 Number) mut => VT.GetNumberPossibleExecutingProcessorTypes(ref this, out Number);
			public HResult GetPossibleExecutingProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetPossibleExecutingProcessorTypes(ref this, Start, Count, Types);
			public HResult GetNumberProcessors(out uint32 Number) mut => VT.GetNumberProcessors(ref this, out Number);
			public HResult GetSystemVersion(out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) mut => VT.GetSystemVersion(ref this, out PlatformId, out Major, out Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, out ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
			public HResult GetPageSize(out uint32 Size) mut => VT.GetPageSize(ref this, out Size);
			public HResult IsPointer64Bit() mut => VT.IsPointer64Bit(ref this);
			public HResult ReadBugCheckData(out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) mut => VT.ReadBugCheckData(ref this, out Code, out Arg1, out Arg2, out Arg3, out Arg4);
			public HResult GetNumberSupportedProcessorTypes(out uint32 Number) mut => VT.GetNumberSupportedProcessorTypes(ref this, out Number);
			public HResult GetSupportedProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetSupportedProcessorTypes(ref this, Start, Count, Types);
			public HResult GetProcessorTypeNames(uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNames(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEffectiveProcessorType(out uint32 Type) mut => VT.GetEffectiveProcessorType(ref this, out Type);
			public HResult SetEffectiveProcessorType(uint32 Type) mut => VT.SetEffectiveProcessorType(ref this, Type);
			public HResult GetExecutionStatus(out uint32 Status) mut => VT.GetExecutionStatus(ref this, out Status);
			public HResult SetExecutionStatus(uint32 Status) mut => VT.SetExecutionStatus(ref this, Status);
			public HResult GetCodeLevel(out uint32 Level) mut => VT.GetCodeLevel(ref this, out Level);
			public HResult SetCodeLevel(uint32 Level) mut => VT.SetCodeLevel(ref this, Level);
			public HResult GetEngineOptions(out uint32 Options) mut => VT.GetEngineOptions(ref this, out Options);
			public HResult AddEngineOptions(uint32 Options) mut => VT.AddEngineOptions(ref this, Options);
			public HResult RemoveEngineOptions(uint32 Options) mut => VT.RemoveEngineOptions(ref this, Options);
			public HResult SetEngineOptions(uint32 Options) mut => VT.SetEngineOptions(ref this, Options);
			public HResult GetSystemErrorControl(out uint32 OutputLevel, out uint32 BreakLevel) mut => VT.GetSystemErrorControl(ref this, out OutputLevel, out BreakLevel);
			public HResult SetSystemErrorControl(uint32 OutputLevel, uint32 BreakLevel) mut => VT.SetSystemErrorControl(ref this, OutputLevel, BreakLevel);
			public HResult GetTextMacro(uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacro(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacro(uint32 Slot, char8* Macro) mut => VT.SetTextMacro(ref this, Slot, Macro);
			public HResult GetRadix(out uint32 Radix) mut => VT.GetRadix(ref this, out Radix);
			public HResult SetRadix(uint32 Radix) mut => VT.SetRadix(ref this, Radix);
			public HResult Evaluate(char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.Evaluate(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult CoerceValue(ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) mut => VT.CoerceValue(ref this, ref In, OutType, out Out);
			public HResult CoerceValues(uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) mut => VT.CoerceValues(ref this, Count, In, OutTypes, Out);
			public HResult Execute(uint32 OutputControl, char8* Command, uint32 Flags) mut => VT.Execute(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFile(uint32 OutputControl, char8* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFile(ref this, OutputControl, CommandFile, Flags);
			public HResult GetNumberBreakpoints(out uint32 Number) mut => VT.GetNumberBreakpoints(ref this, out Number);
			public HResult GetBreakpointByIndex(uint32 Index, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointByIndex(ref this, Index, out Bp);
			public HResult GetBreakpointById(uint32 Id, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointById(ref this, Id, out Bp);
			public HResult GetBreakpointParameters(uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) mut => VT.GetBreakpointParameters(ref this, Count, Ids, Start, Params);
			public HResult AddBreakpoint(uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) mut => VT.AddBreakpoint(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint(ref IDebugBreakpoint Bp) mut => VT.RemoveBreakpoint(ref this, ref Bp);
			public HResult AddExtension(char8* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtension(ref this, Path, Flags, out Handle);
			public HResult RemoveExtension(uint64 Handle) mut => VT.RemoveExtension(ref this, Handle);
			public HResult GetExtensionByPath(char8* Path, out uint64 Handle) mut => VT.GetExtensionByPath(ref this, Path, out Handle);
			public HResult CallExtension(uint64 Handle, char8* Function, char8* Arguments) mut => VT.CallExtension(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunction(uint64 Handle, char8* FuncName, out FARPROC Function) mut => VT.GetExtensionFunction(ref this, Handle, FuncName, out Function);
			public HResult GetWindbgExtensionApis32(out WINDBG_EXTENSION_APIS32 Api) mut => VT.GetWindbgExtensionApis32(ref this, out Api);
			public HResult GetWindbgExtensionApis64(out WINDBG_EXTENSION_APIS64 Api) mut => VT.GetWindbgExtensionApis64(ref this, out Api);
			public HResult GetNumberEventFilters(out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) mut => VT.GetNumberEventFilters(ref this, out SpecificEvents, out SpecificExceptions, out ArbitraryExceptions);
			public HResult GetEventFilterText(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterText(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommand(uint32 Index, char8* Command) mut => VT.SetEventFilterCommand(ref this, Index, Command);
			public HResult GetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.GetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult SetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.SetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult GetSpecificFilterArgument(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgument(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgument(uint32 Index, char8* Argument) mut => VT.SetSpecificFilterArgument(ref this, Index, Argument);
			public HResult GetExceptionFilterParameters(uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.GetExceptionFilterParameters(ref this, Count, Codes, Start, Params);
			public HResult SetExceptionFilterParameters(uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.SetExceptionFilterParameters(ref this, Count, Params);
			public HResult GetExceptionFilterSecondCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommand(uint32 Index, char8* Command) mut => VT.SetExceptionFilterSecondCommand(ref this, Index, Command);
			public HResult WaitForEvent(uint32 Flags, uint32 Timeout) mut => VT.WaitForEvent(ref this, Flags, Timeout);
			public HResult GetLastEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformation(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetCurrentTimeDate(out uint32 TimeDate) mut => VT.GetCurrentTimeDate(ref this, out TimeDate);
			public HResult GetCurrentSystemUpTime(out uint32 UpTime) mut => VT.GetCurrentSystemUpTime(ref this, out UpTime);
			public HResult GetDumpFormatFlags(out uint32 FormatFlags) mut => VT.GetDumpFormatFlags(ref this, out FormatFlags);
			public HResult GetNumberTextReplacements(out uint32 NumRepl) mut => VT.GetNumberTextReplacements(ref this, out NumRepl);
			public HResult GetTextReplacement(char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacement(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacement(char8* SrcText, char8* DstText) mut => VT.SetTextReplacement(ref this, SrcText, DstText);
			public HResult RemoveTextReplacements() mut => VT.RemoveTextReplacements(ref this);
			public HResult OutputTextReplacements(uint32 OutputControl, uint32 Flags) mut => VT.OutputTextReplacements(ref this, OutputControl, Flags);
			public HResult GetAssemblyOptions(out uint32 Options) mut => VT.GetAssemblyOptions(ref this, out Options);
			public HResult AddAssemblyOptions(uint32 Options) mut => VT.AddAssemblyOptions(ref this, Options);
			public HResult RemoveAssemblyOptions(uint32 Options) mut => VT.RemoveAssemblyOptions(ref this, Options);
			public HResult SetAssemblyOptions(uint32 Options) mut => VT.SetAssemblyOptions(ref this, Options);
			public HResult GetExpressionSyntax(out uint32 Flags) mut => VT.GetExpressionSyntax(ref this, out Flags);
			public HResult SetExpressionSyntax(uint32 Flags) mut => VT.SetExpressionSyntax(ref this, Flags);
			public HResult SetExpressionSyntaxByName(char8* AbbrevName) mut => VT.SetExpressionSyntaxByName(ref this, AbbrevName);
			public HResult GetNumberExpressionSyntaxes(out uint32 Number) mut => VT.GetNumberExpressionSyntaxes(ref this, out Number);
			public HResult GetExpressionSyntaxNames(uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetExpressionSyntaxNames(ref this, Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetNumberEvents(out uint32 Events) mut => VT.GetNumberEvents(ref this, out Events);
			public HResult GetEventIndexDescription(uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) mut => VT.GetEventIndexDescription(ref this, Index, Which, Buffer, BufferSize, DescSize);
			public HResult GetCurrentEventIndex(out uint32 Index) mut => VT.GetCurrentEventIndex(ref this, out Index);
			public HResult SetNextEventIndex(uint32 Relation, uint32 Value, out uint32 NextIndex) mut => VT.SetNextEventIndex(ref this, Relation, Value, out NextIndex);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self) GetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Flags) SetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Seconds) GetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Seconds) SetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, char8* File, IntBool Append) OpenLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self) CloseLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Mask) GetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Mask) SetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint8* Buffer, uint32 BufferSize, uint32* InputSize) Input;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, char8* Buffer) ReturnInput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Mask, char8* Format) Output;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Mask, char8* Format, ref int8 Args) OutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, uint32 Mask, char8* Format) ControlledOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) ControlledOutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, char8* Format) OutputPrompt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, char8* Format, ref int8 Args) OutputPromptVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, uint32 Flags) OutputCurrentState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl) OutputVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint64 Handle) GetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint64 Handle) SetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint64 Offset, char8* Instr, out uint64 EndOffset) Assemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) Disassemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint64 Offset) GetDisassembleEffectiveOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) OutputDisassembly;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) OutputDisassemblyLines;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint64 Offset, int32 Delta, out uint64 NearOffset) GetNearInstruction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint64 Offset) GetReturnOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) OutputStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Class, out uint32 Qualifier) GetDebuggeeType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Type) GetActualProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Type) GetExecutingProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Number) GetNumberPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Start, uint32 Count, uint32* Types) GetPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Number) GetNumberProcessors;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) GetSystemVersion;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Size) GetPageSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self) IsPointer64Bit;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) ReadBugCheckData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Number) GetNumberSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Start, uint32 Count, uint32* Types) GetSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Type) GetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Type) SetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Status) GetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Status) SetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Level) GetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Level) SetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Options) GetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Options) AddEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Options) RemoveEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Options) SetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 OutputLevel, out uint32 BreakLevel) GetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputLevel, uint32 BreakLevel) SetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Slot, char8* Macro) SetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Radix) GetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Radix) SetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) Evaluate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) CoerceValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) CoerceValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, char8* Command, uint32 Flags) Execute;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, char8* CommandFile, uint32 Flags) ExecuteCommandFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Number) GetNumberBreakpoints;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, out IDebugBreakpoint* Bp) GetBreakpointByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Id, out IDebugBreakpoint* Bp) GetBreakpointById;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) GetBreakpointParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) AddBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, ref IDebugBreakpoint Bp) RemoveBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, char8* Path, uint32 Flags, out uint64 Handle) AddExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint64 Handle) RemoveExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, char8* Path, out uint64 Handle) GetExtensionByPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint64 Handle, char8* Function, char8* Arguments) CallExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint64 Handle, char8* FuncName, out FARPROC Function) GetExtensionFunction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out WINDBG_EXTENSION_APIS32 Api) GetWindbgExtensionApis32;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out WINDBG_EXTENSION_APIS64 Api) GetWindbgExtensionApis64;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) GetNumberEventFilters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, char8* Command) SetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) GetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) SetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, char8* Argument) SetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) GetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) SetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, char8* Command) SetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Flags, uint32 Timeout) WaitForEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 TimeDate) GetCurrentTimeDate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 UpTime) GetCurrentSystemUpTime;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 FormatFlags) GetDumpFormatFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 NumRepl) GetNumberTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, char8* SrcText, char8* DstText) SetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self) RemoveTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 OutputControl, uint32 Flags) OutputTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Options) GetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Options) AddAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Options) RemoveAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Options) SetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Flags) GetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Flags) SetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, char8* AbbrevName) SetExpressionSyntaxByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Number) GetNumberExpressionSyntaxes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetExpressionSyntaxNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Events) GetNumberEvents;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) GetEventIndexDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, out uint32 Index) GetCurrentEventIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl3 self, uint32 Relation, uint32 Value, out uint32 NextIndex) SetNextEventIndex;
			}
		}
		[CRepr]
		public struct IDebugControl4 : IUnknown
		{
			public const new Guid IID = .(0x94e60ce9, 0x9b41, 0x4b19, 0x9f, 0xc0, 0x6d, 0x9e, 0xb3, 0x52, 0x72, 0xb3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterrupt() mut => VT.GetInterrupt(ref this);
			public HResult SetInterrupt(uint32 Flags) mut => VT.SetInterrupt(ref this, Flags);
			public HResult GetInterruptTimeout(out uint32 Seconds) mut => VT.GetInterruptTimeout(ref this, out Seconds);
			public HResult SetInterruptTimeout(uint32 Seconds) mut => VT.SetInterruptTimeout(ref this, Seconds);
			public HResult GetLogFile(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFile(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFile(char8* File, IntBool Append) mut => VT.OpenLogFile(ref this, File, Append);
			public HResult CloseLogFile() mut => VT.CloseLogFile(ref this);
			public HResult GetLogMask(out uint32 Mask) mut => VT.GetLogMask(ref this, out Mask);
			public HResult SetLogMask(uint32 Mask) mut => VT.SetLogMask(ref this, Mask);
			public HResult Input(uint8* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.Input(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInput(char8* Buffer) mut => VT.ReturnInput(ref this, Buffer);
			public HResult Output(uint32 Mask, char8* Format) mut => VT.Output(ref this, Mask, Format);
			public HResult OutputVaList(uint32 Mask, char8* Format, ref int8 Args) mut => VT.OutputVaList(ref this, Mask, Format, ref Args);
			public HResult ControlledOutput(uint32 OutputControl, uint32 Mask, char8* Format) mut => VT.ControlledOutput(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaList(uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) mut => VT.ControlledOutputVaList(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPrompt(uint32 OutputControl, char8* Format) mut => VT.OutputPrompt(ref this, OutputControl, Format);
			public HResult OutputPromptVaList(uint32 OutputControl, char8* Format, ref int8 Args) mut => VT.OutputPromptVaList(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptText(uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptText(ref this, Buffer, BufferSize, TextSize);
			public HResult OutputCurrentState(uint32 OutputControl, uint32 Flags) mut => VT.OutputCurrentState(ref this, OutputControl, Flags);
			public HResult OutputVersionInformation(uint32 OutputControl) mut => VT.OutputVersionInformation(ref this, OutputControl);
			public HResult GetNotifyEventHandle(out uint64 Handle) mut => VT.GetNotifyEventHandle(ref this, out Handle);
			public HResult SetNotifyEventHandle(uint64 Handle) mut => VT.SetNotifyEventHandle(ref this, Handle);
			public HResult Assemble(uint64 Offset, char8* Instr, out uint64 EndOffset) mut => VT.Assemble(ref this, Offset, Instr, out EndOffset);
			public HResult Disassemble(uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.Disassemble(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetDisassembleEffectiveOffset(out uint64 Offset) mut => VT.GetDisassembleEffectiveOffset(ref this, out Offset);
			public HResult OutputDisassembly(uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) mut => VT.OutputDisassembly(ref this, OutputControl, Offset, Flags, out EndOffset);
			public HResult OutputDisassemblyLines(uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) mut => VT.OutputDisassemblyLines(ref this, OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
			public HResult GetNearInstruction(uint64 Offset, int32 Delta, out uint64 NearOffset) mut => VT.GetNearInstruction(ref this, Offset, Delta, out NearOffset);
			public HResult GetStackTrace(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTrace(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult GetReturnOffset(out uint64 Offset) mut => VT.GetReturnOffset(ref this, out Offset);
			public HResult OutputStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTrace(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetDebuggeeType(out uint32 Class, out uint32 Qualifier) mut => VT.GetDebuggeeType(ref this, out Class, out Qualifier);
			public HResult GetActualProcessorType(out uint32 Type) mut => VT.GetActualProcessorType(ref this, out Type);
			public HResult GetExecutingProcessorType(out uint32 Type) mut => VT.GetExecutingProcessorType(ref this, out Type);
			public HResult GetNumberPossibleExecutingProcessorTypes(out uint32 Number) mut => VT.GetNumberPossibleExecutingProcessorTypes(ref this, out Number);
			public HResult GetPossibleExecutingProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetPossibleExecutingProcessorTypes(ref this, Start, Count, Types);
			public HResult GetNumberProcessors(out uint32 Number) mut => VT.GetNumberProcessors(ref this, out Number);
			public HResult GetSystemVersion(out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) mut => VT.GetSystemVersion(ref this, out PlatformId, out Major, out Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, out ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
			public HResult GetPageSize(out uint32 Size) mut => VT.GetPageSize(ref this, out Size);
			public HResult IsPointer64Bit() mut => VT.IsPointer64Bit(ref this);
			public HResult ReadBugCheckData(out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) mut => VT.ReadBugCheckData(ref this, out Code, out Arg1, out Arg2, out Arg3, out Arg4);
			public HResult GetNumberSupportedProcessorTypes(out uint32 Number) mut => VT.GetNumberSupportedProcessorTypes(ref this, out Number);
			public HResult GetSupportedProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetSupportedProcessorTypes(ref this, Start, Count, Types);
			public HResult GetProcessorTypeNames(uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNames(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEffectiveProcessorType(out uint32 Type) mut => VT.GetEffectiveProcessorType(ref this, out Type);
			public HResult SetEffectiveProcessorType(uint32 Type) mut => VT.SetEffectiveProcessorType(ref this, Type);
			public HResult GetExecutionStatus(out uint32 Status) mut => VT.GetExecutionStatus(ref this, out Status);
			public HResult SetExecutionStatus(uint32 Status) mut => VT.SetExecutionStatus(ref this, Status);
			public HResult GetCodeLevel(out uint32 Level) mut => VT.GetCodeLevel(ref this, out Level);
			public HResult SetCodeLevel(uint32 Level) mut => VT.SetCodeLevel(ref this, Level);
			public HResult GetEngineOptions(out uint32 Options) mut => VT.GetEngineOptions(ref this, out Options);
			public HResult AddEngineOptions(uint32 Options) mut => VT.AddEngineOptions(ref this, Options);
			public HResult RemoveEngineOptions(uint32 Options) mut => VT.RemoveEngineOptions(ref this, Options);
			public HResult SetEngineOptions(uint32 Options) mut => VT.SetEngineOptions(ref this, Options);
			public HResult GetSystemErrorControl(out uint32 OutputLevel, out uint32 BreakLevel) mut => VT.GetSystemErrorControl(ref this, out OutputLevel, out BreakLevel);
			public HResult SetSystemErrorControl(uint32 OutputLevel, uint32 BreakLevel) mut => VT.SetSystemErrorControl(ref this, OutputLevel, BreakLevel);
			public HResult GetTextMacro(uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacro(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacro(uint32 Slot, char8* Macro) mut => VT.SetTextMacro(ref this, Slot, Macro);
			public HResult GetRadix(out uint32 Radix) mut => VT.GetRadix(ref this, out Radix);
			public HResult SetRadix(uint32 Radix) mut => VT.SetRadix(ref this, Radix);
			public HResult Evaluate(char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.Evaluate(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult CoerceValue(ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) mut => VT.CoerceValue(ref this, ref In, OutType, out Out);
			public HResult CoerceValues(uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) mut => VT.CoerceValues(ref this, Count, In, OutTypes, Out);
			public HResult Execute(uint32 OutputControl, char8* Command, uint32 Flags) mut => VT.Execute(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFile(uint32 OutputControl, char8* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFile(ref this, OutputControl, CommandFile, Flags);
			public HResult GetNumberBreakpoints(out uint32 Number) mut => VT.GetNumberBreakpoints(ref this, out Number);
			public HResult GetBreakpointByIndex(uint32 Index, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointByIndex(ref this, Index, out Bp);
			public HResult GetBreakpointById(uint32 Id, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointById(ref this, Id, out Bp);
			public HResult GetBreakpointParameters(uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) mut => VT.GetBreakpointParameters(ref this, Count, Ids, Start, Params);
			public HResult AddBreakpoint(uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) mut => VT.AddBreakpoint(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint(ref IDebugBreakpoint Bp) mut => VT.RemoveBreakpoint(ref this, ref Bp);
			public HResult AddExtension(char8* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtension(ref this, Path, Flags, out Handle);
			public HResult RemoveExtension(uint64 Handle) mut => VT.RemoveExtension(ref this, Handle);
			public HResult GetExtensionByPath(char8* Path, out uint64 Handle) mut => VT.GetExtensionByPath(ref this, Path, out Handle);
			public HResult CallExtension(uint64 Handle, char8* Function, char8* Arguments) mut => VT.CallExtension(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunction(uint64 Handle, char8* FuncName, out FARPROC Function) mut => VT.GetExtensionFunction(ref this, Handle, FuncName, out Function);
			public HResult GetWindbgExtensionApis32(out WINDBG_EXTENSION_APIS32 Api) mut => VT.GetWindbgExtensionApis32(ref this, out Api);
			public HResult GetWindbgExtensionApis64(out WINDBG_EXTENSION_APIS64 Api) mut => VT.GetWindbgExtensionApis64(ref this, out Api);
			public HResult GetNumberEventFilters(out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) mut => VT.GetNumberEventFilters(ref this, out SpecificEvents, out SpecificExceptions, out ArbitraryExceptions);
			public HResult GetEventFilterText(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterText(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommand(uint32 Index, char8* Command) mut => VT.SetEventFilterCommand(ref this, Index, Command);
			public HResult GetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.GetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult SetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.SetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult GetSpecificFilterArgument(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgument(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgument(uint32 Index, char8* Argument) mut => VT.SetSpecificFilterArgument(ref this, Index, Argument);
			public HResult GetExceptionFilterParameters(uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.GetExceptionFilterParameters(ref this, Count, Codes, Start, Params);
			public HResult SetExceptionFilterParameters(uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.SetExceptionFilterParameters(ref this, Count, Params);
			public HResult GetExceptionFilterSecondCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommand(uint32 Index, char8* Command) mut => VT.SetExceptionFilterSecondCommand(ref this, Index, Command);
			public HResult WaitForEvent(uint32 Flags, uint32 Timeout) mut => VT.WaitForEvent(ref this, Flags, Timeout);
			public HResult GetLastEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformation(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetCurrentTimeDate(out uint32 TimeDate) mut => VT.GetCurrentTimeDate(ref this, out TimeDate);
			public HResult GetCurrentSystemUpTime(out uint32 UpTime) mut => VT.GetCurrentSystemUpTime(ref this, out UpTime);
			public HResult GetDumpFormatFlags(out uint32 FormatFlags) mut => VT.GetDumpFormatFlags(ref this, out FormatFlags);
			public HResult GetNumberTextReplacements(out uint32 NumRepl) mut => VT.GetNumberTextReplacements(ref this, out NumRepl);
			public HResult GetTextReplacement(char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacement(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacement(char8* SrcText, char8* DstText) mut => VT.SetTextReplacement(ref this, SrcText, DstText);
			public HResult RemoveTextReplacements() mut => VT.RemoveTextReplacements(ref this);
			public HResult OutputTextReplacements(uint32 OutputControl, uint32 Flags) mut => VT.OutputTextReplacements(ref this, OutputControl, Flags);
			public HResult GetAssemblyOptions(out uint32 Options) mut => VT.GetAssemblyOptions(ref this, out Options);
			public HResult AddAssemblyOptions(uint32 Options) mut => VT.AddAssemblyOptions(ref this, Options);
			public HResult RemoveAssemblyOptions(uint32 Options) mut => VT.RemoveAssemblyOptions(ref this, Options);
			public HResult SetAssemblyOptions(uint32 Options) mut => VT.SetAssemblyOptions(ref this, Options);
			public HResult GetExpressionSyntax(out uint32 Flags) mut => VT.GetExpressionSyntax(ref this, out Flags);
			public HResult SetExpressionSyntax(uint32 Flags) mut => VT.SetExpressionSyntax(ref this, Flags);
			public HResult SetExpressionSyntaxByName(char8* AbbrevName) mut => VT.SetExpressionSyntaxByName(ref this, AbbrevName);
			public HResult GetNumberExpressionSyntaxes(out uint32 Number) mut => VT.GetNumberExpressionSyntaxes(ref this, out Number);
			public HResult GetExpressionSyntaxNames(uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetExpressionSyntaxNames(ref this, Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetNumberEvents(out uint32 Events) mut => VT.GetNumberEvents(ref this, out Events);
			public HResult GetEventIndexDescription(uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) mut => VT.GetEventIndexDescription(ref this, Index, Which, Buffer, BufferSize, DescSize);
			public HResult GetCurrentEventIndex(out uint32 Index) mut => VT.GetCurrentEventIndex(ref this, out Index);
			public HResult SetNextEventIndex(uint32 Relation, uint32 Value, out uint32 NextIndex) mut => VT.SetNextEventIndex(ref this, Relation, Value, out NextIndex);
			public HResult GetLogFileWide(char16* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFileWide(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFileWide(char16* File, IntBool Append) mut => VT.OpenLogFileWide(ref this, File, Append);
			public HResult InputWide(char16* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.InputWide(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInputWide(char16* Buffer) mut => VT.ReturnInputWide(ref this, Buffer);
			public HResult OutputWide(uint32 Mask, char16* Format) mut => VT.OutputWide(ref this, Mask, Format);
			public HResult OutputVaListWide(uint32 Mask, char16* Format, ref int8 Args) mut => VT.OutputVaListWide(ref this, Mask, Format, ref Args);
			public HResult ControlledOutputWide(uint32 OutputControl, uint32 Mask, char16* Format) mut => VT.ControlledOutputWide(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaListWide(uint32 OutputControl, uint32 Mask, char16* Format, ref int8 Args) mut => VT.ControlledOutputVaListWide(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPromptWide(uint32 OutputControl, char16* Format) mut => VT.OutputPromptWide(ref this, OutputControl, Format);
			public HResult OutputPromptVaListWide(uint32 OutputControl, char16* Format, ref int8 Args) mut => VT.OutputPromptVaListWide(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptTextWide(char16* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptTextWide(ref this, Buffer, BufferSize, TextSize);
			public HResult AssembleWide(uint64 Offset, char16* Instr, out uint64 EndOffset) mut => VT.AssembleWide(ref this, Offset, Instr, out EndOffset);
			public HResult DisassembleWide(uint64 Offset, uint32 Flags, char16* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.DisassembleWide(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetProcessorTypeNamesWide(uint32 Type, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNamesWide(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetTextMacroWide(uint32 Slot, char16* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacroWide(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacroWide(uint32 Slot, char16* Macro) mut => VT.SetTextMacroWide(ref this, Slot, Macro);
			public HResult EvaluateWide(char16* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.EvaluateWide(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult ExecuteWide(uint32 OutputControl, char16* Command, uint32 Flags) mut => VT.ExecuteWide(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFileWide(uint32 OutputControl, char16* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFileWide(ref this, OutputControl, CommandFile, Flags);
			public HResult GetBreakpointByIndex2(uint32 Index, out IDebugBreakpoint2* Bp) mut => VT.GetBreakpointByIndex2(ref this, Index, out Bp);
			public HResult GetBreakpointById2(uint32 Id, out IDebugBreakpoint2* Bp) mut => VT.GetBreakpointById2(ref this, Id, out Bp);
			public HResult AddBreakpoint2(uint32 Type, uint32 DesiredId, out IDebugBreakpoint2* Bp) mut => VT.AddBreakpoint2(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint2(ref IDebugBreakpoint2 Bp) mut => VT.RemoveBreakpoint2(ref this, ref Bp);
			public HResult AddExtensionWide(char16* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtensionWide(ref this, Path, Flags, out Handle);
			public HResult GetExtensionByPathWide(char16* Path, out uint64 Handle) mut => VT.GetExtensionByPathWide(ref this, Path, out Handle);
			public HResult CallExtensionWide(uint64 Handle, char16* Function, char16* Arguments) mut => VT.CallExtensionWide(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunctionWide(uint64 Handle, char16* FuncName, out FARPROC Function) mut => VT.GetExtensionFunctionWide(ref this, Handle, FuncName, out Function);
			public HResult GetEventFilterTextWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterTextWide(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommandWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommandWide(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommandWide(uint32 Index, char16* Command) mut => VT.SetEventFilterCommandWide(ref this, Index, Command);
			public HResult GetSpecificFilterArgumentWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgumentWide(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgumentWide(uint32 Index, char16* Argument) mut => VT.SetSpecificFilterArgumentWide(ref this, Index, Argument);
			public HResult GetExceptionFilterSecondCommandWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommandWide(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommandWide(uint32 Index, char16* Command) mut => VT.SetExceptionFilterSecondCommandWide(ref this, Index, Command);
			public HResult GetLastEventInformationWide(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, char16* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformationWide(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetTextReplacementWide(char16* SrcText, uint32 Index, char16* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, char16* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacementWide(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacementWide(char16* SrcText, char16* DstText) mut => VT.SetTextReplacementWide(ref this, SrcText, DstText);
			public HResult SetExpressionSyntaxByNameWide(char16* AbbrevName) mut => VT.SetExpressionSyntaxByNameWide(ref this, AbbrevName);
			public HResult GetExpressionSyntaxNamesWide(uint32 Index, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetExpressionSyntaxNamesWide(ref this, Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEventIndexDescriptionWide(uint32 Index, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* DescSize) mut => VT.GetEventIndexDescriptionWide(ref this, Index, Which, Buffer, BufferSize, DescSize);
			public HResult GetLogFile2(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) mut => VT.GetLogFile2(ref this, Buffer, BufferSize, FileSize, out Flags);
			public HResult OpenLogFile2(char8* File, uint32 Flags) mut => VT.OpenLogFile2(ref this, File, Flags);
			public HResult GetLogFile2Wide(char16* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) mut => VT.GetLogFile2Wide(ref this, Buffer, BufferSize, FileSize, out Flags);
			public HResult OpenLogFile2Wide(char16* File, uint32 Flags) mut => VT.OpenLogFile2Wide(ref this, File, Flags);
			public HResult GetSystemVersionValues(out uint32 PlatformId, out uint32 Win32Major, out uint32 Win32Minor, uint32* KdMajor, uint32* KdMinor) mut => VT.GetSystemVersionValues(ref this, out PlatformId, out Win32Major, out Win32Minor, KdMajor, KdMinor);
			public HResult GetSystemVersionString(uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSystemVersionString(ref this, Which, Buffer, BufferSize, StringSize);
			public HResult GetSystemVersionStringWide(uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSystemVersionStringWide(ref this, Which, Buffer, BufferSize, StringSize);
			public HResult GetContextStackTrace(void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) mut => VT.GetContextStackTrace(ref this, StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
			public HResult OutputContextStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) mut => VT.OutputContextStackTrace(ref this, OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
			public HResult GetStoredEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* Context, uint32 ContextSize, uint32* ContextUsed, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed) mut => VT.GetStoredEventInformation(ref this, out Type, out ProcessId, out ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
			public HResult GetManagedStatus(uint32* Flags, uint32 WhichString, uint8* String, uint32 StringSize, uint32* StringNeeded) mut => VT.GetManagedStatus(ref this, Flags, WhichString, String, StringSize, StringNeeded);
			public HResult GetManagedStatusWide(uint32* Flags, uint32 WhichString, char16* String, uint32 StringSize, uint32* StringNeeded) mut => VT.GetManagedStatusWide(ref this, Flags, WhichString, String, StringSize, StringNeeded);
			public HResult ResetManagedStatus(uint32 Flags) mut => VT.ResetManagedStatus(ref this, Flags);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self) GetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Flags) SetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Seconds) GetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Seconds) SetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char8* File, IntBool Append) OpenLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self) CloseLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Mask) GetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Mask) SetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint8* Buffer, uint32 BufferSize, uint32* InputSize) Input;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char8* Buffer) ReturnInput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Mask, char8* Format) Output;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Mask, char8* Format, ref int8 Args) OutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, uint32 Mask, char8* Format) ControlledOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) ControlledOutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, char8* Format) OutputPrompt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, char8* Format, ref int8 Args) OutputPromptVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, uint32 Flags) OutputCurrentState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl) OutputVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint64 Handle) GetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Handle) SetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Offset, char8* Instr, out uint64 EndOffset) Assemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) Disassemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint64 Offset) GetDisassembleEffectiveOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) OutputDisassembly;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) OutputDisassemblyLines;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Offset, int32 Delta, out uint64 NearOffset) GetNearInstruction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint64 Offset) GetReturnOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) OutputStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Class, out uint32 Qualifier) GetDebuggeeType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Type) GetActualProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Type) GetExecutingProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Number) GetNumberPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Start, uint32 Count, uint32* Types) GetPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Number) GetNumberProcessors;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) GetSystemVersion;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Size) GetPageSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self) IsPointer64Bit;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) ReadBugCheckData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Number) GetNumberSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Start, uint32 Count, uint32* Types) GetSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Type) GetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Type) SetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Status) GetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Status) SetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Level) GetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Level) SetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Options) GetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Options) AddEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Options) RemoveEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Options) SetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 OutputLevel, out uint32 BreakLevel) GetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputLevel, uint32 BreakLevel) SetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Slot, char8* Macro) SetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Radix) GetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Radix) SetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) Evaluate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) CoerceValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) CoerceValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, char8* Command, uint32 Flags) Execute;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, char8* CommandFile, uint32 Flags) ExecuteCommandFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Number) GetNumberBreakpoints;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, out IDebugBreakpoint* Bp) GetBreakpointByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Id, out IDebugBreakpoint* Bp) GetBreakpointById;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) GetBreakpointParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) AddBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, ref IDebugBreakpoint Bp) RemoveBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char8* Path, uint32 Flags, out uint64 Handle) AddExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Handle) RemoveExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char8* Path, out uint64 Handle) GetExtensionByPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Handle, char8* Function, char8* Arguments) CallExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Handle, char8* FuncName, out FARPROC Function) GetExtensionFunction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out WINDBG_EXTENSION_APIS32 Api) GetWindbgExtensionApis32;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out WINDBG_EXTENSION_APIS64 Api) GetWindbgExtensionApis64;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) GetNumberEventFilters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char8* Command) SetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) GetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) SetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char8* Argument) SetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) GetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) SetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char8* Command) SetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Flags, uint32 Timeout) WaitForEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 TimeDate) GetCurrentTimeDate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 UpTime) GetCurrentSystemUpTime;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 FormatFlags) GetDumpFormatFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 NumRepl) GetNumberTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char8* SrcText, char8* DstText) SetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self) RemoveTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, uint32 Flags) OutputTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Options) GetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Options) AddAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Options) RemoveAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Options) SetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Flags) GetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Flags) SetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char8* AbbrevName) SetExpressionSyntaxByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Number) GetNumberExpressionSyntaxes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetExpressionSyntaxNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Events) GetNumberEvents;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) GetEventIndexDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Index) GetCurrentEventIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Relation, uint32 Value, out uint32 NextIndex) SetNextEventIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* File, IntBool Append) OpenLogFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* Buffer, uint32 BufferSize, uint32* InputSize) InputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* Buffer) ReturnInputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Mask, char16* Format) OutputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Mask, char16* Format, ref int8 Args) OutputVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, uint32 Mask, char16* Format) ControlledOutputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, uint32 Mask, char16* Format, ref int8 Args) ControlledOutputVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, char16* Format) OutputPromptWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, char16* Format, ref int8 Args) OutputPromptVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptTextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Offset, char16* Instr, out uint64 EndOffset) AssembleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Offset, uint32 Flags, char16* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) DisassembleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Type, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNamesWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Slot, char16* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacroWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Slot, char16* Macro) SetTextMacroWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) EvaluateWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, char16* Command, uint32 Flags) ExecuteWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, char16* CommandFile, uint32 Flags) ExecuteCommandFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, out IDebugBreakpoint2* Bp) GetBreakpointByIndex2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Id, out IDebugBreakpoint2* Bp) GetBreakpointById2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint2* Bp) AddBreakpoint2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, ref IDebugBreakpoint2 Bp) RemoveBreakpoint2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* Path, uint32 Flags, out uint64 Handle) AddExtensionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* Path, out uint64 Handle) GetExtensionByPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Handle, char16* Function, char16* Arguments) CallExtensionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint64 Handle, char16* FuncName, out FARPROC Function) GetExtensionFunctionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterTextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char16* Command) SetEventFilterCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgumentWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char16* Argument) SetSpecificFilterArgumentWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char16* Command) SetExceptionFilterSecondCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, char16* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* SrcText, uint32 Index, char16* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, char16* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* SrcText, char16* DstText) SetTextReplacementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* AbbrevName) SetExpressionSyntaxByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetExpressionSyntaxNamesWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Index, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* DescSize) GetEventIndexDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) GetLogFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char8* File, uint32 Flags) OpenLogFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) GetLogFile2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, char16* File, uint32 Flags) OpenLogFile2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 PlatformId, out uint32 Win32Major, out uint32 Win32Minor, uint32* KdMajor, uint32* KdMinor) GetSystemVersionValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSystemVersionString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSystemVersionStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) GetContextStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) OutputContextStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* Context, uint32 ContextSize, uint32* ContextUsed, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed) GetStoredEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32* Flags, uint32 WhichString, uint8* String, uint32 StringSize, uint32* StringNeeded) GetManagedStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32* Flags, uint32 WhichString, char16* String, uint32 StringSize, uint32* StringNeeded) GetManagedStatusWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl4 self, uint32 Flags) ResetManagedStatus;
			}
		}
		[CRepr]
		public struct IDebugControl5 : IUnknown
		{
			public const new Guid IID = .(0xb2ffe162, 0x2412, 0x429f, 0x8d, 0x1d, 0x5b, 0xf6, 0xdd, 0x82, 0x46, 0x96);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterrupt() mut => VT.GetInterrupt(ref this);
			public HResult SetInterrupt(uint32 Flags) mut => VT.SetInterrupt(ref this, Flags);
			public HResult GetInterruptTimeout(out uint32 Seconds) mut => VT.GetInterruptTimeout(ref this, out Seconds);
			public HResult SetInterruptTimeout(uint32 Seconds) mut => VT.SetInterruptTimeout(ref this, Seconds);
			public HResult GetLogFile(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFile(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFile(char8* File, IntBool Append) mut => VT.OpenLogFile(ref this, File, Append);
			public HResult CloseLogFile() mut => VT.CloseLogFile(ref this);
			public HResult GetLogMask(out uint32 Mask) mut => VT.GetLogMask(ref this, out Mask);
			public HResult SetLogMask(uint32 Mask) mut => VT.SetLogMask(ref this, Mask);
			public HResult Input(uint8* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.Input(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInput(char8* Buffer) mut => VT.ReturnInput(ref this, Buffer);
			public HResult Output(uint32 Mask, char8* Format) mut => VT.Output(ref this, Mask, Format);
			public HResult OutputVaList(uint32 Mask, char8* Format, ref int8 Args) mut => VT.OutputVaList(ref this, Mask, Format, ref Args);
			public HResult ControlledOutput(uint32 OutputControl, uint32 Mask, char8* Format) mut => VT.ControlledOutput(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaList(uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) mut => VT.ControlledOutputVaList(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPrompt(uint32 OutputControl, char8* Format) mut => VT.OutputPrompt(ref this, OutputControl, Format);
			public HResult OutputPromptVaList(uint32 OutputControl, char8* Format, ref int8 Args) mut => VT.OutputPromptVaList(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptText(uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptText(ref this, Buffer, BufferSize, TextSize);
			public HResult OutputCurrentState(uint32 OutputControl, uint32 Flags) mut => VT.OutputCurrentState(ref this, OutputControl, Flags);
			public HResult OutputVersionInformation(uint32 OutputControl) mut => VT.OutputVersionInformation(ref this, OutputControl);
			public HResult GetNotifyEventHandle(out uint64 Handle) mut => VT.GetNotifyEventHandle(ref this, out Handle);
			public HResult SetNotifyEventHandle(uint64 Handle) mut => VT.SetNotifyEventHandle(ref this, Handle);
			public HResult Assemble(uint64 Offset, char8* Instr, out uint64 EndOffset) mut => VT.Assemble(ref this, Offset, Instr, out EndOffset);
			public HResult Disassemble(uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.Disassemble(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetDisassembleEffectiveOffset(out uint64 Offset) mut => VT.GetDisassembleEffectiveOffset(ref this, out Offset);
			public HResult OutputDisassembly(uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) mut => VT.OutputDisassembly(ref this, OutputControl, Offset, Flags, out EndOffset);
			public HResult OutputDisassemblyLines(uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) mut => VT.OutputDisassemblyLines(ref this, OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
			public HResult GetNearInstruction(uint64 Offset, int32 Delta, out uint64 NearOffset) mut => VT.GetNearInstruction(ref this, Offset, Delta, out NearOffset);
			public HResult GetStackTrace(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTrace(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult GetReturnOffset(out uint64 Offset) mut => VT.GetReturnOffset(ref this, out Offset);
			public HResult OutputStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTrace(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetDebuggeeType(out uint32 Class, out uint32 Qualifier) mut => VT.GetDebuggeeType(ref this, out Class, out Qualifier);
			public HResult GetActualProcessorType(out uint32 Type) mut => VT.GetActualProcessorType(ref this, out Type);
			public HResult GetExecutingProcessorType(out uint32 Type) mut => VT.GetExecutingProcessorType(ref this, out Type);
			public HResult GetNumberPossibleExecutingProcessorTypes(out uint32 Number) mut => VT.GetNumberPossibleExecutingProcessorTypes(ref this, out Number);
			public HResult GetPossibleExecutingProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetPossibleExecutingProcessorTypes(ref this, Start, Count, Types);
			public HResult GetNumberProcessors(out uint32 Number) mut => VT.GetNumberProcessors(ref this, out Number);
			public HResult GetSystemVersion(out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) mut => VT.GetSystemVersion(ref this, out PlatformId, out Major, out Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, out ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
			public HResult GetPageSize(out uint32 Size) mut => VT.GetPageSize(ref this, out Size);
			public HResult IsPointer64Bit() mut => VT.IsPointer64Bit(ref this);
			public HResult ReadBugCheckData(out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) mut => VT.ReadBugCheckData(ref this, out Code, out Arg1, out Arg2, out Arg3, out Arg4);
			public HResult GetNumberSupportedProcessorTypes(out uint32 Number) mut => VT.GetNumberSupportedProcessorTypes(ref this, out Number);
			public HResult GetSupportedProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetSupportedProcessorTypes(ref this, Start, Count, Types);
			public HResult GetProcessorTypeNames(uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNames(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEffectiveProcessorType(out uint32 Type) mut => VT.GetEffectiveProcessorType(ref this, out Type);
			public HResult SetEffectiveProcessorType(uint32 Type) mut => VT.SetEffectiveProcessorType(ref this, Type);
			public HResult GetExecutionStatus(out uint32 Status) mut => VT.GetExecutionStatus(ref this, out Status);
			public HResult SetExecutionStatus(uint32 Status) mut => VT.SetExecutionStatus(ref this, Status);
			public HResult GetCodeLevel(out uint32 Level) mut => VT.GetCodeLevel(ref this, out Level);
			public HResult SetCodeLevel(uint32 Level) mut => VT.SetCodeLevel(ref this, Level);
			public HResult GetEngineOptions(out uint32 Options) mut => VT.GetEngineOptions(ref this, out Options);
			public HResult AddEngineOptions(uint32 Options) mut => VT.AddEngineOptions(ref this, Options);
			public HResult RemoveEngineOptions(uint32 Options) mut => VT.RemoveEngineOptions(ref this, Options);
			public HResult SetEngineOptions(uint32 Options) mut => VT.SetEngineOptions(ref this, Options);
			public HResult GetSystemErrorControl(out uint32 OutputLevel, out uint32 BreakLevel) mut => VT.GetSystemErrorControl(ref this, out OutputLevel, out BreakLevel);
			public HResult SetSystemErrorControl(uint32 OutputLevel, uint32 BreakLevel) mut => VT.SetSystemErrorControl(ref this, OutputLevel, BreakLevel);
			public HResult GetTextMacro(uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacro(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacro(uint32 Slot, char8* Macro) mut => VT.SetTextMacro(ref this, Slot, Macro);
			public HResult GetRadix(out uint32 Radix) mut => VT.GetRadix(ref this, out Radix);
			public HResult SetRadix(uint32 Radix) mut => VT.SetRadix(ref this, Radix);
			public HResult Evaluate(char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.Evaluate(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult CoerceValue(ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) mut => VT.CoerceValue(ref this, ref In, OutType, out Out);
			public HResult CoerceValues(uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) mut => VT.CoerceValues(ref this, Count, In, OutTypes, Out);
			public HResult Execute(uint32 OutputControl, char8* Command, uint32 Flags) mut => VT.Execute(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFile(uint32 OutputControl, char8* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFile(ref this, OutputControl, CommandFile, Flags);
			public HResult GetNumberBreakpoints(out uint32 Number) mut => VT.GetNumberBreakpoints(ref this, out Number);
			public HResult GetBreakpointByIndex(uint32 Index, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointByIndex(ref this, Index, out Bp);
			public HResult GetBreakpointById(uint32 Id, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointById(ref this, Id, out Bp);
			public HResult GetBreakpointParameters(uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) mut => VT.GetBreakpointParameters(ref this, Count, Ids, Start, Params);
			public HResult AddBreakpoint(uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) mut => VT.AddBreakpoint(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint(ref IDebugBreakpoint Bp) mut => VT.RemoveBreakpoint(ref this, ref Bp);
			public HResult AddExtension(char8* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtension(ref this, Path, Flags, out Handle);
			public HResult RemoveExtension(uint64 Handle) mut => VT.RemoveExtension(ref this, Handle);
			public HResult GetExtensionByPath(char8* Path, out uint64 Handle) mut => VT.GetExtensionByPath(ref this, Path, out Handle);
			public HResult CallExtension(uint64 Handle, char8* Function, char8* Arguments) mut => VT.CallExtension(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunction(uint64 Handle, char8* FuncName, out FARPROC Function) mut => VT.GetExtensionFunction(ref this, Handle, FuncName, out Function);
			public HResult GetWindbgExtensionApis32(out WINDBG_EXTENSION_APIS32 Api) mut => VT.GetWindbgExtensionApis32(ref this, out Api);
			public HResult GetWindbgExtensionApis64(out WINDBG_EXTENSION_APIS64 Api) mut => VT.GetWindbgExtensionApis64(ref this, out Api);
			public HResult GetNumberEventFilters(out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) mut => VT.GetNumberEventFilters(ref this, out SpecificEvents, out SpecificExceptions, out ArbitraryExceptions);
			public HResult GetEventFilterText(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterText(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommand(uint32 Index, char8* Command) mut => VT.SetEventFilterCommand(ref this, Index, Command);
			public HResult GetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.GetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult SetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.SetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult GetSpecificFilterArgument(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgument(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgument(uint32 Index, char8* Argument) mut => VT.SetSpecificFilterArgument(ref this, Index, Argument);
			public HResult GetExceptionFilterParameters(uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.GetExceptionFilterParameters(ref this, Count, Codes, Start, Params);
			public HResult SetExceptionFilterParameters(uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.SetExceptionFilterParameters(ref this, Count, Params);
			public HResult GetExceptionFilterSecondCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommand(uint32 Index, char8* Command) mut => VT.SetExceptionFilterSecondCommand(ref this, Index, Command);
			public HResult WaitForEvent(uint32 Flags, uint32 Timeout) mut => VT.WaitForEvent(ref this, Flags, Timeout);
			public HResult GetLastEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformation(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetCurrentTimeDate(out uint32 TimeDate) mut => VT.GetCurrentTimeDate(ref this, out TimeDate);
			public HResult GetCurrentSystemUpTime(out uint32 UpTime) mut => VT.GetCurrentSystemUpTime(ref this, out UpTime);
			public HResult GetDumpFormatFlags(out uint32 FormatFlags) mut => VT.GetDumpFormatFlags(ref this, out FormatFlags);
			public HResult GetNumberTextReplacements(out uint32 NumRepl) mut => VT.GetNumberTextReplacements(ref this, out NumRepl);
			public HResult GetTextReplacement(char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacement(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacement(char8* SrcText, char8* DstText) mut => VT.SetTextReplacement(ref this, SrcText, DstText);
			public HResult RemoveTextReplacements() mut => VT.RemoveTextReplacements(ref this);
			public HResult OutputTextReplacements(uint32 OutputControl, uint32 Flags) mut => VT.OutputTextReplacements(ref this, OutputControl, Flags);
			public HResult GetAssemblyOptions(out uint32 Options) mut => VT.GetAssemblyOptions(ref this, out Options);
			public HResult AddAssemblyOptions(uint32 Options) mut => VT.AddAssemblyOptions(ref this, Options);
			public HResult RemoveAssemblyOptions(uint32 Options) mut => VT.RemoveAssemblyOptions(ref this, Options);
			public HResult SetAssemblyOptions(uint32 Options) mut => VT.SetAssemblyOptions(ref this, Options);
			public HResult GetExpressionSyntax(out uint32 Flags) mut => VT.GetExpressionSyntax(ref this, out Flags);
			public HResult SetExpressionSyntax(uint32 Flags) mut => VT.SetExpressionSyntax(ref this, Flags);
			public HResult SetExpressionSyntaxByName(char8* AbbrevName) mut => VT.SetExpressionSyntaxByName(ref this, AbbrevName);
			public HResult GetNumberExpressionSyntaxes(out uint32 Number) mut => VT.GetNumberExpressionSyntaxes(ref this, out Number);
			public HResult GetExpressionSyntaxNames(uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetExpressionSyntaxNames(ref this, Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetNumberEvents(out uint32 Events) mut => VT.GetNumberEvents(ref this, out Events);
			public HResult GetEventIndexDescription(uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) mut => VT.GetEventIndexDescription(ref this, Index, Which, Buffer, BufferSize, DescSize);
			public HResult GetCurrentEventIndex(out uint32 Index) mut => VT.GetCurrentEventIndex(ref this, out Index);
			public HResult SetNextEventIndex(uint32 Relation, uint32 Value, out uint32 NextIndex) mut => VT.SetNextEventIndex(ref this, Relation, Value, out NextIndex);
			public HResult GetLogFileWide(char16* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFileWide(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFileWide(char16* File, IntBool Append) mut => VT.OpenLogFileWide(ref this, File, Append);
			public HResult InputWide(char16* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.InputWide(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInputWide(char16* Buffer) mut => VT.ReturnInputWide(ref this, Buffer);
			public HResult OutputWide(uint32 Mask, char16* Format) mut => VT.OutputWide(ref this, Mask, Format);
			public HResult OutputVaListWide(uint32 Mask, char16* Format, ref int8 Args) mut => VT.OutputVaListWide(ref this, Mask, Format, ref Args);
			public HResult ControlledOutputWide(uint32 OutputControl, uint32 Mask, char16* Format) mut => VT.ControlledOutputWide(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaListWide(uint32 OutputControl, uint32 Mask, char16* Format, ref int8 Args) mut => VT.ControlledOutputVaListWide(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPromptWide(uint32 OutputControl, char16* Format) mut => VT.OutputPromptWide(ref this, OutputControl, Format);
			public HResult OutputPromptVaListWide(uint32 OutputControl, char16* Format, ref int8 Args) mut => VT.OutputPromptVaListWide(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptTextWide(char16* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptTextWide(ref this, Buffer, BufferSize, TextSize);
			public HResult AssembleWide(uint64 Offset, char16* Instr, out uint64 EndOffset) mut => VT.AssembleWide(ref this, Offset, Instr, out EndOffset);
			public HResult DisassembleWide(uint64 Offset, uint32 Flags, char16* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.DisassembleWide(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetProcessorTypeNamesWide(uint32 Type, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNamesWide(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetTextMacroWide(uint32 Slot, char16* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacroWide(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacroWide(uint32 Slot, char16* Macro) mut => VT.SetTextMacroWide(ref this, Slot, Macro);
			public HResult EvaluateWide(char16* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.EvaluateWide(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult ExecuteWide(uint32 OutputControl, char16* Command, uint32 Flags) mut => VT.ExecuteWide(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFileWide(uint32 OutputControl, char16* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFileWide(ref this, OutputControl, CommandFile, Flags);
			public HResult GetBreakpointByIndex2(uint32 Index, out IDebugBreakpoint2* Bp) mut => VT.GetBreakpointByIndex2(ref this, Index, out Bp);
			public HResult GetBreakpointById2(uint32 Id, out IDebugBreakpoint2* Bp) mut => VT.GetBreakpointById2(ref this, Id, out Bp);
			public HResult AddBreakpoint2(uint32 Type, uint32 DesiredId, out IDebugBreakpoint2* Bp) mut => VT.AddBreakpoint2(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint2(ref IDebugBreakpoint2 Bp) mut => VT.RemoveBreakpoint2(ref this, ref Bp);
			public HResult AddExtensionWide(char16* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtensionWide(ref this, Path, Flags, out Handle);
			public HResult GetExtensionByPathWide(char16* Path, out uint64 Handle) mut => VT.GetExtensionByPathWide(ref this, Path, out Handle);
			public HResult CallExtensionWide(uint64 Handle, char16* Function, char16* Arguments) mut => VT.CallExtensionWide(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunctionWide(uint64 Handle, char16* FuncName, out FARPROC Function) mut => VT.GetExtensionFunctionWide(ref this, Handle, FuncName, out Function);
			public HResult GetEventFilterTextWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterTextWide(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommandWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommandWide(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommandWide(uint32 Index, char16* Command) mut => VT.SetEventFilterCommandWide(ref this, Index, Command);
			public HResult GetSpecificFilterArgumentWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgumentWide(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgumentWide(uint32 Index, char16* Argument) mut => VT.SetSpecificFilterArgumentWide(ref this, Index, Argument);
			public HResult GetExceptionFilterSecondCommandWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommandWide(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommandWide(uint32 Index, char16* Command) mut => VT.SetExceptionFilterSecondCommandWide(ref this, Index, Command);
			public HResult GetLastEventInformationWide(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, char16* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformationWide(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetTextReplacementWide(char16* SrcText, uint32 Index, char16* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, char16* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacementWide(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacementWide(char16* SrcText, char16* DstText) mut => VT.SetTextReplacementWide(ref this, SrcText, DstText);
			public HResult SetExpressionSyntaxByNameWide(char16* AbbrevName) mut => VT.SetExpressionSyntaxByNameWide(ref this, AbbrevName);
			public HResult GetExpressionSyntaxNamesWide(uint32 Index, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetExpressionSyntaxNamesWide(ref this, Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEventIndexDescriptionWide(uint32 Index, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* DescSize) mut => VT.GetEventIndexDescriptionWide(ref this, Index, Which, Buffer, BufferSize, DescSize);
			public HResult GetLogFile2(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) mut => VT.GetLogFile2(ref this, Buffer, BufferSize, FileSize, out Flags);
			public HResult OpenLogFile2(char8* File, uint32 Flags) mut => VT.OpenLogFile2(ref this, File, Flags);
			public HResult GetLogFile2Wide(char16* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) mut => VT.GetLogFile2Wide(ref this, Buffer, BufferSize, FileSize, out Flags);
			public HResult OpenLogFile2Wide(char16* File, uint32 Flags) mut => VT.OpenLogFile2Wide(ref this, File, Flags);
			public HResult GetSystemVersionValues(out uint32 PlatformId, out uint32 Win32Major, out uint32 Win32Minor, uint32* KdMajor, uint32* KdMinor) mut => VT.GetSystemVersionValues(ref this, out PlatformId, out Win32Major, out Win32Minor, KdMajor, KdMinor);
			public HResult GetSystemVersionString(uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSystemVersionString(ref this, Which, Buffer, BufferSize, StringSize);
			public HResult GetSystemVersionStringWide(uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSystemVersionStringWide(ref this, Which, Buffer, BufferSize, StringSize);
			public HResult GetContextStackTrace(void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) mut => VT.GetContextStackTrace(ref this, StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
			public HResult OutputContextStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) mut => VT.OutputContextStackTrace(ref this, OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
			public HResult GetStoredEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* Context, uint32 ContextSize, uint32* ContextUsed, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed) mut => VT.GetStoredEventInformation(ref this, out Type, out ProcessId, out ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
			public HResult GetManagedStatus(uint32* Flags, uint32 WhichString, uint8* String, uint32 StringSize, uint32* StringNeeded) mut => VT.GetManagedStatus(ref this, Flags, WhichString, String, StringSize, StringNeeded);
			public HResult GetManagedStatusWide(uint32* Flags, uint32 WhichString, char16* String, uint32 StringSize, uint32* StringNeeded) mut => VT.GetManagedStatusWide(ref this, Flags, WhichString, String, StringSize, StringNeeded);
			public HResult ResetManagedStatus(uint32 Flags) mut => VT.ResetManagedStatus(ref this, Flags);
			public HResult GetStackTraceEx(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTraceEx(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult OutputStackTraceEx(uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTraceEx(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetContextStackTraceEx(void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) mut => VT.GetContextStackTraceEx(ref this, StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
			public HResult OutputContextStackTraceEx(uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) mut => VT.OutputContextStackTraceEx(ref this, OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
			public HResult GetBreakpointByGuid(ref Guid Guid, out IDebugBreakpoint3* Bp) mut => VT.GetBreakpointByGuid(ref this, ref Guid, out Bp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self) GetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Flags) SetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Seconds) GetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Seconds) SetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char8* File, IntBool Append) OpenLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self) CloseLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Mask) GetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Mask) SetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint8* Buffer, uint32 BufferSize, uint32* InputSize) Input;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char8* Buffer) ReturnInput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Mask, char8* Format) Output;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Mask, char8* Format, ref int8 Args) OutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, uint32 Mask, char8* Format) ControlledOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) ControlledOutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, char8* Format) OutputPrompt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, char8* Format, ref int8 Args) OutputPromptVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, uint32 Flags) OutputCurrentState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl) OutputVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint64 Handle) GetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Handle) SetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Offset, char8* Instr, out uint64 EndOffset) Assemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) Disassemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint64 Offset) GetDisassembleEffectiveOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) OutputDisassembly;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) OutputDisassemblyLines;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Offset, int32 Delta, out uint64 NearOffset) GetNearInstruction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint64 Offset) GetReturnOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) OutputStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Class, out uint32 Qualifier) GetDebuggeeType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Type) GetActualProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Type) GetExecutingProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Number) GetNumberPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Start, uint32 Count, uint32* Types) GetPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Number) GetNumberProcessors;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) GetSystemVersion;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Size) GetPageSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self) IsPointer64Bit;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) ReadBugCheckData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Number) GetNumberSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Start, uint32 Count, uint32* Types) GetSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Type) GetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Type) SetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Status) GetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Status) SetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Level) GetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Level) SetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Options) GetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Options) AddEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Options) RemoveEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Options) SetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 OutputLevel, out uint32 BreakLevel) GetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputLevel, uint32 BreakLevel) SetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Slot, char8* Macro) SetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Radix) GetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Radix) SetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) Evaluate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) CoerceValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) CoerceValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, char8* Command, uint32 Flags) Execute;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, char8* CommandFile, uint32 Flags) ExecuteCommandFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Number) GetNumberBreakpoints;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, out IDebugBreakpoint* Bp) GetBreakpointByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Id, out IDebugBreakpoint* Bp) GetBreakpointById;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) GetBreakpointParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) AddBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, ref IDebugBreakpoint Bp) RemoveBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char8* Path, uint32 Flags, out uint64 Handle) AddExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Handle) RemoveExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char8* Path, out uint64 Handle) GetExtensionByPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Handle, char8* Function, char8* Arguments) CallExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Handle, char8* FuncName, out FARPROC Function) GetExtensionFunction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out WINDBG_EXTENSION_APIS32 Api) GetWindbgExtensionApis32;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out WINDBG_EXTENSION_APIS64 Api) GetWindbgExtensionApis64;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) GetNumberEventFilters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char8* Command) SetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) GetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) SetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char8* Argument) SetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) GetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) SetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char8* Command) SetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Flags, uint32 Timeout) WaitForEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 TimeDate) GetCurrentTimeDate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 UpTime) GetCurrentSystemUpTime;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 FormatFlags) GetDumpFormatFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 NumRepl) GetNumberTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char8* SrcText, char8* DstText) SetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self) RemoveTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, uint32 Flags) OutputTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Options) GetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Options) AddAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Options) RemoveAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Options) SetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Flags) GetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Flags) SetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char8* AbbrevName) SetExpressionSyntaxByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Number) GetNumberExpressionSyntaxes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetExpressionSyntaxNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Events) GetNumberEvents;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) GetEventIndexDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Index) GetCurrentEventIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Relation, uint32 Value, out uint32 NextIndex) SetNextEventIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* File, IntBool Append) OpenLogFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* Buffer, uint32 BufferSize, uint32* InputSize) InputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* Buffer) ReturnInputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Mask, char16* Format) OutputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Mask, char16* Format, ref int8 Args) OutputVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, uint32 Mask, char16* Format) ControlledOutputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, uint32 Mask, char16* Format, ref int8 Args) ControlledOutputVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, char16* Format) OutputPromptWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, char16* Format, ref int8 Args) OutputPromptVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptTextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Offset, char16* Instr, out uint64 EndOffset) AssembleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Offset, uint32 Flags, char16* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) DisassembleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Type, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNamesWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Slot, char16* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacroWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Slot, char16* Macro) SetTextMacroWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) EvaluateWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, char16* Command, uint32 Flags) ExecuteWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, char16* CommandFile, uint32 Flags) ExecuteCommandFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, out IDebugBreakpoint2* Bp) GetBreakpointByIndex2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Id, out IDebugBreakpoint2* Bp) GetBreakpointById2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint2* Bp) AddBreakpoint2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, ref IDebugBreakpoint2 Bp) RemoveBreakpoint2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* Path, uint32 Flags, out uint64 Handle) AddExtensionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* Path, out uint64 Handle) GetExtensionByPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Handle, char16* Function, char16* Arguments) CallExtensionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 Handle, char16* FuncName, out FARPROC Function) GetExtensionFunctionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterTextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char16* Command) SetEventFilterCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgumentWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char16* Argument) SetSpecificFilterArgumentWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char16* Command) SetExceptionFilterSecondCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, char16* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* SrcText, uint32 Index, char16* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, char16* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* SrcText, char16* DstText) SetTextReplacementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* AbbrevName) SetExpressionSyntaxByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetExpressionSyntaxNamesWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Index, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* DescSize) GetEventIndexDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) GetLogFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char8* File, uint32 Flags) OpenLogFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) GetLogFile2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, char16* File, uint32 Flags) OpenLogFile2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 PlatformId, out uint32 Win32Major, out uint32 Win32Minor, uint32* KdMajor, uint32* KdMinor) GetSystemVersionValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSystemVersionString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSystemVersionStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) GetContextStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) OutputContextStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* Context, uint32 ContextSize, uint32* ContextUsed, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed) GetStoredEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32* Flags, uint32 WhichString, uint8* String, uint32 StringSize, uint32* StringNeeded) GetManagedStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32* Flags, uint32 WhichString, char16* String, uint32 StringSize, uint32* StringNeeded) GetManagedStatusWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 Flags) ResetManagedStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32 Flags) OutputStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) GetContextStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) OutputContextStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl5 self, ref Guid Guid, out IDebugBreakpoint3* Bp) GetBreakpointByGuid;
			}
		}
		[CRepr]
		public struct IDebugControl6 : IUnknown
		{
			public const new Guid IID = .(0xbc0d583f, 0x126d, 0x43a1, 0x9c, 0xc4, 0xa8, 0x60, 0xab, 0x1d, 0x53, 0x7b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterrupt() mut => VT.GetInterrupt(ref this);
			public HResult SetInterrupt(uint32 Flags) mut => VT.SetInterrupt(ref this, Flags);
			public HResult GetInterruptTimeout(out uint32 Seconds) mut => VT.GetInterruptTimeout(ref this, out Seconds);
			public HResult SetInterruptTimeout(uint32 Seconds) mut => VT.SetInterruptTimeout(ref this, Seconds);
			public HResult GetLogFile(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFile(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFile(char8* File, IntBool Append) mut => VT.OpenLogFile(ref this, File, Append);
			public HResult CloseLogFile() mut => VT.CloseLogFile(ref this);
			public HResult GetLogMask(out uint32 Mask) mut => VT.GetLogMask(ref this, out Mask);
			public HResult SetLogMask(uint32 Mask) mut => VT.SetLogMask(ref this, Mask);
			public HResult Input(uint8* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.Input(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInput(char8* Buffer) mut => VT.ReturnInput(ref this, Buffer);
			public HResult Output(uint32 Mask, char8* Format) mut => VT.Output(ref this, Mask, Format);
			public HResult OutputVaList(uint32 Mask, char8* Format, ref int8 Args) mut => VT.OutputVaList(ref this, Mask, Format, ref Args);
			public HResult ControlledOutput(uint32 OutputControl, uint32 Mask, char8* Format) mut => VT.ControlledOutput(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaList(uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) mut => VT.ControlledOutputVaList(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPrompt(uint32 OutputControl, char8* Format) mut => VT.OutputPrompt(ref this, OutputControl, Format);
			public HResult OutputPromptVaList(uint32 OutputControl, char8* Format, ref int8 Args) mut => VT.OutputPromptVaList(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptText(uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptText(ref this, Buffer, BufferSize, TextSize);
			public HResult OutputCurrentState(uint32 OutputControl, uint32 Flags) mut => VT.OutputCurrentState(ref this, OutputControl, Flags);
			public HResult OutputVersionInformation(uint32 OutputControl) mut => VT.OutputVersionInformation(ref this, OutputControl);
			public HResult GetNotifyEventHandle(out uint64 Handle) mut => VT.GetNotifyEventHandle(ref this, out Handle);
			public HResult SetNotifyEventHandle(uint64 Handle) mut => VT.SetNotifyEventHandle(ref this, Handle);
			public HResult Assemble(uint64 Offset, char8* Instr, out uint64 EndOffset) mut => VT.Assemble(ref this, Offset, Instr, out EndOffset);
			public HResult Disassemble(uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.Disassemble(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetDisassembleEffectiveOffset(out uint64 Offset) mut => VT.GetDisassembleEffectiveOffset(ref this, out Offset);
			public HResult OutputDisassembly(uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) mut => VT.OutputDisassembly(ref this, OutputControl, Offset, Flags, out EndOffset);
			public HResult OutputDisassemblyLines(uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) mut => VT.OutputDisassemblyLines(ref this, OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
			public HResult GetNearInstruction(uint64 Offset, int32 Delta, out uint64 NearOffset) mut => VT.GetNearInstruction(ref this, Offset, Delta, out NearOffset);
			public HResult GetStackTrace(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTrace(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult GetReturnOffset(out uint64 Offset) mut => VT.GetReturnOffset(ref this, out Offset);
			public HResult OutputStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTrace(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetDebuggeeType(out uint32 Class, out uint32 Qualifier) mut => VT.GetDebuggeeType(ref this, out Class, out Qualifier);
			public HResult GetActualProcessorType(out uint32 Type) mut => VT.GetActualProcessorType(ref this, out Type);
			public HResult GetExecutingProcessorType(out uint32 Type) mut => VT.GetExecutingProcessorType(ref this, out Type);
			public HResult GetNumberPossibleExecutingProcessorTypes(out uint32 Number) mut => VT.GetNumberPossibleExecutingProcessorTypes(ref this, out Number);
			public HResult GetPossibleExecutingProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetPossibleExecutingProcessorTypes(ref this, Start, Count, Types);
			public HResult GetNumberProcessors(out uint32 Number) mut => VT.GetNumberProcessors(ref this, out Number);
			public HResult GetSystemVersion(out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) mut => VT.GetSystemVersion(ref this, out PlatformId, out Major, out Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, out ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
			public HResult GetPageSize(out uint32 Size) mut => VT.GetPageSize(ref this, out Size);
			public HResult IsPointer64Bit() mut => VT.IsPointer64Bit(ref this);
			public HResult ReadBugCheckData(out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) mut => VT.ReadBugCheckData(ref this, out Code, out Arg1, out Arg2, out Arg3, out Arg4);
			public HResult GetNumberSupportedProcessorTypes(out uint32 Number) mut => VT.GetNumberSupportedProcessorTypes(ref this, out Number);
			public HResult GetSupportedProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetSupportedProcessorTypes(ref this, Start, Count, Types);
			public HResult GetProcessorTypeNames(uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNames(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEffectiveProcessorType(out uint32 Type) mut => VT.GetEffectiveProcessorType(ref this, out Type);
			public HResult SetEffectiveProcessorType(uint32 Type) mut => VT.SetEffectiveProcessorType(ref this, Type);
			public HResult GetExecutionStatus(out uint32 Status) mut => VT.GetExecutionStatus(ref this, out Status);
			public HResult SetExecutionStatus(uint32 Status) mut => VT.SetExecutionStatus(ref this, Status);
			public HResult GetCodeLevel(out uint32 Level) mut => VT.GetCodeLevel(ref this, out Level);
			public HResult SetCodeLevel(uint32 Level) mut => VT.SetCodeLevel(ref this, Level);
			public HResult GetEngineOptions(out uint32 Options) mut => VT.GetEngineOptions(ref this, out Options);
			public HResult AddEngineOptions(uint32 Options) mut => VT.AddEngineOptions(ref this, Options);
			public HResult RemoveEngineOptions(uint32 Options) mut => VT.RemoveEngineOptions(ref this, Options);
			public HResult SetEngineOptions(uint32 Options) mut => VT.SetEngineOptions(ref this, Options);
			public HResult GetSystemErrorControl(out uint32 OutputLevel, out uint32 BreakLevel) mut => VT.GetSystemErrorControl(ref this, out OutputLevel, out BreakLevel);
			public HResult SetSystemErrorControl(uint32 OutputLevel, uint32 BreakLevel) mut => VT.SetSystemErrorControl(ref this, OutputLevel, BreakLevel);
			public HResult GetTextMacro(uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacro(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacro(uint32 Slot, char8* Macro) mut => VT.SetTextMacro(ref this, Slot, Macro);
			public HResult GetRadix(out uint32 Radix) mut => VT.GetRadix(ref this, out Radix);
			public HResult SetRadix(uint32 Radix) mut => VT.SetRadix(ref this, Radix);
			public HResult Evaluate(char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.Evaluate(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult CoerceValue(ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) mut => VT.CoerceValue(ref this, ref In, OutType, out Out);
			public HResult CoerceValues(uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) mut => VT.CoerceValues(ref this, Count, In, OutTypes, Out);
			public HResult Execute(uint32 OutputControl, char8* Command, uint32 Flags) mut => VT.Execute(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFile(uint32 OutputControl, char8* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFile(ref this, OutputControl, CommandFile, Flags);
			public HResult GetNumberBreakpoints(out uint32 Number) mut => VT.GetNumberBreakpoints(ref this, out Number);
			public HResult GetBreakpointByIndex(uint32 Index, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointByIndex(ref this, Index, out Bp);
			public HResult GetBreakpointById(uint32 Id, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointById(ref this, Id, out Bp);
			public HResult GetBreakpointParameters(uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) mut => VT.GetBreakpointParameters(ref this, Count, Ids, Start, Params);
			public HResult AddBreakpoint(uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) mut => VT.AddBreakpoint(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint(ref IDebugBreakpoint Bp) mut => VT.RemoveBreakpoint(ref this, ref Bp);
			public HResult AddExtension(char8* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtension(ref this, Path, Flags, out Handle);
			public HResult RemoveExtension(uint64 Handle) mut => VT.RemoveExtension(ref this, Handle);
			public HResult GetExtensionByPath(char8* Path, out uint64 Handle) mut => VT.GetExtensionByPath(ref this, Path, out Handle);
			public HResult CallExtension(uint64 Handle, char8* Function, char8* Arguments) mut => VT.CallExtension(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunction(uint64 Handle, char8* FuncName, out FARPROC Function) mut => VT.GetExtensionFunction(ref this, Handle, FuncName, out Function);
			public HResult GetWindbgExtensionApis32(out WINDBG_EXTENSION_APIS32 Api) mut => VT.GetWindbgExtensionApis32(ref this, out Api);
			public HResult GetWindbgExtensionApis64(out WINDBG_EXTENSION_APIS64 Api) mut => VT.GetWindbgExtensionApis64(ref this, out Api);
			public HResult GetNumberEventFilters(out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) mut => VT.GetNumberEventFilters(ref this, out SpecificEvents, out SpecificExceptions, out ArbitraryExceptions);
			public HResult GetEventFilterText(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterText(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommand(uint32 Index, char8* Command) mut => VT.SetEventFilterCommand(ref this, Index, Command);
			public HResult GetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.GetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult SetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.SetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult GetSpecificFilterArgument(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgument(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgument(uint32 Index, char8* Argument) mut => VT.SetSpecificFilterArgument(ref this, Index, Argument);
			public HResult GetExceptionFilterParameters(uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.GetExceptionFilterParameters(ref this, Count, Codes, Start, Params);
			public HResult SetExceptionFilterParameters(uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.SetExceptionFilterParameters(ref this, Count, Params);
			public HResult GetExceptionFilterSecondCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommand(uint32 Index, char8* Command) mut => VT.SetExceptionFilterSecondCommand(ref this, Index, Command);
			public HResult WaitForEvent(uint32 Flags, uint32 Timeout) mut => VT.WaitForEvent(ref this, Flags, Timeout);
			public HResult GetLastEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformation(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetCurrentTimeDate(out uint32 TimeDate) mut => VT.GetCurrentTimeDate(ref this, out TimeDate);
			public HResult GetCurrentSystemUpTime(out uint32 UpTime) mut => VT.GetCurrentSystemUpTime(ref this, out UpTime);
			public HResult GetDumpFormatFlags(out uint32 FormatFlags) mut => VT.GetDumpFormatFlags(ref this, out FormatFlags);
			public HResult GetNumberTextReplacements(out uint32 NumRepl) mut => VT.GetNumberTextReplacements(ref this, out NumRepl);
			public HResult GetTextReplacement(char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacement(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacement(char8* SrcText, char8* DstText) mut => VT.SetTextReplacement(ref this, SrcText, DstText);
			public HResult RemoveTextReplacements() mut => VT.RemoveTextReplacements(ref this);
			public HResult OutputTextReplacements(uint32 OutputControl, uint32 Flags) mut => VT.OutputTextReplacements(ref this, OutputControl, Flags);
			public HResult GetAssemblyOptions(out uint32 Options) mut => VT.GetAssemblyOptions(ref this, out Options);
			public HResult AddAssemblyOptions(uint32 Options) mut => VT.AddAssemblyOptions(ref this, Options);
			public HResult RemoveAssemblyOptions(uint32 Options) mut => VT.RemoveAssemblyOptions(ref this, Options);
			public HResult SetAssemblyOptions(uint32 Options) mut => VT.SetAssemblyOptions(ref this, Options);
			public HResult GetExpressionSyntax(out uint32 Flags) mut => VT.GetExpressionSyntax(ref this, out Flags);
			public HResult SetExpressionSyntax(uint32 Flags) mut => VT.SetExpressionSyntax(ref this, Flags);
			public HResult SetExpressionSyntaxByName(char8* AbbrevName) mut => VT.SetExpressionSyntaxByName(ref this, AbbrevName);
			public HResult GetNumberExpressionSyntaxes(out uint32 Number) mut => VT.GetNumberExpressionSyntaxes(ref this, out Number);
			public HResult GetExpressionSyntaxNames(uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetExpressionSyntaxNames(ref this, Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetNumberEvents(out uint32 Events) mut => VT.GetNumberEvents(ref this, out Events);
			public HResult GetEventIndexDescription(uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) mut => VT.GetEventIndexDescription(ref this, Index, Which, Buffer, BufferSize, DescSize);
			public HResult GetCurrentEventIndex(out uint32 Index) mut => VT.GetCurrentEventIndex(ref this, out Index);
			public HResult SetNextEventIndex(uint32 Relation, uint32 Value, out uint32 NextIndex) mut => VT.SetNextEventIndex(ref this, Relation, Value, out NextIndex);
			public HResult GetLogFileWide(char16* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFileWide(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFileWide(char16* File, IntBool Append) mut => VT.OpenLogFileWide(ref this, File, Append);
			public HResult InputWide(char16* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.InputWide(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInputWide(char16* Buffer) mut => VT.ReturnInputWide(ref this, Buffer);
			public HResult OutputWide(uint32 Mask, char16* Format) mut => VT.OutputWide(ref this, Mask, Format);
			public HResult OutputVaListWide(uint32 Mask, char16* Format, ref int8 Args) mut => VT.OutputVaListWide(ref this, Mask, Format, ref Args);
			public HResult ControlledOutputWide(uint32 OutputControl, uint32 Mask, char16* Format) mut => VT.ControlledOutputWide(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaListWide(uint32 OutputControl, uint32 Mask, char16* Format, ref int8 Args) mut => VT.ControlledOutputVaListWide(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPromptWide(uint32 OutputControl, char16* Format) mut => VT.OutputPromptWide(ref this, OutputControl, Format);
			public HResult OutputPromptVaListWide(uint32 OutputControl, char16* Format, ref int8 Args) mut => VT.OutputPromptVaListWide(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptTextWide(char16* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptTextWide(ref this, Buffer, BufferSize, TextSize);
			public HResult AssembleWide(uint64 Offset, char16* Instr, out uint64 EndOffset) mut => VT.AssembleWide(ref this, Offset, Instr, out EndOffset);
			public HResult DisassembleWide(uint64 Offset, uint32 Flags, char16* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.DisassembleWide(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetProcessorTypeNamesWide(uint32 Type, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNamesWide(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetTextMacroWide(uint32 Slot, char16* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacroWide(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacroWide(uint32 Slot, char16* Macro) mut => VT.SetTextMacroWide(ref this, Slot, Macro);
			public HResult EvaluateWide(char16* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.EvaluateWide(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult ExecuteWide(uint32 OutputControl, char16* Command, uint32 Flags) mut => VT.ExecuteWide(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFileWide(uint32 OutputControl, char16* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFileWide(ref this, OutputControl, CommandFile, Flags);
			public HResult GetBreakpointByIndex2(uint32 Index, out IDebugBreakpoint2* Bp) mut => VT.GetBreakpointByIndex2(ref this, Index, out Bp);
			public HResult GetBreakpointById2(uint32 Id, out IDebugBreakpoint2* Bp) mut => VT.GetBreakpointById2(ref this, Id, out Bp);
			public HResult AddBreakpoint2(uint32 Type, uint32 DesiredId, out IDebugBreakpoint2* Bp) mut => VT.AddBreakpoint2(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint2(ref IDebugBreakpoint2 Bp) mut => VT.RemoveBreakpoint2(ref this, ref Bp);
			public HResult AddExtensionWide(char16* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtensionWide(ref this, Path, Flags, out Handle);
			public HResult GetExtensionByPathWide(char16* Path, out uint64 Handle) mut => VT.GetExtensionByPathWide(ref this, Path, out Handle);
			public HResult CallExtensionWide(uint64 Handle, char16* Function, char16* Arguments) mut => VT.CallExtensionWide(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunctionWide(uint64 Handle, char16* FuncName, out FARPROC Function) mut => VT.GetExtensionFunctionWide(ref this, Handle, FuncName, out Function);
			public HResult GetEventFilterTextWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterTextWide(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommandWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommandWide(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommandWide(uint32 Index, char16* Command) mut => VT.SetEventFilterCommandWide(ref this, Index, Command);
			public HResult GetSpecificFilterArgumentWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgumentWide(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgumentWide(uint32 Index, char16* Argument) mut => VT.SetSpecificFilterArgumentWide(ref this, Index, Argument);
			public HResult GetExceptionFilterSecondCommandWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommandWide(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommandWide(uint32 Index, char16* Command) mut => VT.SetExceptionFilterSecondCommandWide(ref this, Index, Command);
			public HResult GetLastEventInformationWide(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, char16* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformationWide(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetTextReplacementWide(char16* SrcText, uint32 Index, char16* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, char16* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacementWide(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacementWide(char16* SrcText, char16* DstText) mut => VT.SetTextReplacementWide(ref this, SrcText, DstText);
			public HResult SetExpressionSyntaxByNameWide(char16* AbbrevName) mut => VT.SetExpressionSyntaxByNameWide(ref this, AbbrevName);
			public HResult GetExpressionSyntaxNamesWide(uint32 Index, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetExpressionSyntaxNamesWide(ref this, Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEventIndexDescriptionWide(uint32 Index, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* DescSize) mut => VT.GetEventIndexDescriptionWide(ref this, Index, Which, Buffer, BufferSize, DescSize);
			public HResult GetLogFile2(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) mut => VT.GetLogFile2(ref this, Buffer, BufferSize, FileSize, out Flags);
			public HResult OpenLogFile2(char8* File, uint32 Flags) mut => VT.OpenLogFile2(ref this, File, Flags);
			public HResult GetLogFile2Wide(char16* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) mut => VT.GetLogFile2Wide(ref this, Buffer, BufferSize, FileSize, out Flags);
			public HResult OpenLogFile2Wide(char16* File, uint32 Flags) mut => VT.OpenLogFile2Wide(ref this, File, Flags);
			public HResult GetSystemVersionValues(out uint32 PlatformId, out uint32 Win32Major, out uint32 Win32Minor, uint32* KdMajor, uint32* KdMinor) mut => VT.GetSystemVersionValues(ref this, out PlatformId, out Win32Major, out Win32Minor, KdMajor, KdMinor);
			public HResult GetSystemVersionString(uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSystemVersionString(ref this, Which, Buffer, BufferSize, StringSize);
			public HResult GetSystemVersionStringWide(uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSystemVersionStringWide(ref this, Which, Buffer, BufferSize, StringSize);
			public HResult GetContextStackTrace(void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) mut => VT.GetContextStackTrace(ref this, StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
			public HResult OutputContextStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) mut => VT.OutputContextStackTrace(ref this, OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
			public HResult GetStoredEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* Context, uint32 ContextSize, uint32* ContextUsed, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed) mut => VT.GetStoredEventInformation(ref this, out Type, out ProcessId, out ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
			public HResult GetManagedStatus(uint32* Flags, uint32 WhichString, uint8* String, uint32 StringSize, uint32* StringNeeded) mut => VT.GetManagedStatus(ref this, Flags, WhichString, String, StringSize, StringNeeded);
			public HResult GetManagedStatusWide(uint32* Flags, uint32 WhichString, char16* String, uint32 StringSize, uint32* StringNeeded) mut => VT.GetManagedStatusWide(ref this, Flags, WhichString, String, StringSize, StringNeeded);
			public HResult ResetManagedStatus(uint32 Flags) mut => VT.ResetManagedStatus(ref this, Flags);
			public HResult GetStackTraceEx(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTraceEx(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult OutputStackTraceEx(uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTraceEx(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetContextStackTraceEx(void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) mut => VT.GetContextStackTraceEx(ref this, StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
			public HResult OutputContextStackTraceEx(uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) mut => VT.OutputContextStackTraceEx(ref this, OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
			public HResult GetBreakpointByGuid(ref Guid Guid, out IDebugBreakpoint3* Bp) mut => VT.GetBreakpointByGuid(ref this, ref Guid, out Bp);
			public HResult GetExecutionStatusEx(out uint32 Status) mut => VT.GetExecutionStatusEx(ref this, out Status);
			public HResult GetSynchronizationStatus(out uint32 SendsAttempted, out uint32 SecondsSinceLastResponse) mut => VT.GetSynchronizationStatus(ref this, out SendsAttempted, out SecondsSinceLastResponse);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self) GetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Flags) SetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Seconds) GetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Seconds) SetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char8* File, IntBool Append) OpenLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self) CloseLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Mask) GetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Mask) SetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint8* Buffer, uint32 BufferSize, uint32* InputSize) Input;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char8* Buffer) ReturnInput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Mask, char8* Format) Output;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Mask, char8* Format, ref int8 Args) OutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, uint32 Mask, char8* Format) ControlledOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) ControlledOutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, char8* Format) OutputPrompt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, char8* Format, ref int8 Args) OutputPromptVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, uint32 Flags) OutputCurrentState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl) OutputVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint64 Handle) GetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Handle) SetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Offset, char8* Instr, out uint64 EndOffset) Assemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) Disassemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint64 Offset) GetDisassembleEffectiveOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) OutputDisassembly;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) OutputDisassemblyLines;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Offset, int32 Delta, out uint64 NearOffset) GetNearInstruction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint64 Offset) GetReturnOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) OutputStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Class, out uint32 Qualifier) GetDebuggeeType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Type) GetActualProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Type) GetExecutingProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Number) GetNumberPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Start, uint32 Count, uint32* Types) GetPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Number) GetNumberProcessors;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) GetSystemVersion;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Size) GetPageSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self) IsPointer64Bit;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) ReadBugCheckData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Number) GetNumberSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Start, uint32 Count, uint32* Types) GetSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Type) GetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Type) SetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Status) GetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Status) SetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Level) GetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Level) SetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Options) GetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Options) AddEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Options) RemoveEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Options) SetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 OutputLevel, out uint32 BreakLevel) GetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputLevel, uint32 BreakLevel) SetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Slot, char8* Macro) SetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Radix) GetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Radix) SetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) Evaluate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) CoerceValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) CoerceValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, char8* Command, uint32 Flags) Execute;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, char8* CommandFile, uint32 Flags) ExecuteCommandFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Number) GetNumberBreakpoints;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, out IDebugBreakpoint* Bp) GetBreakpointByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Id, out IDebugBreakpoint* Bp) GetBreakpointById;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) GetBreakpointParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) AddBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, ref IDebugBreakpoint Bp) RemoveBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char8* Path, uint32 Flags, out uint64 Handle) AddExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Handle) RemoveExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char8* Path, out uint64 Handle) GetExtensionByPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Handle, char8* Function, char8* Arguments) CallExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Handle, char8* FuncName, out FARPROC Function) GetExtensionFunction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out WINDBG_EXTENSION_APIS32 Api) GetWindbgExtensionApis32;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out WINDBG_EXTENSION_APIS64 Api) GetWindbgExtensionApis64;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) GetNumberEventFilters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char8* Command) SetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) GetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) SetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char8* Argument) SetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) GetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) SetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char8* Command) SetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Flags, uint32 Timeout) WaitForEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 TimeDate) GetCurrentTimeDate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 UpTime) GetCurrentSystemUpTime;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 FormatFlags) GetDumpFormatFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 NumRepl) GetNumberTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char8* SrcText, char8* DstText) SetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self) RemoveTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, uint32 Flags) OutputTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Options) GetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Options) AddAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Options) RemoveAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Options) SetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Flags) GetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Flags) SetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char8* AbbrevName) SetExpressionSyntaxByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Number) GetNumberExpressionSyntaxes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetExpressionSyntaxNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Events) GetNumberEvents;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) GetEventIndexDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Index) GetCurrentEventIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Relation, uint32 Value, out uint32 NextIndex) SetNextEventIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* File, IntBool Append) OpenLogFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* Buffer, uint32 BufferSize, uint32* InputSize) InputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* Buffer) ReturnInputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Mask, char16* Format) OutputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Mask, char16* Format, ref int8 Args) OutputVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, uint32 Mask, char16* Format) ControlledOutputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, uint32 Mask, char16* Format, ref int8 Args) ControlledOutputVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, char16* Format) OutputPromptWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, char16* Format, ref int8 Args) OutputPromptVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptTextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Offset, char16* Instr, out uint64 EndOffset) AssembleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Offset, uint32 Flags, char16* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) DisassembleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Type, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNamesWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Slot, char16* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacroWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Slot, char16* Macro) SetTextMacroWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) EvaluateWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, char16* Command, uint32 Flags) ExecuteWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, char16* CommandFile, uint32 Flags) ExecuteCommandFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, out IDebugBreakpoint2* Bp) GetBreakpointByIndex2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Id, out IDebugBreakpoint2* Bp) GetBreakpointById2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint2* Bp) AddBreakpoint2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, ref IDebugBreakpoint2 Bp) RemoveBreakpoint2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* Path, uint32 Flags, out uint64 Handle) AddExtensionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* Path, out uint64 Handle) GetExtensionByPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Handle, char16* Function, char16* Arguments) CallExtensionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 Handle, char16* FuncName, out FARPROC Function) GetExtensionFunctionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterTextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char16* Command) SetEventFilterCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgumentWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char16* Argument) SetSpecificFilterArgumentWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char16* Command) SetExceptionFilterSecondCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, char16* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* SrcText, uint32 Index, char16* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, char16* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* SrcText, char16* DstText) SetTextReplacementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* AbbrevName) SetExpressionSyntaxByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetExpressionSyntaxNamesWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Index, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* DescSize) GetEventIndexDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) GetLogFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char8* File, uint32 Flags) OpenLogFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) GetLogFile2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, char16* File, uint32 Flags) OpenLogFile2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 PlatformId, out uint32 Win32Major, out uint32 Win32Minor, uint32* KdMajor, uint32* KdMinor) GetSystemVersionValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSystemVersionString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSystemVersionStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) GetContextStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) OutputContextStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* Context, uint32 ContextSize, uint32* ContextUsed, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed) GetStoredEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32* Flags, uint32 WhichString, uint8* String, uint32 StringSize, uint32* StringNeeded) GetManagedStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32* Flags, uint32 WhichString, char16* String, uint32 StringSize, uint32* StringNeeded) GetManagedStatusWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 Flags) ResetManagedStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32 Flags) OutputStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) GetContextStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) OutputContextStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, ref Guid Guid, out IDebugBreakpoint3* Bp) GetBreakpointByGuid;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 Status) GetExecutionStatusEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl6 self, out uint32 SendsAttempted, out uint32 SecondsSinceLastResponse) GetSynchronizationStatus;
			}
		}
		[CRepr]
		public struct IDebugControl7 : IUnknown
		{
			public const new Guid IID = .(0xb86fb3b1, 0x80d4, 0x475b, 0xae, 0xa3, 0xcf, 0x06, 0x53, 0x9c, 0xf6, 0x3a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterrupt() mut => VT.GetInterrupt(ref this);
			public HResult SetInterrupt(uint32 Flags) mut => VT.SetInterrupt(ref this, Flags);
			public HResult GetInterruptTimeout(out uint32 Seconds) mut => VT.GetInterruptTimeout(ref this, out Seconds);
			public HResult SetInterruptTimeout(uint32 Seconds) mut => VT.SetInterruptTimeout(ref this, Seconds);
			public HResult GetLogFile(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFile(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFile(char8* File, IntBool Append) mut => VT.OpenLogFile(ref this, File, Append);
			public HResult CloseLogFile() mut => VT.CloseLogFile(ref this);
			public HResult GetLogMask(out uint32 Mask) mut => VT.GetLogMask(ref this, out Mask);
			public HResult SetLogMask(uint32 Mask) mut => VT.SetLogMask(ref this, Mask);
			public HResult Input(uint8* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.Input(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInput(char8* Buffer) mut => VT.ReturnInput(ref this, Buffer);
			public HResult Output(uint32 Mask, char8* Format) mut => VT.Output(ref this, Mask, Format);
			public HResult OutputVaList(uint32 Mask, char8* Format, ref int8 Args) mut => VT.OutputVaList(ref this, Mask, Format, ref Args);
			public HResult ControlledOutput(uint32 OutputControl, uint32 Mask, char8* Format) mut => VT.ControlledOutput(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaList(uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) mut => VT.ControlledOutputVaList(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPrompt(uint32 OutputControl, char8* Format) mut => VT.OutputPrompt(ref this, OutputControl, Format);
			public HResult OutputPromptVaList(uint32 OutputControl, char8* Format, ref int8 Args) mut => VT.OutputPromptVaList(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptText(uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptText(ref this, Buffer, BufferSize, TextSize);
			public HResult OutputCurrentState(uint32 OutputControl, uint32 Flags) mut => VT.OutputCurrentState(ref this, OutputControl, Flags);
			public HResult OutputVersionInformation(uint32 OutputControl) mut => VT.OutputVersionInformation(ref this, OutputControl);
			public HResult GetNotifyEventHandle(out uint64 Handle) mut => VT.GetNotifyEventHandle(ref this, out Handle);
			public HResult SetNotifyEventHandle(uint64 Handle) mut => VT.SetNotifyEventHandle(ref this, Handle);
			public HResult Assemble(uint64 Offset, char8* Instr, out uint64 EndOffset) mut => VT.Assemble(ref this, Offset, Instr, out EndOffset);
			public HResult Disassemble(uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.Disassemble(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetDisassembleEffectiveOffset(out uint64 Offset) mut => VT.GetDisassembleEffectiveOffset(ref this, out Offset);
			public HResult OutputDisassembly(uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) mut => VT.OutputDisassembly(ref this, OutputControl, Offset, Flags, out EndOffset);
			public HResult OutputDisassemblyLines(uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) mut => VT.OutputDisassemblyLines(ref this, OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
			public HResult GetNearInstruction(uint64 Offset, int32 Delta, out uint64 NearOffset) mut => VT.GetNearInstruction(ref this, Offset, Delta, out NearOffset);
			public HResult GetStackTrace(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTrace(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult GetReturnOffset(out uint64 Offset) mut => VT.GetReturnOffset(ref this, out Offset);
			public HResult OutputStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTrace(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetDebuggeeType(out uint32 Class, out uint32 Qualifier) mut => VT.GetDebuggeeType(ref this, out Class, out Qualifier);
			public HResult GetActualProcessorType(out uint32 Type) mut => VT.GetActualProcessorType(ref this, out Type);
			public HResult GetExecutingProcessorType(out uint32 Type) mut => VT.GetExecutingProcessorType(ref this, out Type);
			public HResult GetNumberPossibleExecutingProcessorTypes(out uint32 Number) mut => VT.GetNumberPossibleExecutingProcessorTypes(ref this, out Number);
			public HResult GetPossibleExecutingProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetPossibleExecutingProcessorTypes(ref this, Start, Count, Types);
			public HResult GetNumberProcessors(out uint32 Number) mut => VT.GetNumberProcessors(ref this, out Number);
			public HResult GetSystemVersion(out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) mut => VT.GetSystemVersion(ref this, out PlatformId, out Major, out Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, out ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
			public HResult GetPageSize(out uint32 Size) mut => VT.GetPageSize(ref this, out Size);
			public HResult IsPointer64Bit() mut => VT.IsPointer64Bit(ref this);
			public HResult ReadBugCheckData(out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) mut => VT.ReadBugCheckData(ref this, out Code, out Arg1, out Arg2, out Arg3, out Arg4);
			public HResult GetNumberSupportedProcessorTypes(out uint32 Number) mut => VT.GetNumberSupportedProcessorTypes(ref this, out Number);
			public HResult GetSupportedProcessorTypes(uint32 Start, uint32 Count, uint32* Types) mut => VT.GetSupportedProcessorTypes(ref this, Start, Count, Types);
			public HResult GetProcessorTypeNames(uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNames(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEffectiveProcessorType(out uint32 Type) mut => VT.GetEffectiveProcessorType(ref this, out Type);
			public HResult SetEffectiveProcessorType(uint32 Type) mut => VT.SetEffectiveProcessorType(ref this, Type);
			public HResult GetExecutionStatus(out uint32 Status) mut => VT.GetExecutionStatus(ref this, out Status);
			public HResult SetExecutionStatus(uint32 Status) mut => VT.SetExecutionStatus(ref this, Status);
			public HResult GetCodeLevel(out uint32 Level) mut => VT.GetCodeLevel(ref this, out Level);
			public HResult SetCodeLevel(uint32 Level) mut => VT.SetCodeLevel(ref this, Level);
			public HResult GetEngineOptions(out uint32 Options) mut => VT.GetEngineOptions(ref this, out Options);
			public HResult AddEngineOptions(uint32 Options) mut => VT.AddEngineOptions(ref this, Options);
			public HResult RemoveEngineOptions(uint32 Options) mut => VT.RemoveEngineOptions(ref this, Options);
			public HResult SetEngineOptions(uint32 Options) mut => VT.SetEngineOptions(ref this, Options);
			public HResult GetSystemErrorControl(out uint32 OutputLevel, out uint32 BreakLevel) mut => VT.GetSystemErrorControl(ref this, out OutputLevel, out BreakLevel);
			public HResult SetSystemErrorControl(uint32 OutputLevel, uint32 BreakLevel) mut => VT.SetSystemErrorControl(ref this, OutputLevel, BreakLevel);
			public HResult GetTextMacro(uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacro(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacro(uint32 Slot, char8* Macro) mut => VT.SetTextMacro(ref this, Slot, Macro);
			public HResult GetRadix(out uint32 Radix) mut => VT.GetRadix(ref this, out Radix);
			public HResult SetRadix(uint32 Radix) mut => VT.SetRadix(ref this, Radix);
			public HResult Evaluate(char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.Evaluate(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult CoerceValue(ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) mut => VT.CoerceValue(ref this, ref In, OutType, out Out);
			public HResult CoerceValues(uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) mut => VT.CoerceValues(ref this, Count, In, OutTypes, Out);
			public HResult Execute(uint32 OutputControl, char8* Command, uint32 Flags) mut => VT.Execute(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFile(uint32 OutputControl, char8* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFile(ref this, OutputControl, CommandFile, Flags);
			public HResult GetNumberBreakpoints(out uint32 Number) mut => VT.GetNumberBreakpoints(ref this, out Number);
			public HResult GetBreakpointByIndex(uint32 Index, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointByIndex(ref this, Index, out Bp);
			public HResult GetBreakpointById(uint32 Id, out IDebugBreakpoint* Bp) mut => VT.GetBreakpointById(ref this, Id, out Bp);
			public HResult GetBreakpointParameters(uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) mut => VT.GetBreakpointParameters(ref this, Count, Ids, Start, Params);
			public HResult AddBreakpoint(uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) mut => VT.AddBreakpoint(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint(ref IDebugBreakpoint Bp) mut => VT.RemoveBreakpoint(ref this, ref Bp);
			public HResult AddExtension(char8* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtension(ref this, Path, Flags, out Handle);
			public HResult RemoveExtension(uint64 Handle) mut => VT.RemoveExtension(ref this, Handle);
			public HResult GetExtensionByPath(char8* Path, out uint64 Handle) mut => VT.GetExtensionByPath(ref this, Path, out Handle);
			public HResult CallExtension(uint64 Handle, char8* Function, char8* Arguments) mut => VT.CallExtension(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunction(uint64 Handle, char8* FuncName, out FARPROC Function) mut => VT.GetExtensionFunction(ref this, Handle, FuncName, out Function);
			public HResult GetWindbgExtensionApis32(out WINDBG_EXTENSION_APIS32 Api) mut => VT.GetWindbgExtensionApis32(ref this, out Api);
			public HResult GetWindbgExtensionApis64(out WINDBG_EXTENSION_APIS64 Api) mut => VT.GetWindbgExtensionApis64(ref this, out Api);
			public HResult GetNumberEventFilters(out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) mut => VT.GetNumberEventFilters(ref this, out SpecificEvents, out SpecificExceptions, out ArbitraryExceptions);
			public HResult GetEventFilterText(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterText(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommand(uint32 Index, char8* Command) mut => VT.SetEventFilterCommand(ref this, Index, Command);
			public HResult GetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.GetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult SetSpecificFilterParameters(uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) mut => VT.SetSpecificFilterParameters(ref this, Start, Count, Params);
			public HResult GetSpecificFilterArgument(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgument(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgument(uint32 Index, char8* Argument) mut => VT.SetSpecificFilterArgument(ref this, Index, Argument);
			public HResult GetExceptionFilterParameters(uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.GetExceptionFilterParameters(ref this, Count, Codes, Start, Params);
			public HResult SetExceptionFilterParameters(uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) mut => VT.SetExceptionFilterParameters(ref this, Count, Params);
			public HResult GetExceptionFilterSecondCommand(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommand(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommand(uint32 Index, char8* Command) mut => VT.SetExceptionFilterSecondCommand(ref this, Index, Command);
			public HResult WaitForEvent(uint32 Flags, uint32 Timeout) mut => VT.WaitForEvent(ref this, Flags, Timeout);
			public HResult GetLastEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformation(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetCurrentTimeDate(out uint32 TimeDate) mut => VT.GetCurrentTimeDate(ref this, out TimeDate);
			public HResult GetCurrentSystemUpTime(out uint32 UpTime) mut => VT.GetCurrentSystemUpTime(ref this, out UpTime);
			public HResult GetDumpFormatFlags(out uint32 FormatFlags) mut => VT.GetDumpFormatFlags(ref this, out FormatFlags);
			public HResult GetNumberTextReplacements(out uint32 NumRepl) mut => VT.GetNumberTextReplacements(ref this, out NumRepl);
			public HResult GetTextReplacement(char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacement(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacement(char8* SrcText, char8* DstText) mut => VT.SetTextReplacement(ref this, SrcText, DstText);
			public HResult RemoveTextReplacements() mut => VT.RemoveTextReplacements(ref this);
			public HResult OutputTextReplacements(uint32 OutputControl, uint32 Flags) mut => VT.OutputTextReplacements(ref this, OutputControl, Flags);
			public HResult GetAssemblyOptions(out uint32 Options) mut => VT.GetAssemblyOptions(ref this, out Options);
			public HResult AddAssemblyOptions(uint32 Options) mut => VT.AddAssemblyOptions(ref this, Options);
			public HResult RemoveAssemblyOptions(uint32 Options) mut => VT.RemoveAssemblyOptions(ref this, Options);
			public HResult SetAssemblyOptions(uint32 Options) mut => VT.SetAssemblyOptions(ref this, Options);
			public HResult GetExpressionSyntax(out uint32 Flags) mut => VT.GetExpressionSyntax(ref this, out Flags);
			public HResult SetExpressionSyntax(uint32 Flags) mut => VT.SetExpressionSyntax(ref this, Flags);
			public HResult SetExpressionSyntaxByName(char8* AbbrevName) mut => VT.SetExpressionSyntaxByName(ref this, AbbrevName);
			public HResult GetNumberExpressionSyntaxes(out uint32 Number) mut => VT.GetNumberExpressionSyntaxes(ref this, out Number);
			public HResult GetExpressionSyntaxNames(uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetExpressionSyntaxNames(ref this, Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetNumberEvents(out uint32 Events) mut => VT.GetNumberEvents(ref this, out Events);
			public HResult GetEventIndexDescription(uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) mut => VT.GetEventIndexDescription(ref this, Index, Which, Buffer, BufferSize, DescSize);
			public HResult GetCurrentEventIndex(out uint32 Index) mut => VT.GetCurrentEventIndex(ref this, out Index);
			public HResult SetNextEventIndex(uint32 Relation, uint32 Value, out uint32 NextIndex) mut => VT.SetNextEventIndex(ref this, Relation, Value, out NextIndex);
			public HResult GetLogFileWide(char16* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) mut => VT.GetLogFileWide(ref this, Buffer, BufferSize, FileSize, out Append);
			public HResult OpenLogFileWide(char16* File, IntBool Append) mut => VT.OpenLogFileWide(ref this, File, Append);
			public HResult InputWide(char16* Buffer, uint32 BufferSize, uint32* InputSize) mut => VT.InputWide(ref this, Buffer, BufferSize, InputSize);
			public HResult ReturnInputWide(char16* Buffer) mut => VT.ReturnInputWide(ref this, Buffer);
			public HResult OutputWide(uint32 Mask, char16* Format) mut => VT.OutputWide(ref this, Mask, Format);
			public HResult OutputVaListWide(uint32 Mask, char16* Format, ref int8 Args) mut => VT.OutputVaListWide(ref this, Mask, Format, ref Args);
			public HResult ControlledOutputWide(uint32 OutputControl, uint32 Mask, char16* Format) mut => VT.ControlledOutputWide(ref this, OutputControl, Mask, Format);
			public HResult ControlledOutputVaListWide(uint32 OutputControl, uint32 Mask, char16* Format, ref int8 Args) mut => VT.ControlledOutputVaListWide(ref this, OutputControl, Mask, Format, ref Args);
			public HResult OutputPromptWide(uint32 OutputControl, char16* Format) mut => VT.OutputPromptWide(ref this, OutputControl, Format);
			public HResult OutputPromptVaListWide(uint32 OutputControl, char16* Format, ref int8 Args) mut => VT.OutputPromptVaListWide(ref this, OutputControl, Format, ref Args);
			public HResult GetPromptTextWide(char16* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetPromptTextWide(ref this, Buffer, BufferSize, TextSize);
			public HResult AssembleWide(uint64 Offset, char16* Instr, out uint64 EndOffset) mut => VT.AssembleWide(ref this, Offset, Instr, out EndOffset);
			public HResult DisassembleWide(uint64 Offset, uint32 Flags, char16* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) mut => VT.DisassembleWide(ref this, Offset, Flags, Buffer, BufferSize, DisassemblySize, out EndOffset);
			public HResult GetProcessorTypeNamesWide(uint32 Type, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetProcessorTypeNamesWide(ref this, Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetTextMacroWide(uint32 Slot, char16* Buffer, uint32 BufferSize, uint32* MacroSize) mut => VT.GetTextMacroWide(ref this, Slot, Buffer, BufferSize, MacroSize);
			public HResult SetTextMacroWide(uint32 Slot, char16* Macro) mut => VT.SetTextMacroWide(ref this, Slot, Macro);
			public HResult EvaluateWide(char16* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) mut => VT.EvaluateWide(ref this, Expression, DesiredType, out Value, RemainderIndex);
			public HResult ExecuteWide(uint32 OutputControl, char16* Command, uint32 Flags) mut => VT.ExecuteWide(ref this, OutputControl, Command, Flags);
			public HResult ExecuteCommandFileWide(uint32 OutputControl, char16* CommandFile, uint32 Flags) mut => VT.ExecuteCommandFileWide(ref this, OutputControl, CommandFile, Flags);
			public HResult GetBreakpointByIndex2(uint32 Index, out IDebugBreakpoint2* Bp) mut => VT.GetBreakpointByIndex2(ref this, Index, out Bp);
			public HResult GetBreakpointById2(uint32 Id, out IDebugBreakpoint2* Bp) mut => VT.GetBreakpointById2(ref this, Id, out Bp);
			public HResult AddBreakpoint2(uint32 Type, uint32 DesiredId, out IDebugBreakpoint2* Bp) mut => VT.AddBreakpoint2(ref this, Type, DesiredId, out Bp);
			public HResult RemoveBreakpoint2(ref IDebugBreakpoint2 Bp) mut => VT.RemoveBreakpoint2(ref this, ref Bp);
			public HResult AddExtensionWide(char16* Path, uint32 Flags, out uint64 Handle) mut => VT.AddExtensionWide(ref this, Path, Flags, out Handle);
			public HResult GetExtensionByPathWide(char16* Path, out uint64 Handle) mut => VT.GetExtensionByPathWide(ref this, Path, out Handle);
			public HResult CallExtensionWide(uint64 Handle, char16* Function, char16* Arguments) mut => VT.CallExtensionWide(ref this, Handle, Function, Arguments);
			public HResult GetExtensionFunctionWide(uint64 Handle, char16* FuncName, out FARPROC Function) mut => VT.GetExtensionFunctionWide(ref this, Handle, FuncName, out Function);
			public HResult GetEventFilterTextWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* TextSize) mut => VT.GetEventFilterTextWide(ref this, Index, Buffer, BufferSize, TextSize);
			public HResult GetEventFilterCommandWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetEventFilterCommandWide(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetEventFilterCommandWide(uint32 Index, char16* Command) mut => VT.SetEventFilterCommandWide(ref this, Index, Command);
			public HResult GetSpecificFilterArgumentWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ArgumentSize) mut => VT.GetSpecificFilterArgumentWide(ref this, Index, Buffer, BufferSize, ArgumentSize);
			public HResult SetSpecificFilterArgumentWide(uint32 Index, char16* Argument) mut => VT.SetSpecificFilterArgumentWide(ref this, Index, Argument);
			public HResult GetExceptionFilterSecondCommandWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) mut => VT.GetExceptionFilterSecondCommandWide(ref this, Index, Buffer, BufferSize, CommandSize);
			public HResult SetExceptionFilterSecondCommandWide(uint32 Index, char16* Command) mut => VT.SetExceptionFilterSecondCommandWide(ref this, Index, Command);
			public HResult GetLastEventInformationWide(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, char16* Description, uint32 DescriptionSize, uint32* DescriptionUsed) mut => VT.GetLastEventInformationWide(ref this, out Type, out ProcessId, out ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
			public HResult GetTextReplacementWide(char16* SrcText, uint32 Index, char16* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, char16* DstBuffer, uint32 DstBufferSize, uint32* DstSize) mut => VT.GetTextReplacementWide(ref this, SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
			public HResult SetTextReplacementWide(char16* SrcText, char16* DstText) mut => VT.SetTextReplacementWide(ref this, SrcText, DstText);
			public HResult SetExpressionSyntaxByNameWide(char16* AbbrevName) mut => VT.SetExpressionSyntaxByNameWide(ref this, AbbrevName);
			public HResult GetExpressionSyntaxNamesWide(uint32 Index, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) mut => VT.GetExpressionSyntaxNamesWide(ref this, Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
			public HResult GetEventIndexDescriptionWide(uint32 Index, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* DescSize) mut => VT.GetEventIndexDescriptionWide(ref this, Index, Which, Buffer, BufferSize, DescSize);
			public HResult GetLogFile2(uint8* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) mut => VT.GetLogFile2(ref this, Buffer, BufferSize, FileSize, out Flags);
			public HResult OpenLogFile2(char8* File, uint32 Flags) mut => VT.OpenLogFile2(ref this, File, Flags);
			public HResult GetLogFile2Wide(char16* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) mut => VT.GetLogFile2Wide(ref this, Buffer, BufferSize, FileSize, out Flags);
			public HResult OpenLogFile2Wide(char16* File, uint32 Flags) mut => VT.OpenLogFile2Wide(ref this, File, Flags);
			public HResult GetSystemVersionValues(out uint32 PlatformId, out uint32 Win32Major, out uint32 Win32Minor, uint32* KdMajor, uint32* KdMinor) mut => VT.GetSystemVersionValues(ref this, out PlatformId, out Win32Major, out Win32Minor, KdMajor, KdMinor);
			public HResult GetSystemVersionString(uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSystemVersionString(ref this, Which, Buffer, BufferSize, StringSize);
			public HResult GetSystemVersionStringWide(uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSystemVersionStringWide(ref this, Which, Buffer, BufferSize, StringSize);
			public HResult GetContextStackTrace(void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) mut => VT.GetContextStackTrace(ref this, StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
			public HResult OutputContextStackTrace(uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) mut => VT.OutputContextStackTrace(ref this, OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
			public HResult GetStoredEventInformation(out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* Context, uint32 ContextSize, uint32* ContextUsed, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed) mut => VT.GetStoredEventInformation(ref this, out Type, out ProcessId, out ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
			public HResult GetManagedStatus(uint32* Flags, uint32 WhichString, uint8* String, uint32 StringSize, uint32* StringNeeded) mut => VT.GetManagedStatus(ref this, Flags, WhichString, String, StringSize, StringNeeded);
			public HResult GetManagedStatusWide(uint32* Flags, uint32 WhichString, char16* String, uint32 StringSize, uint32* StringNeeded) mut => VT.GetManagedStatusWide(ref this, Flags, WhichString, String, StringSize, StringNeeded);
			public HResult ResetManagedStatus(uint32 Flags) mut => VT.ResetManagedStatus(ref this, Flags);
			public HResult GetStackTraceEx(uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32* FramesFilled) mut => VT.GetStackTraceEx(ref this, FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
			public HResult OutputStackTraceEx(uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32 Flags) mut => VT.OutputStackTraceEx(ref this, OutputControl, Frames, FramesSize, Flags);
			public HResult GetContextStackTraceEx(void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) mut => VT.GetContextStackTraceEx(ref this, StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
			public HResult OutputContextStackTraceEx(uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) mut => VT.OutputContextStackTraceEx(ref this, OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
			public HResult GetBreakpointByGuid(ref Guid Guid, out IDebugBreakpoint3* Bp) mut => VT.GetBreakpointByGuid(ref this, ref Guid, out Bp);
			public HResult GetExecutionStatusEx(out uint32 Status) mut => VT.GetExecutionStatusEx(ref this, out Status);
			public HResult GetSynchronizationStatus(out uint32 SendsAttempted, out uint32 SecondsSinceLastResponse) mut => VT.GetSynchronizationStatus(ref this, out SendsAttempted, out SecondsSinceLastResponse);
			public HResult GetDebuggeeType2(uint32 Flags, out uint32 Class, out uint32 Qualifier) mut => VT.GetDebuggeeType2(ref this, Flags, out Class, out Qualifier);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self) GetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Flags) SetInterrupt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Seconds) GetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Seconds) SetInterruptTimeout;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char8* File, IntBool Append) OpenLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self) CloseLogFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Mask) GetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Mask) SetLogMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint8* Buffer, uint32 BufferSize, uint32* InputSize) Input;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char8* Buffer) ReturnInput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Mask, char8* Format) Output;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Mask, char8* Format, ref int8 Args) OutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, uint32 Mask, char8* Format) ControlledOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, uint32 Mask, char8* Format, ref int8 Args) ControlledOutputVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, char8* Format) OutputPrompt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, char8* Format, ref int8 Args) OutputPromptVaList;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, uint32 Flags) OutputCurrentState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl) OutputVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint64 Handle) GetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Handle) SetNotifyEventHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Offset, char8* Instr, out uint64 EndOffset) Assemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Offset, uint32 Flags, uint8* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) Disassemble;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint64 Offset) GetDisassembleEffectiveOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, uint64 Offset, uint32 Flags, out uint64 EndOffset) OutputDisassembly;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, uint32 PreviousLines, uint32 TotalLines, uint64 Offset, uint32 Flags, uint32* OffsetLine, uint64* StartOffset, uint64* EndOffset, uint64* LineOffsets) OutputDisassemblyLines;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Offset, int32 Delta, out uint64 NearOffset) GetNearInstruction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint64 Offset) GetReturnOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, uint32 Flags) OutputStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Class, out uint32 Qualifier) GetDebuggeeType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Type) GetActualProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Type) GetExecutingProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Number) GetNumberPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Start, uint32 Count, uint32* Types) GetPossibleExecutingProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Number) GetNumberProcessors;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 PlatformId, out uint32 Major, out uint32 Minor, uint8* ServicePackString, uint32 ServicePackStringSize, uint32* ServicePackStringUsed, out uint32 ServicePackNumber, uint8* BuildString, uint32 BuildStringSize, uint32* BuildStringUsed) GetSystemVersion;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Size) GetPageSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self) IsPointer64Bit;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Code, out uint64 Arg1, out uint64 Arg2, out uint64 Arg3, out uint64 Arg4) ReadBugCheckData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Number) GetNumberSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Start, uint32 Count, uint32* Types) GetSupportedProcessorTypes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Type, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Type) GetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Type) SetEffectiveProcessorType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Status) GetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Status) SetExecutionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Level) GetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Level) SetCodeLevel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Options) GetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Options) AddEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Options) RemoveEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Options) SetEngineOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 OutputLevel, out uint32 BreakLevel) GetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputLevel, uint32 BreakLevel) SetSystemErrorControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Slot, uint8* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Slot, char8* Macro) SetTextMacro;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Radix) GetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Radix) SetRadix;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char8* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) Evaluate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, ref DEBUG_VALUE In, uint32 OutType, out DEBUG_VALUE Out) CoerceValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Count, DEBUG_VALUE* In, uint32* OutTypes, DEBUG_VALUE* Out) CoerceValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, char8* Command, uint32 Flags) Execute;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, char8* CommandFile, uint32 Flags) ExecuteCommandFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Number) GetNumberBreakpoints;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, out IDebugBreakpoint* Bp) GetBreakpointByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Id, out IDebugBreakpoint* Bp) GetBreakpointById;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Count, uint32* Ids, uint32 Start, DEBUG_BREAKPOINT_PARAMETERS* Params) GetBreakpointParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint* Bp) AddBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, ref IDebugBreakpoint Bp) RemoveBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char8* Path, uint32 Flags, out uint64 Handle) AddExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Handle) RemoveExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char8* Path, out uint64 Handle) GetExtensionByPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Handle, char8* Function, char8* Arguments) CallExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Handle, char8* FuncName, out FARPROC Function) GetExtensionFunction;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out WINDBG_EXTENSION_APIS32 Api) GetWindbgExtensionApis32;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out WINDBG_EXTENSION_APIS64 Api) GetWindbgExtensionApis64;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 SpecificEvents, out uint32 SpecificExceptions, out uint32 ArbitraryExceptions) GetNumberEventFilters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char8* Command) SetEventFilterCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) GetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Start, uint32 Count, DEBUG_SPECIFIC_FILTER_PARAMETERS* Params) SetSpecificFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char8* Argument) SetSpecificFilterArgument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Count, uint32* Codes, uint32 Start, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) GetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Count, DEBUG_EXCEPTION_FILTER_PARAMETERS* Params) SetExceptionFilterParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char8* Command) SetExceptionFilterSecondCommand;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Flags, uint32 Timeout) WaitForEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, uint8* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 TimeDate) GetCurrentTimeDate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 UpTime) GetCurrentSystemUpTime;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 FormatFlags) GetDumpFormatFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 NumRepl) GetNumberTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char8* SrcText, uint32 Index, uint8* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, uint8* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char8* SrcText, char8* DstText) SetTextReplacement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self) RemoveTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, uint32 Flags) OutputTextReplacements;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Options) GetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Options) AddAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Options) RemoveAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Options) SetAssemblyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Flags) GetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Flags) SetExpressionSyntax;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char8* AbbrevName) SetExpressionSyntaxByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Number) GetNumberExpressionSyntaxes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, uint8* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, uint8* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetExpressionSyntaxNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Events) GetNumberEvents;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, uint32 Which, char8* Buffer, uint32 BufferSize, uint32* DescSize) GetEventIndexDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Index) GetCurrentEventIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Relation, uint32 Value, out uint32 NextIndex) SetNextEventIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* Buffer, uint32 BufferSize, uint32* FileSize, out IntBool Append) GetLogFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* File, IntBool Append) OpenLogFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* Buffer, uint32 BufferSize, uint32* InputSize) InputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* Buffer) ReturnInputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Mask, char16* Format) OutputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Mask, char16* Format, ref int8 Args) OutputVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, uint32 Mask, char16* Format) ControlledOutputWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, uint32 Mask, char16* Format, ref int8 Args) ControlledOutputVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, char16* Format) OutputPromptWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, char16* Format, ref int8 Args) OutputPromptVaListWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* Buffer, uint32 BufferSize, uint32* TextSize) GetPromptTextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Offset, char16* Instr, out uint64 EndOffset) AssembleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Offset, uint32 Flags, char16* Buffer, uint32 BufferSize, uint32* DisassemblySize, out uint64 EndOffset) DisassembleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Type, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetProcessorTypeNamesWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Slot, char16* Buffer, uint32 BufferSize, uint32* MacroSize) GetTextMacroWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Slot, char16* Macro) SetTextMacroWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* Expression, uint32 DesiredType, out DEBUG_VALUE Value, uint32* RemainderIndex) EvaluateWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, char16* Command, uint32 Flags) ExecuteWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, char16* CommandFile, uint32 Flags) ExecuteCommandFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, out IDebugBreakpoint2* Bp) GetBreakpointByIndex2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Id, out IDebugBreakpoint2* Bp) GetBreakpointById2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Type, uint32 DesiredId, out IDebugBreakpoint2* Bp) AddBreakpoint2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, ref IDebugBreakpoint2 Bp) RemoveBreakpoint2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* Path, uint32 Flags, out uint64 Handle) AddExtensionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* Path, out uint64 Handle) GetExtensionByPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Handle, char16* Function, char16* Arguments) CallExtensionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 Handle, char16* FuncName, out FARPROC Function) GetExtensionFunctionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* TextSize) GetEventFilterTextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetEventFilterCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char16* Command) SetEventFilterCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ArgumentSize) GetSpecificFilterArgumentWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char16* Argument) SetSpecificFilterArgumentWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* CommandSize) GetExceptionFilterSecondCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char16* Command) SetExceptionFilterSecondCommandWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed, char16* Description, uint32 DescriptionSize, uint32* DescriptionUsed) GetLastEventInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* SrcText, uint32 Index, char16* SrcBuffer, uint32 SrcBufferSize, uint32* SrcSize, char16* DstBuffer, uint32 DstBufferSize, uint32* DstSize) GetTextReplacementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* SrcText, char16* DstText) SetTextReplacementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* AbbrevName) SetExpressionSyntaxByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, char16* FullNameBuffer, uint32 FullNameBufferSize, uint32* FullNameSize, char16* AbbrevNameBuffer, uint32 AbbrevNameBufferSize, uint32* AbbrevNameSize) GetExpressionSyntaxNamesWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Index, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* DescSize) GetEventIndexDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint8* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) GetLogFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char8* File, uint32 Flags) OpenLogFile2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* Buffer, uint32 BufferSize, uint32* FileSize, out uint32 Flags) GetLogFile2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, char16* File, uint32 Flags) OpenLogFile2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 PlatformId, out uint32 Win32Major, out uint32 Win32Minor, uint32* KdMajor, uint32* KdMinor) GetSystemVersionValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSystemVersionString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSystemVersionStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) GetContextStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, DEBUG_STACK_FRAME* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) OutputContextStackTrace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Type, out uint32 ProcessId, out uint32 ThreadId, void* Context, uint32 ContextSize, uint32* ContextUsed, void* ExtraInformation, uint32 ExtraInformationSize, uint32* ExtraInformationUsed) GetStoredEventInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32* Flags, uint32 WhichString, uint8* String, uint32 StringSize, uint32* StringNeeded) GetManagedStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32* Flags, uint32 WhichString, char16* String, uint32 StringSize, uint32* StringNeeded) GetManagedStatusWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Flags) ResetManagedStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint64 FrameOffset, uint64 StackOffset, uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32* FramesFilled) GetStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, uint32 Flags) OutputStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, void* StartContext, uint32 StartContextSize, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32* FramesFilled) GetContextStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 OutputControl, DEBUG_STACK_FRAME_EX* Frames, uint32 FramesSize, void* FrameContexts, uint32 FrameContextsSize, uint32 FrameContextsEntrySize, uint32 Flags) OutputContextStackTraceEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, ref Guid Guid, out IDebugBreakpoint3* Bp) GetBreakpointByGuid;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 Status) GetExecutionStatusEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, out uint32 SendsAttempted, out uint32 SecondsSinceLastResponse) GetSynchronizationStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugControl7 self, uint32 Flags, out uint32 Class, out uint32 Qualifier) GetDebuggeeType2;
			}
		}
		[CRepr]
		public struct IDebugDataSpaces : IUnknown
		{
			public const new Guid IID = .(0x88f7dfab, 0x3ea7, 0x4c3a, 0xae, 0xfb, 0xc4, 0xe8, 0x10, 0x61, 0x73, 0xaa);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ReadVirtual(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadVirtual(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteVirtual(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteVirtual(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult SearchVirtual(uint64 Offset, uint64 Length, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) mut => VT.SearchVirtual(ref this, Offset, Length, Pattern, PatternSize, PatternGranularity, out MatchOffset);
			public HResult ReadVirtualUncached(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadVirtualUncached(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteVirtualUncached(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteVirtualUncached(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadPointersVirtual(uint32 Count, uint64 Offset, uint64* Ptrs) mut => VT.ReadPointersVirtual(ref this, Count, Offset, Ptrs);
			public HResult WritePointersVirtual(uint32 Count, uint64 Offset, uint64* Ptrs) mut => VT.WritePointersVirtual(ref this, Count, Offset, Ptrs);
			public HResult ReadPhysical(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadPhysical(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WritePhysical(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WritePhysical(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadControl(uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadControl(ref this, Processor, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteControl(uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteControl(ref this, Processor, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadIo(uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadIo(ref this, InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteIo(uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteIo(ref this, InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadMsr(uint32 Msr, out uint64 Value) mut => VT.ReadMsr(ref this, Msr, out Value);
			public HResult WriteMsr(uint32 Msr, uint64 Value) mut => VT.WriteMsr(ref this, Msr, Value);
			public HResult ReadBusData(uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadBusData(ref this, BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteBusData(uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteBusData(ref this, BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
			public HResult CheckLowMemory() mut => VT.CheckLowMemory(ref this);
			public HResult ReadDebuggerData(uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadDebuggerData(ref this, Index, Buffer, BufferSize, DataSize);
			public HResult ReadProcessorSystemData(uint32 Processor, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadProcessorSystemData(ref this, Processor, Index, Buffer, BufferSize, DataSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint64 Offset, uint64 Length, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) SearchVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadVirtualUncached;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteVirtualUncached;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 Count, uint64 Offset, uint64* Ptrs) ReadPointersVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 Count, uint64 Offset, uint64* Ptrs) WritePointersVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WritePhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadIo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteIo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 Msr, out uint64 Value) ReadMsr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 Msr, uint64 Value) WriteMsr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadBusData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteBusData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self) CheckLowMemory;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadDebuggerData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces self, uint32 Processor, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadProcessorSystemData;
			}
		}
		[CRepr]
		public struct IDebugDataSpaces2 : IUnknown
		{
			public const new Guid IID = .(0x7a5e852f, 0x96e9, 0x468f, 0xac, 0x1b, 0x0b, 0x3a, 0xdd, 0xc4, 0xa0, 0x49);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ReadVirtual(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadVirtual(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteVirtual(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteVirtual(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult SearchVirtual(uint64 Offset, uint64 Length, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) mut => VT.SearchVirtual(ref this, Offset, Length, Pattern, PatternSize, PatternGranularity, out MatchOffset);
			public HResult ReadVirtualUncached(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadVirtualUncached(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteVirtualUncached(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteVirtualUncached(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadPointersVirtual(uint32 Count, uint64 Offset, uint64* Ptrs) mut => VT.ReadPointersVirtual(ref this, Count, Offset, Ptrs);
			public HResult WritePointersVirtual(uint32 Count, uint64 Offset, uint64* Ptrs) mut => VT.WritePointersVirtual(ref this, Count, Offset, Ptrs);
			public HResult ReadPhysical(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadPhysical(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WritePhysical(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WritePhysical(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadControl(uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadControl(ref this, Processor, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteControl(uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteControl(ref this, Processor, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadIo(uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadIo(ref this, InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteIo(uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteIo(ref this, InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadMsr(uint32 Msr, out uint64 Value) mut => VT.ReadMsr(ref this, Msr, out Value);
			public HResult WriteMsr(uint32 Msr, uint64 Value) mut => VT.WriteMsr(ref this, Msr, Value);
			public HResult ReadBusData(uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadBusData(ref this, BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteBusData(uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteBusData(ref this, BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
			public HResult CheckLowMemory() mut => VT.CheckLowMemory(ref this);
			public HResult ReadDebuggerData(uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadDebuggerData(ref this, Index, Buffer, BufferSize, DataSize);
			public HResult ReadProcessorSystemData(uint32 Processor, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadProcessorSystemData(ref this, Processor, Index, Buffer, BufferSize, DataSize);
			public HResult VirtualToPhysical(uint64 Virtual, out uint64 Physical) mut => VT.VirtualToPhysical(ref this, Virtual, out Physical);
			public HResult GetVirtualTranslationPhysicalOffsets(uint64 Virtual, uint64* Offsets, uint32 OffsetsSize, uint32* Levels) mut => VT.GetVirtualTranslationPhysicalOffsets(ref this, Virtual, Offsets, OffsetsSize, Levels);
			public HResult ReadHandleData(uint64 Handle, uint32 DataType, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadHandleData(ref this, Handle, DataType, Buffer, BufferSize, DataSize);
			public HResult FillVirtual(uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) mut => VT.FillVirtual(ref this, Start, Size, Pattern, PatternSize, Filled);
			public HResult FillPhysical(uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) mut => VT.FillPhysical(ref this, Start, Size, Pattern, PatternSize, Filled);
			public HResult QueryVirtual(uint64 Offset, out MEMORY_BASIC_INFORMATION64 Info) mut => VT.QueryVirtual(ref this, Offset, out Info);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Offset, uint64 Length, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) SearchVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadVirtualUncached;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteVirtualUncached;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 Count, uint64 Offset, uint64* Ptrs) ReadPointersVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 Count, uint64 Offset, uint64* Ptrs) WritePointersVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WritePhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadIo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteIo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 Msr, out uint64 Value) ReadMsr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 Msr, uint64 Value) WriteMsr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadBusData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteBusData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self) CheckLowMemory;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadDebuggerData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint32 Processor, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadProcessorSystemData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Virtual, out uint64 Physical) VirtualToPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Virtual, uint64* Offsets, uint32 OffsetsSize, uint32* Levels) GetVirtualTranslationPhysicalOffsets;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Handle, uint32 DataType, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadHandleData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) FillVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) FillPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces2 self, uint64 Offset, out MEMORY_BASIC_INFORMATION64 Info) QueryVirtual;
			}
		}
		[CRepr]
		public struct IDebugDataSpaces3 : IUnknown
		{
			public const new Guid IID = .(0x23f79d6c, 0x8aaf, 0x4f7c, 0xa6, 0x07, 0x99, 0x95, 0xf5, 0x40, 0x7e, 0x63);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ReadVirtual(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadVirtual(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteVirtual(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteVirtual(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult SearchVirtual(uint64 Offset, uint64 Length, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) mut => VT.SearchVirtual(ref this, Offset, Length, Pattern, PatternSize, PatternGranularity, out MatchOffset);
			public HResult ReadVirtualUncached(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadVirtualUncached(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteVirtualUncached(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteVirtualUncached(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadPointersVirtual(uint32 Count, uint64 Offset, uint64* Ptrs) mut => VT.ReadPointersVirtual(ref this, Count, Offset, Ptrs);
			public HResult WritePointersVirtual(uint32 Count, uint64 Offset, uint64* Ptrs) mut => VT.WritePointersVirtual(ref this, Count, Offset, Ptrs);
			public HResult ReadPhysical(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadPhysical(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WritePhysical(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WritePhysical(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadControl(uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadControl(ref this, Processor, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteControl(uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteControl(ref this, Processor, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadIo(uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadIo(ref this, InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteIo(uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteIo(ref this, InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadMsr(uint32 Msr, out uint64 Value) mut => VT.ReadMsr(ref this, Msr, out Value);
			public HResult WriteMsr(uint32 Msr, uint64 Value) mut => VT.WriteMsr(ref this, Msr, Value);
			public HResult ReadBusData(uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadBusData(ref this, BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteBusData(uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteBusData(ref this, BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
			public HResult CheckLowMemory() mut => VT.CheckLowMemory(ref this);
			public HResult ReadDebuggerData(uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadDebuggerData(ref this, Index, Buffer, BufferSize, DataSize);
			public HResult ReadProcessorSystemData(uint32 Processor, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadProcessorSystemData(ref this, Processor, Index, Buffer, BufferSize, DataSize);
			public HResult VirtualToPhysical(uint64 Virtual, out uint64 Physical) mut => VT.VirtualToPhysical(ref this, Virtual, out Physical);
			public HResult GetVirtualTranslationPhysicalOffsets(uint64 Virtual, uint64* Offsets, uint32 OffsetsSize, uint32* Levels) mut => VT.GetVirtualTranslationPhysicalOffsets(ref this, Virtual, Offsets, OffsetsSize, Levels);
			public HResult ReadHandleData(uint64 Handle, uint32 DataType, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadHandleData(ref this, Handle, DataType, Buffer, BufferSize, DataSize);
			public HResult FillVirtual(uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) mut => VT.FillVirtual(ref this, Start, Size, Pattern, PatternSize, Filled);
			public HResult FillPhysical(uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) mut => VT.FillPhysical(ref this, Start, Size, Pattern, PatternSize, Filled);
			public HResult QueryVirtual(uint64 Offset, out MEMORY_BASIC_INFORMATION64 Info) mut => VT.QueryVirtual(ref this, Offset, out Info);
			public HResult ReadImageNtHeaders(uint64 ImageBase, out IMAGE_NT_HEADERS64 Headers) mut => VT.ReadImageNtHeaders(ref this, ImageBase, out Headers);
			public HResult ReadTagged(ref Guid Tag, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* TotalSize) mut => VT.ReadTagged(ref this, ref Tag, Offset, Buffer, BufferSize, TotalSize);
			public HResult StartEnumTagged(out uint64 Handle) mut => VT.StartEnumTagged(ref this, out Handle);
			public HResult GetNextTagged(uint64 Handle, out Guid Tag, out uint32 Size) mut => VT.GetNextTagged(ref this, Handle, out Tag, out Size);
			public HResult EndEnumTagged(uint64 Handle) mut => VT.EndEnumTagged(ref this, Handle);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Offset, uint64 Length, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) SearchVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadVirtualUncached;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteVirtualUncached;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 Count, uint64 Offset, uint64* Ptrs) ReadPointersVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 Count, uint64 Offset, uint64* Ptrs) WritePointersVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WritePhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadIo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteIo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 Msr, out uint64 Value) ReadMsr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 Msr, uint64 Value) WriteMsr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadBusData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteBusData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self) CheckLowMemory;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadDebuggerData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint32 Processor, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadProcessorSystemData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Virtual, out uint64 Physical) VirtualToPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Virtual, uint64* Offsets, uint32 OffsetsSize, uint32* Levels) GetVirtualTranslationPhysicalOffsets;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Handle, uint32 DataType, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadHandleData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) FillVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) FillPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Offset, out MEMORY_BASIC_INFORMATION64 Info) QueryVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 ImageBase, out IMAGE_NT_HEADERS64 Headers) ReadImageNtHeaders;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, ref Guid Tag, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* TotalSize) ReadTagged;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, out uint64 Handle) StartEnumTagged;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Handle, out Guid Tag, out uint32 Size) GetNextTagged;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces3 self, uint64 Handle) EndEnumTagged;
			}
		}
		[CRepr]
		public struct IDebugDataSpaces4 : IUnknown
		{
			public const new Guid IID = .(0xd98ada1f, 0x29e9, 0x4ef5, 0xa6, 0xc0, 0xe5, 0x33, 0x49, 0x88, 0x32, 0x12);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ReadVirtual(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadVirtual(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteVirtual(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteVirtual(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult SearchVirtual(uint64 Offset, uint64 Length, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) mut => VT.SearchVirtual(ref this, Offset, Length, Pattern, PatternSize, PatternGranularity, out MatchOffset);
			public HResult ReadVirtualUncached(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadVirtualUncached(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteVirtualUncached(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteVirtualUncached(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadPointersVirtual(uint32 Count, uint64 Offset, uint64* Ptrs) mut => VT.ReadPointersVirtual(ref this, Count, Offset, Ptrs);
			public HResult WritePointersVirtual(uint32 Count, uint64 Offset, uint64* Ptrs) mut => VT.WritePointersVirtual(ref this, Count, Offset, Ptrs);
			public HResult ReadPhysical(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadPhysical(ref this, Offset, Buffer, BufferSize, BytesRead);
			public HResult WritePhysical(uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WritePhysical(ref this, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadControl(uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadControl(ref this, Processor, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteControl(uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteControl(ref this, Processor, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadIo(uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadIo(ref this, InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteIo(uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteIo(ref this, InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
			public HResult ReadMsr(uint32 Msr, out uint64 Value) mut => VT.ReadMsr(ref this, Msr, out Value);
			public HResult WriteMsr(uint32 Msr, uint64 Value) mut => VT.WriteMsr(ref this, Msr, Value);
			public HResult ReadBusData(uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadBusData(ref this, BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
			public HResult WriteBusData(uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteBusData(ref this, BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
			public HResult CheckLowMemory() mut => VT.CheckLowMemory(ref this);
			public HResult ReadDebuggerData(uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadDebuggerData(ref this, Index, Buffer, BufferSize, DataSize);
			public HResult ReadProcessorSystemData(uint32 Processor, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadProcessorSystemData(ref this, Processor, Index, Buffer, BufferSize, DataSize);
			public HResult VirtualToPhysical(uint64 Virtual, out uint64 Physical) mut => VT.VirtualToPhysical(ref this, Virtual, out Physical);
			public HResult GetVirtualTranslationPhysicalOffsets(uint64 Virtual, uint64* Offsets, uint32 OffsetsSize, uint32* Levels) mut => VT.GetVirtualTranslationPhysicalOffsets(ref this, Virtual, Offsets, OffsetsSize, Levels);
			public HResult ReadHandleData(uint64 Handle, uint32 DataType, void* Buffer, uint32 BufferSize, uint32* DataSize) mut => VT.ReadHandleData(ref this, Handle, DataType, Buffer, BufferSize, DataSize);
			public HResult FillVirtual(uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) mut => VT.FillVirtual(ref this, Start, Size, Pattern, PatternSize, Filled);
			public HResult FillPhysical(uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) mut => VT.FillPhysical(ref this, Start, Size, Pattern, PatternSize, Filled);
			public HResult QueryVirtual(uint64 Offset, out MEMORY_BASIC_INFORMATION64 Info) mut => VT.QueryVirtual(ref this, Offset, out Info);
			public HResult ReadImageNtHeaders(uint64 ImageBase, out IMAGE_NT_HEADERS64 Headers) mut => VT.ReadImageNtHeaders(ref this, ImageBase, out Headers);
			public HResult ReadTagged(ref Guid Tag, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* TotalSize) mut => VT.ReadTagged(ref this, ref Tag, Offset, Buffer, BufferSize, TotalSize);
			public HResult StartEnumTagged(out uint64 Handle) mut => VT.StartEnumTagged(ref this, out Handle);
			public HResult GetNextTagged(uint64 Handle, out Guid Tag, out uint32 Size) mut => VT.GetNextTagged(ref this, Handle, out Tag, out Size);
			public HResult EndEnumTagged(uint64 Handle) mut => VT.EndEnumTagged(ref this, Handle);
			public HResult GetOffsetInformation(uint32 Space, uint32 Which, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* InfoSize) mut => VT.GetOffsetInformation(ref this, Space, Which, Offset, Buffer, BufferSize, InfoSize);
			public HResult GetNextDifferentlyValidOffsetVirtual(uint64 Offset, out uint64 NextOffset) mut => VT.GetNextDifferentlyValidOffsetVirtual(ref this, Offset, out NextOffset);
			public HResult GetValidRegionVirtual(uint64 Base, uint32 Size, out uint64 ValidBase, out uint32 ValidSize) mut => VT.GetValidRegionVirtual(ref this, Base, Size, out ValidBase, out ValidSize);
			public HResult SearchVirtual2(uint64 Offset, uint64 Length, uint32 Flags, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) mut => VT.SearchVirtual2(ref this, Offset, Length, Flags, Pattern, PatternSize, PatternGranularity, out MatchOffset);
			public HResult ReadMultiByteStringVirtual(uint64 Offset, uint32 MaxBytes, uint8* Buffer, uint32 BufferSize, uint32* StringBytes) mut => VT.ReadMultiByteStringVirtual(ref this, Offset, MaxBytes, Buffer, BufferSize, StringBytes);
			public HResult ReadMultiByteStringVirtualWide(uint64 Offset, uint32 MaxBytes, uint32 CodePage, char16* Buffer, uint32 BufferSize, uint32* StringBytes) mut => VT.ReadMultiByteStringVirtualWide(ref this, Offset, MaxBytes, CodePage, Buffer, BufferSize, StringBytes);
			public HResult ReadUnicodeStringVirtual(uint64 Offset, uint32 MaxBytes, uint32 CodePage, uint8* Buffer, uint32 BufferSize, uint32* StringBytes) mut => VT.ReadUnicodeStringVirtual(ref this, Offset, MaxBytes, CodePage, Buffer, BufferSize, StringBytes);
			public HResult ReadUnicodeStringVirtualWide(uint64 Offset, uint32 MaxBytes, char16* Buffer, uint32 BufferSize, uint32* StringBytes) mut => VT.ReadUnicodeStringVirtualWide(ref this, Offset, MaxBytes, Buffer, BufferSize, StringBytes);
			public HResult ReadPhysical2(uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadPhysical2(ref this, Offset, Flags, Buffer, BufferSize, BytesRead);
			public HResult WritePhysical2(uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WritePhysical2(ref this, Offset, Flags, Buffer, BufferSize, BytesWritten);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, uint64 Length, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) SearchVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadVirtualUncached;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteVirtualUncached;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 Count, uint64 Offset, uint64* Ptrs) ReadPointersVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 Count, uint64 Offset, uint64* Ptrs) WritePointersVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WritePhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 Processor, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteControl;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadIo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 InterfaceType, uint32 BusNumber, uint32 AddressSpace, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteIo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 Msr, out uint64 Value) ReadMsr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 Msr, uint64 Value) WriteMsr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadBusData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 BusDataType, uint32 BusNumber, uint32 SlotNumber, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteBusData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self) CheckLowMemory;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadDebuggerData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 Processor, uint32 Index, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadProcessorSystemData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Virtual, out uint64 Physical) VirtualToPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Virtual, uint64* Offsets, uint32 OffsetsSize, uint32* Levels) GetVirtualTranslationPhysicalOffsets;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Handle, uint32 DataType, void* Buffer, uint32 BufferSize, uint32* DataSize) ReadHandleData;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) FillVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Start, uint32 Size, void* Pattern, uint32 PatternSize, uint32* Filled) FillPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, out MEMORY_BASIC_INFORMATION64 Info) QueryVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 ImageBase, out IMAGE_NT_HEADERS64 Headers) ReadImageNtHeaders;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, ref Guid Tag, uint32 Offset, void* Buffer, uint32 BufferSize, uint32* TotalSize) ReadTagged;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, out uint64 Handle) StartEnumTagged;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Handle, out Guid Tag, out uint32 Size) GetNextTagged;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Handle) EndEnumTagged;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint32 Space, uint32 Which, uint64 Offset, void* Buffer, uint32 BufferSize, uint32* InfoSize) GetOffsetInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, out uint64 NextOffset) GetNextDifferentlyValidOffsetVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Base, uint32 Size, out uint64 ValidBase, out uint32 ValidSize) GetValidRegionVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, uint64 Length, uint32 Flags, void* Pattern, uint32 PatternSize, uint32 PatternGranularity, out uint64 MatchOffset) SearchVirtual2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, uint32 MaxBytes, uint8* Buffer, uint32 BufferSize, uint32* StringBytes) ReadMultiByteStringVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, uint32 MaxBytes, uint32 CodePage, char16* Buffer, uint32 BufferSize, uint32* StringBytes) ReadMultiByteStringVirtualWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, uint32 MaxBytes, uint32 CodePage, uint8* Buffer, uint32 BufferSize, uint32* StringBytes) ReadUnicodeStringVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, uint32 MaxBytes, char16* Buffer, uint32 BufferSize, uint32* StringBytes) ReadUnicodeStringVirtualWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadPhysical2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDataSpaces4 self, uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WritePhysical2;
			}
		}
		[CRepr]
		public struct IDebugEventCallbacks : IUnknown
		{
			public const new Guid IID = .(0x337be28b, 0x5036, 0x4d72, 0xb6, 0xbf, 0xc4, 0x5f, 0xbb, 0x9f, 0x2e, 0xaa);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterestMask(out uint32 Mask) mut => VT.GetInterestMask(ref this, out Mask);
			public HResult Breakpoint(ref IDebugBreakpoint Bp) mut => VT.Breakpoint(ref this, ref Bp);
			public HResult Exception(ref EXCEPTION_RECORD64 Exception, uint32 FirstChance) mut => VT.Exception(ref this, ref Exception, FirstChance);
			public HResult CreateThread(uint64 Handle, uint64 DataOffset, uint64 StartOffset) mut => VT._CreateThread(ref this, Handle, DataOffset, StartOffset);
			public HResult ExitThread(uint32 ExitCode) mut => VT._ExitThread(ref this, ExitCode);
			public HResult CreateProcessA(uint64 ImageFileHandle, uint64 Handle, uint64 BaseOffset, uint32 ModuleSize, char8* ModuleName, char8* ImageName, uint32 CheckSum, uint32 TimeDateStamp, uint64 InitialThreadHandle, uint64 ThreadDataOffset, uint64 StartOffset) mut => VT._CreateProcessA(ref this, ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset);
			public HResult ExitProcess(uint32 ExitCode) mut => VT._ExitProcess(ref this, ExitCode);
			public HResult LoadModule(uint64 ImageFileHandle, uint64 BaseOffset, uint32 ModuleSize, char8* ModuleName, char8* ImageName, uint32 CheckSum, uint32 TimeDateStamp) mut => VT.LoadModule(ref this, ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp);
			public HResult UnloadModule(char8* ImageBaseName, uint64 BaseOffset) mut => VT.UnloadModule(ref this, ImageBaseName, BaseOffset);
			public HResult SystemError(uint32 Error, uint32 Level) mut => VT.SystemError(ref this, Error, Level);
			public HResult SessionStatus(uint32 Status) mut => VT.SessionStatus(ref this, Status);
			public HResult ChangeDebuggeeState(uint32 Flags, uint64 Argument) mut => VT.ChangeDebuggeeState(ref this, Flags, Argument);
			public HResult ChangeEngineState(uint32 Flags, uint64 Argument) mut => VT.ChangeEngineState(ref this, Flags, Argument);
			public HResult ChangeSymbolState(uint32 Flags, uint64 Argument) mut => VT.ChangeSymbolState(ref this, Flags, Argument);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, out uint32 Mask) GetInterestMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, ref IDebugBreakpoint Bp) Breakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, ref EXCEPTION_RECORD64 Exception, uint32 FirstChance) Exception;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint64 Handle, uint64 DataOffset, uint64 StartOffset) _CreateThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint32 ExitCode) _ExitThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint64 ImageFileHandle, uint64 Handle, uint64 BaseOffset, uint32 ModuleSize, char8* ModuleName, char8* ImageName, uint32 CheckSum, uint32 TimeDateStamp, uint64 InitialThreadHandle, uint64 ThreadDataOffset, uint64 StartOffset) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint32 ExitCode) _ExitProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint64 ImageFileHandle, uint64 BaseOffset, uint32 ModuleSize, char8* ModuleName, char8* ImageName, uint32 CheckSum, uint32 TimeDateStamp) LoadModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, char8* ImageBaseName, uint64 BaseOffset) UnloadModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint32 Error, uint32 Level) SystemError;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint32 Status) SessionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint32 Flags, uint64 Argument) ChangeDebuggeeState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint32 Flags, uint64 Argument) ChangeEngineState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacks self, uint32 Flags, uint64 Argument) ChangeSymbolState;
			}
		}
		[CRepr]
		public struct IDebugEventCallbacksWide : IUnknown
		{
			public const new Guid IID = .(0x0690e046, 0x9c23, 0x45ac, 0xa0, 0x4f, 0x98, 0x7a, 0xc2, 0x9a, 0xd0, 0xd3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterestMask(out uint32 Mask) mut => VT.GetInterestMask(ref this, out Mask);
			public HResult Breakpoint(ref IDebugBreakpoint2 Bp) mut => VT.Breakpoint(ref this, ref Bp);
			public HResult Exception(ref EXCEPTION_RECORD64 Exception, uint32 FirstChance) mut => VT.Exception(ref this, ref Exception, FirstChance);
			public HResult CreateThread(uint64 Handle, uint64 DataOffset, uint64 StartOffset) mut => VT._CreateThread(ref this, Handle, DataOffset, StartOffset);
			public HResult ExitThread(uint32 ExitCode) mut => VT._ExitThread(ref this, ExitCode);
			public HResult CreateProcessA(uint64 ImageFileHandle, uint64 Handle, uint64 BaseOffset, uint32 ModuleSize, char16* ModuleName, char16* ImageName, uint32 CheckSum, uint32 TimeDateStamp, uint64 InitialThreadHandle, uint64 ThreadDataOffset, uint64 StartOffset) mut => VT._CreateProcessA(ref this, ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset);
			public HResult ExitProcess(uint32 ExitCode) mut => VT._ExitProcess(ref this, ExitCode);
			public HResult LoadModule(uint64 ImageFileHandle, uint64 BaseOffset, uint32 ModuleSize, char16* ModuleName, char16* ImageName, uint32 CheckSum, uint32 TimeDateStamp) mut => VT.LoadModule(ref this, ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp);
			public HResult UnloadModule(char16* ImageBaseName, uint64 BaseOffset) mut => VT.UnloadModule(ref this, ImageBaseName, BaseOffset);
			public HResult SystemError(uint32 Error, uint32 Level) mut => VT.SystemError(ref this, Error, Level);
			public HResult SessionStatus(uint32 Status) mut => VT.SessionStatus(ref this, Status);
			public HResult ChangeDebuggeeState(uint32 Flags, uint64 Argument) mut => VT.ChangeDebuggeeState(ref this, Flags, Argument);
			public HResult ChangeEngineState(uint32 Flags, uint64 Argument) mut => VT.ChangeEngineState(ref this, Flags, Argument);
			public HResult ChangeSymbolState(uint32 Flags, uint64 Argument) mut => VT.ChangeSymbolState(ref this, Flags, Argument);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, out uint32 Mask) GetInterestMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, ref IDebugBreakpoint2 Bp) Breakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, ref EXCEPTION_RECORD64 Exception, uint32 FirstChance) Exception;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint64 Handle, uint64 DataOffset, uint64 StartOffset) _CreateThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint32 ExitCode) _ExitThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint64 ImageFileHandle, uint64 Handle, uint64 BaseOffset, uint32 ModuleSize, char16* ModuleName, char16* ImageName, uint32 CheckSum, uint32 TimeDateStamp, uint64 InitialThreadHandle, uint64 ThreadDataOffset, uint64 StartOffset) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint32 ExitCode) _ExitProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint64 ImageFileHandle, uint64 BaseOffset, uint32 ModuleSize, char16* ModuleName, char16* ImageName, uint32 CheckSum, uint32 TimeDateStamp) LoadModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, char16* ImageBaseName, uint64 BaseOffset) UnloadModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint32 Error, uint32 Level) SystemError;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint32 Status) SessionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint32 Flags, uint64 Argument) ChangeDebuggeeState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint32 Flags, uint64 Argument) ChangeEngineState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventCallbacksWide self, uint32 Flags, uint64 Argument) ChangeSymbolState;
			}
		}
		[CRepr]
		public struct IDebugEventContextCallbacks : IUnknown
		{
			public const new Guid IID = .(0x61a4905b, 0x23f9, 0x4247, 0xb3, 0xc5, 0x53, 0xd0, 0x87, 0x52, 0x9a, 0xb7);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterestMask(out uint32 Mask) mut => VT.GetInterestMask(ref this, out Mask);
			public HResult Breakpoint(ref IDebugBreakpoint2 Bp, void* Context, uint32 ContextSize) mut => VT.Breakpoint(ref this, ref Bp, Context, ContextSize);
			public HResult Exception(ref EXCEPTION_RECORD64 Exception, uint32 FirstChance, void* Context, uint32 ContextSize) mut => VT.Exception(ref this, ref Exception, FirstChance, Context, ContextSize);
			public HResult CreateThread(uint64 Handle, uint64 DataOffset, uint64 StartOffset, void* Context, uint32 ContextSize) mut => VT._CreateThread(ref this, Handle, DataOffset, StartOffset, Context, ContextSize);
			public HResult ExitThread(uint32 ExitCode, void* Context, uint32 ContextSize) mut => VT._ExitThread(ref this, ExitCode, Context, ContextSize);
			public HResult CreateProcessA(uint64 ImageFileHandle, uint64 Handle, uint64 BaseOffset, uint32 ModuleSize, char16* ModuleName, char16* ImageName, uint32 CheckSum, uint32 TimeDateStamp, uint64 InitialThreadHandle, uint64 ThreadDataOffset, uint64 StartOffset, void* Context, uint32 ContextSize) mut => VT._CreateProcessA(ref this, ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset, Context, ContextSize);
			public HResult ExitProcess(uint32 ExitCode, void* Context, uint32 ContextSize) mut => VT._ExitProcess(ref this, ExitCode, Context, ContextSize);
			public HResult LoadModule(uint64 ImageFileHandle, uint64 BaseOffset, uint32 ModuleSize, char16* ModuleName, char16* ImageName, uint32 CheckSum, uint32 TimeDateStamp, void* Context, uint32 ContextSize) mut => VT.LoadModule(ref this, ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, Context, ContextSize);
			public HResult UnloadModule(char16* ImageBaseName, uint64 BaseOffset, void* Context, uint32 ContextSize) mut => VT.UnloadModule(ref this, ImageBaseName, BaseOffset, Context, ContextSize);
			public HResult SystemError(uint32 Error, uint32 Level, void* Context, uint32 ContextSize) mut => VT.SystemError(ref this, Error, Level, Context, ContextSize);
			public HResult SessionStatus(uint32 Status) mut => VT.SessionStatus(ref this, Status);
			public HResult ChangeDebuggeeState(uint32 Flags, uint64 Argument, void* Context, uint32 ContextSize) mut => VT.ChangeDebuggeeState(ref this, Flags, Argument, Context, ContextSize);
			public HResult ChangeEngineState(uint32 Flags, uint64 Argument, void* Context, uint32 ContextSize) mut => VT.ChangeEngineState(ref this, Flags, Argument, Context, ContextSize);
			public HResult ChangeSymbolState(uint32 Flags, uint64 Argument) mut => VT.ChangeSymbolState(ref this, Flags, Argument);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, out uint32 Mask) GetInterestMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, ref IDebugBreakpoint2 Bp, void* Context, uint32 ContextSize) Breakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, ref EXCEPTION_RECORD64 Exception, uint32 FirstChance, void* Context, uint32 ContextSize) Exception;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint64 Handle, uint64 DataOffset, uint64 StartOffset, void* Context, uint32 ContextSize) _CreateThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint32 ExitCode, void* Context, uint32 ContextSize) _ExitThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint64 ImageFileHandle, uint64 Handle, uint64 BaseOffset, uint32 ModuleSize, char16* ModuleName, char16* ImageName, uint32 CheckSum, uint32 TimeDateStamp, uint64 InitialThreadHandle, uint64 ThreadDataOffset, uint64 StartOffset, void* Context, uint32 ContextSize) _CreateProcessA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint32 ExitCode, void* Context, uint32 ContextSize) _ExitProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint64 ImageFileHandle, uint64 BaseOffset, uint32 ModuleSize, char16* ModuleName, char16* ImageName, uint32 CheckSum, uint32 TimeDateStamp, void* Context, uint32 ContextSize) LoadModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, char16* ImageBaseName, uint64 BaseOffset, void* Context, uint32 ContextSize) UnloadModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint32 Error, uint32 Level, void* Context, uint32 ContextSize) SystemError;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint32 Status) SessionStatus;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint32 Flags, uint64 Argument, void* Context, uint32 ContextSize) ChangeDebuggeeState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint32 Flags, uint64 Argument, void* Context, uint32 ContextSize) ChangeEngineState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugEventContextCallbacks self, uint32 Flags, uint64 Argument) ChangeSymbolState;
			}
		}
		[CRepr]
		public struct IDebugInputCallbacks : IUnknown
		{
			public const new Guid IID = .(0x9f50e42c, 0xf136, 0x499e, 0x9a, 0x97, 0x73, 0x03, 0x6c, 0x94, 0xed, 0x2d);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult StartInput(uint32 BufferSize) mut => VT.StartInput(ref this, BufferSize);
			public HResult EndInput() mut => VT.EndInput(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugInputCallbacks self, uint32 BufferSize) StartInput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugInputCallbacks self) EndInput;
			}
		}
		[CRepr]
		public struct IDebugOutputCallbacks : IUnknown
		{
			public const new Guid IID = .(0x4bf58045, 0xd654, 0x4c40, 0xb0, 0xaf, 0x68, 0x30, 0x90, 0xf3, 0x56, 0xdc);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Output(uint32 Mask, char8* Text) mut => VT.Output(ref this, Mask, Text);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugOutputCallbacks self, uint32 Mask, char8* Text) Output;
			}
		}
		[CRepr]
		public struct IDebugOutputCallbacksWide : IUnknown
		{
			public const new Guid IID = .(0x4c7fd663, 0xc394, 0x4e26, 0x8e, 0xf1, 0x34, 0xad, 0x5e, 0xd3, 0x76, 0x4c);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Output(uint32 Mask, char16* Text) mut => VT.Output(ref this, Mask, Text);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugOutputCallbacksWide self, uint32 Mask, char16* Text) Output;
			}
		}
		[CRepr]
		public struct IDebugOutputCallbacks2 : IUnknown
		{
			public const new Guid IID = .(0x67721fe9, 0x56d2, 0x4a44, 0xa3, 0x25, 0x2b, 0x65, 0x51, 0x3c, 0xe6, 0xeb);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Output(uint32 Mask, char8* Text) mut => VT.Output(ref this, Mask, Text);
			public HResult GetInterestMask(out uint32 Mask) mut => VT.GetInterestMask(ref this, out Mask);
			public HResult Output2(uint32 Which, uint32 Flags, uint64 Arg, char16* Text) mut => VT.Output2(ref this, Which, Flags, Arg, Text);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugOutputCallbacks2 self, uint32 Mask, char8* Text) Output;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugOutputCallbacks2 self, out uint32 Mask) GetInterestMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugOutputCallbacks2 self, uint32 Which, uint32 Flags, uint64 Arg, char16* Text) Output2;
			}
		}
		[CRepr]
		public struct IDebugRegisters : IUnknown
		{
			public const new Guid IID = .(0xce289126, 0x9e84, 0x45a7, 0x93, 0x7e, 0x67, 0xbb, 0x18, 0x69, 0x14, 0x93);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetNumberRegisters(out uint32 Number) mut => VT.GetNumberRegisters(ref this, out Number);
			public HResult GetDescription(uint32 Register, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, DEBUG_REGISTER_DESCRIPTION* Desc) mut => VT.GetDescription(ref this, Register, NameBuffer, NameBufferSize, NameSize, Desc);
			public HResult GetIndexByName(char8* Name, out uint32 Index) mut => VT.GetIndexByName(ref this, Name, out Index);
			public HResult GetValue(uint32 Register, out DEBUG_VALUE Value) mut => VT.GetValue(ref this, Register, out Value);
			public HResult SetValue(uint32 Register, ref DEBUG_VALUE Value) mut => VT.SetValue(ref this, Register, ref Value);
			public HResult GetValues(uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) mut => VT.GetValues(ref this, Count, Indices, Start, Values);
			public HResult SetValues(uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) mut => VT.SetValues(ref this, Count, Indices, Start, Values);
			public HResult OutputRegisters(uint32 OutputControl, uint32 Flags) mut => VT.OutputRegisters(ref this, OutputControl, Flags);
			public HResult GetInstructionOffset(out uint64 Offset) mut => VT.GetInstructionOffset(ref this, out Offset);
			public HResult GetStackOffset(out uint64 Offset) mut => VT.GetStackOffset(ref this, out Offset);
			public HResult GetFrameOffset(out uint64 Offset) mut => VT.GetFrameOffset(ref this, out Offset);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, out uint32 Number) GetNumberRegisters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, uint32 Register, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, DEBUG_REGISTER_DESCRIPTION* Desc) GetDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, char8* Name, out uint32 Index) GetIndexByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, uint32 Register, out DEBUG_VALUE Value) GetValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, uint32 Register, ref DEBUG_VALUE Value) SetValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) GetValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) SetValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, uint32 OutputControl, uint32 Flags) OutputRegisters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, out uint64 Offset) GetInstructionOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, out uint64 Offset) GetStackOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters self, out uint64 Offset) GetFrameOffset;
			}
		}
		[CRepr]
		public struct IDebugRegisters2 : IUnknown
		{
			public const new Guid IID = .(0x1656afa9, 0x19c6, 0x4e3a, 0x97, 0xe7, 0x5d, 0xc9, 0x16, 0x0c, 0xf9, 0xc4);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetNumberRegisters(out uint32 Number) mut => VT.GetNumberRegisters(ref this, out Number);
			public HResult GetDescription(uint32 Register, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, DEBUG_REGISTER_DESCRIPTION* Desc) mut => VT.GetDescription(ref this, Register, NameBuffer, NameBufferSize, NameSize, Desc);
			public HResult GetIndexByName(char8* Name, out uint32 Index) mut => VT.GetIndexByName(ref this, Name, out Index);
			public HResult GetValue(uint32 Register, out DEBUG_VALUE Value) mut => VT.GetValue(ref this, Register, out Value);
			public HResult SetValue(uint32 Register, ref DEBUG_VALUE Value) mut => VT.SetValue(ref this, Register, ref Value);
			public HResult GetValues(uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) mut => VT.GetValues(ref this, Count, Indices, Start, Values);
			public HResult SetValues(uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) mut => VT.SetValues(ref this, Count, Indices, Start, Values);
			public HResult OutputRegisters(uint32 OutputControl, uint32 Flags) mut => VT.OutputRegisters(ref this, OutputControl, Flags);
			public HResult GetInstructionOffset(out uint64 Offset) mut => VT.GetInstructionOffset(ref this, out Offset);
			public HResult GetStackOffset(out uint64 Offset) mut => VT.GetStackOffset(ref this, out Offset);
			public HResult GetFrameOffset(out uint64 Offset) mut => VT.GetFrameOffset(ref this, out Offset);
			public HResult GetDescriptionWide(uint32 Register, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, DEBUG_REGISTER_DESCRIPTION* Desc) mut => VT.GetDescriptionWide(ref this, Register, NameBuffer, NameBufferSize, NameSize, Desc);
			public HResult GetIndexByNameWide(char16* Name, out uint32 Index) mut => VT.GetIndexByNameWide(ref this, Name, out Index);
			public HResult GetNumberPseudoRegisters(out uint32 Number) mut => VT.GetNumberPseudoRegisters(ref this, out Number);
			public HResult GetPseudoDescription(uint32 Register, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* TypeModule, uint32* TypeId) mut => VT.GetPseudoDescription(ref this, Register, NameBuffer, NameBufferSize, NameSize, TypeModule, TypeId);
			public HResult GetPseudoDescriptionWide(uint32 Register, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* TypeModule, uint32* TypeId) mut => VT.GetPseudoDescriptionWide(ref this, Register, NameBuffer, NameBufferSize, NameSize, TypeModule, TypeId);
			public HResult GetPseudoIndexByName(char8* Name, out uint32 Index) mut => VT.GetPseudoIndexByName(ref this, Name, out Index);
			public HResult GetPseudoIndexByNameWide(char16* Name, out uint32 Index) mut => VT.GetPseudoIndexByNameWide(ref this, Name, out Index);
			public HResult GetPseudoValues(uint32 Source, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) mut => VT.GetPseudoValues(ref this, Source, Count, Indices, Start, Values);
			public HResult SetPseudoValues(uint32 Source, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) mut => VT.SetPseudoValues(ref this, Source, Count, Indices, Start, Values);
			public HResult GetValues2(uint32 Source, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) mut => VT.GetValues2(ref this, Source, Count, Indices, Start, Values);
			public HResult SetValues2(uint32 Source, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) mut => VT.SetValues2(ref this, Source, Count, Indices, Start, Values);
			public HResult OutputRegisters2(uint32 OutputControl, uint32 Source, uint32 Flags) mut => VT.OutputRegisters2(ref this, OutputControl, Source, Flags);
			public HResult GetInstructionOffset2(uint32 Source, out uint64 Offset) mut => VT.GetInstructionOffset2(ref this, Source, out Offset);
			public HResult GetStackOffset2(uint32 Source, out uint64 Offset) mut => VT.GetStackOffset2(ref this, Source, out Offset);
			public HResult GetFrameOffset2(uint32 Source, out uint64 Offset) mut => VT.GetFrameOffset2(ref this, Source, out Offset);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, out uint32 Number) GetNumberRegisters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Register, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, DEBUG_REGISTER_DESCRIPTION* Desc) GetDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, char8* Name, out uint32 Index) GetIndexByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Register, out DEBUG_VALUE Value) GetValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Register, ref DEBUG_VALUE Value) SetValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) GetValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) SetValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 OutputControl, uint32 Flags) OutputRegisters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, out uint64 Offset) GetInstructionOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, out uint64 Offset) GetStackOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, out uint64 Offset) GetFrameOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Register, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, DEBUG_REGISTER_DESCRIPTION* Desc) GetDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, char16* Name, out uint32 Index) GetIndexByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, out uint32 Number) GetNumberPseudoRegisters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Register, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* TypeModule, uint32* TypeId) GetPseudoDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Register, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* TypeModule, uint32* TypeId) GetPseudoDescriptionWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, char8* Name, out uint32 Index) GetPseudoIndexByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, char16* Name, out uint32 Index) GetPseudoIndexByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Source, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) GetPseudoValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Source, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) SetPseudoValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Source, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) GetValues2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Source, uint32 Count, uint32* Indices, uint32 Start, DEBUG_VALUE* Values) SetValues2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 OutputControl, uint32 Source, uint32 Flags) OutputRegisters2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Source, out uint64 Offset) GetInstructionOffset2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Source, out uint64 Offset) GetStackOffset2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugRegisters2 self, uint32 Source, out uint64 Offset) GetFrameOffset2;
			}
		}
		[CRepr]
		public struct IDebugSymbolGroup : IUnknown
		{
			public const new Guid IID = .(0xf2528316, 0x0f1a, 0x4431, 0xae, 0xed, 0x11, 0xd0, 0x96, 0xe1, 0xe2, 0xab);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetNumberSymbols(out uint32 Number) mut => VT.GetNumberSymbols(ref this, out Number);
			public HResult AddSymbol(char8* Name, out uint32 Index) mut => VT.AddSymbol(ref this, Name, out Index);
			public HResult RemoveSymbolByName(char8* Name) mut => VT.RemoveSymbolByName(ref this, Name);
			public HResult RemoveSymbolByIndex(uint32 Index) mut => VT.RemoveSymbolByIndex(ref this, Index);
			public HResult GetSymbolName(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetSymbolName(ref this, Index, Buffer, BufferSize, NameSize);
			public HResult GetSymbolParameters(uint32 Start, uint32 Count, DEBUG_SYMBOL_PARAMETERS* Params) mut => VT.GetSymbolParameters(ref this, Start, Count, Params);
			public HResult ExpandSymbol(uint32 Index, IntBool Expand) mut => VT.ExpandSymbol(ref this, Index, Expand);
			public HResult OutputSymbols(uint32 OutputControl, uint32 Flags, uint32 Start, uint32 Count) mut => VT.OutputSymbols(ref this, OutputControl, Flags, Start, Count);
			public HResult WriteSymbol(uint32 Index, char8* Value) mut => VT.WriteSymbol(ref this, Index, Value);
			public HResult OutputAsType(uint32 Index, char8* Type) mut => VT.OutputAsType(ref this, Index, Type);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, out uint32 Number) GetNumberSymbols;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, char8* Name, out uint32 Index) AddSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, char8* Name) RemoveSymbolByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, uint32 Index) RemoveSymbolByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetSymbolName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, uint32 Start, uint32 Count, DEBUG_SYMBOL_PARAMETERS* Params) GetSymbolParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, uint32 Index, IntBool Expand) ExpandSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, uint32 OutputControl, uint32 Flags, uint32 Start, uint32 Count) OutputSymbols;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, uint32 Index, char8* Value) WriteSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup self, uint32 Index, char8* Type) OutputAsType;
			}
		}
		[CRepr]
		public struct IDebugSymbolGroup2 : IUnknown
		{
			public const new Guid IID = .(0x6a7ccc5f, 0xfb5e, 0x4dcc, 0xb4, 0x1c, 0x6c, 0x20, 0x30, 0x7b, 0xcc, 0xc7);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetNumberSymbols(out uint32 Number) mut => VT.GetNumberSymbols(ref this, out Number);
			public HResult AddSymbol(char8* Name, out uint32 Index) mut => VT.AddSymbol(ref this, Name, out Index);
			public HResult RemoveSymbolByName(char8* Name) mut => VT.RemoveSymbolByName(ref this, Name);
			public HResult RemoveSymbolByIndex(uint32 Index) mut => VT.RemoveSymbolByIndex(ref this, Index);
			public HResult GetSymbolName(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetSymbolName(ref this, Index, Buffer, BufferSize, NameSize);
			public HResult GetSymbolParameters(uint32 Start, uint32 Count, DEBUG_SYMBOL_PARAMETERS* Params) mut => VT.GetSymbolParameters(ref this, Start, Count, Params);
			public HResult ExpandSymbol(uint32 Index, IntBool Expand) mut => VT.ExpandSymbol(ref this, Index, Expand);
			public HResult OutputSymbols(uint32 OutputControl, uint32 Flags, uint32 Start, uint32 Count) mut => VT.OutputSymbols(ref this, OutputControl, Flags, Start, Count);
			public HResult WriteSymbol(uint32 Index, char8* Value) mut => VT.WriteSymbol(ref this, Index, Value);
			public HResult OutputAsType(uint32 Index, char8* Type) mut => VT.OutputAsType(ref this, Index, Type);
			public HResult AddSymbolWide(char16* Name, out uint32 Index) mut => VT.AddSymbolWide(ref this, Name, out Index);
			public HResult RemoveSymbolByNameWide(char16* Name) mut => VT.RemoveSymbolByNameWide(ref this, Name);
			public HResult GetSymbolNameWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetSymbolNameWide(ref this, Index, Buffer, BufferSize, NameSize);
			public HResult WriteSymbolWide(uint32 Index, char16* Value) mut => VT.WriteSymbolWide(ref this, Index, Value);
			public HResult OutputAsTypeWide(uint32 Index, char16* Type) mut => VT.OutputAsTypeWide(ref this, Index, Type);
			public HResult GetSymbolTypeName(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetSymbolTypeName(ref this, Index, Buffer, BufferSize, NameSize);
			public HResult GetSymbolTypeNameWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetSymbolTypeNameWide(ref this, Index, Buffer, BufferSize, NameSize);
			public HResult GetSymbolSize(uint32 Index, out uint32 Size) mut => VT.GetSymbolSize(ref this, Index, out Size);
			public HResult GetSymbolOffset(uint32 Index, out uint64 Offset) mut => VT.GetSymbolOffset(ref this, Index, out Offset);
			public HResult GetSymbolRegister(uint32 Index, out uint32 Register) mut => VT.GetSymbolRegister(ref this, Index, out Register);
			public HResult GetSymbolValueText(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetSymbolValueText(ref this, Index, Buffer, BufferSize, NameSize);
			public HResult GetSymbolValueTextWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetSymbolValueTextWide(ref this, Index, Buffer, BufferSize, NameSize);
			public HResult GetSymbolEntryInformation(uint32 Index, out DEBUG_SYMBOL_ENTRY Entry) mut => VT.GetSymbolEntryInformation(ref this, Index, out Entry);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, out uint32 Number) GetNumberSymbols;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, char8* Name, out uint32 Index) AddSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, char8* Name) RemoveSymbolByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index) RemoveSymbolByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetSymbolName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Start, uint32 Count, DEBUG_SYMBOL_PARAMETERS* Params) GetSymbolParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, IntBool Expand) ExpandSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 OutputControl, uint32 Flags, uint32 Start, uint32 Count) OutputSymbols;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, char8* Value) WriteSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, char8* Type) OutputAsType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, char16* Name, out uint32 Index) AddSymbolWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, char16* Name) RemoveSymbolByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize) GetSymbolNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, char16* Value) WriteSymbolWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, char16* Type) OutputAsTypeWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetSymbolTypeName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize) GetSymbolTypeNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, out uint32 Size) GetSymbolSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, out uint64 Offset) GetSymbolOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, out uint32 Register) GetSymbolRegister;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetSymbolValueText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* NameSize) GetSymbolValueTextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbolGroup2 self, uint32 Index, out DEBUG_SYMBOL_ENTRY Entry) GetSymbolEntryInformation;
			}
		}
		[CRepr]
		public struct IDebugSymbols : IUnknown
		{
			public const new Guid IID = .(0x8c31e98c, 0x983a, 0x48a5, 0x90, 0x16, 0x6f, 0xe5, 0xd6, 0x67, 0xa9, 0x50);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSymbolOptions(out uint32 Options) mut => VT.GetSymbolOptions(ref this, out Options);
			public HResult AddSymbolOptions(uint32 Options) mut => VT.AddSymbolOptions(ref this, Options);
			public HResult RemoveSymbolOptions(uint32 Options) mut => VT.RemoveSymbolOptions(ref this, Options);
			public HResult SetSymbolOptions(uint32 Options) mut => VT.SetSymbolOptions(ref this, Options);
			public HResult GetNameByOffset(uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByOffset(ref this, Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetOffsetByName(char8* Symbol, out uint64 Offset) mut => VT.GetOffsetByName(ref this, Symbol, out Offset);
			public HResult GetNearNameByOffset(uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNearNameByOffset(ref this, Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByOffset(uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByOffset(ref this, Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetOffsetByLine(uint32 Line, char8* File, out uint64 Offset) mut => VT.GetOffsetByLine(ref this, Line, File, out Offset);
			public HResult GetNumberModules(out uint32 Loaded, out uint32 Unloaded) mut => VT.GetNumberModules(ref this, out Loaded, out Unloaded);
			public HResult GetModuleByIndex(uint32 Index, out uint64 Base) mut => VT.GetModuleByIndex(ref this, Index, out Base);
			public HResult GetModuleByModuleName(char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName(ref this, Name, StartIndex, Index, Base);
			public HResult GetModuleByOffset(uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByOffset(ref this, Offset, StartIndex, Index, Base);
			public HResult GetModuleNames(uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) mut => VT.GetModuleNames(ref this, Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
			public HResult GetModuleParameters(uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) mut => VT.GetModuleParameters(ref this, Count, Bases, Start, Params);
			public HResult GetSymbolModule(char8* Symbol, out uint64 Base) mut => VT.GetSymbolModule(ref this, Symbol, out Base);
			public HResult GetTypeName(uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetTypeName(ref this, Module, TypeId, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeId(uint64 Module, char8* Name, out uint32 TypeId) mut => VT.GetTypeId(ref this, Module, Name, out TypeId);
			public HResult GetTypeSize(uint64 Module, uint32 TypeId, out uint32 Size) mut => VT.GetTypeSize(ref this, Module, TypeId, out Size);
			public HResult GetFieldOffset(uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) mut => VT.GetFieldOffset(ref this, Module, TypeId, Field, out Offset);
			public HResult GetSymbolTypeId(char8* Symbol, out uint32 TypeId, uint64* Module) mut => VT.GetSymbolTypeId(ref this, Symbol, out TypeId, Module);
			public HResult GetOffsetTypeId(uint64 Offset, out uint32 TypeId, uint64* Module) mut => VT.GetOffsetTypeId(ref this, Offset, out TypeId, Module);
			public HResult ReadTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataVirtual(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataVirtual(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult ReadTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataPhysical(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataPhysical(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult GetScope(uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.GetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult SetScope(uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.SetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult ResetScope() mut => VT.ResetScope(ref this);
			public HResult GetScopeSymbolGroup(uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) mut => VT.GetScopeSymbolGroup(ref this, Flags, Update, out Symbols);
			public HResult CreateSymbolGroup(out IDebugSymbolGroup* Group) mut => VT.CreateSymbolGroup(ref this, out Group);
			public HResult StartSymbolMatch(char8* Pattern, out uint64 Handle) mut => VT.StartSymbolMatch(ref this, Pattern, out Handle);
			public HResult GetNextSymbolMatch(uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) mut => VT.GetNextSymbolMatch(ref this, Handle, Buffer, BufferSize, MatchSize, Offset);
			public HResult EndSymbolMatch(uint64 Handle) mut => VT.EndSymbolMatch(ref this, Handle);
			public HResult Reload(char8* Module) mut => VT.Reload(ref this, Module);
			public HResult GetSymbolPath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSymbolPath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetSymbolPath(char8* Path) mut => VT.SetSymbolPath(ref this, Path);
			public HResult AppendSymbolPath(char8* Addition) mut => VT.AppendSymbolPath(ref this, Addition);
			public HResult GetImagePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetImagePath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetImagePath(char8* Path) mut => VT.SetImagePath(ref this, Path);
			public HResult AppendImagePath(char8* Addition) mut => VT.AppendImagePath(ref this, Addition);
			public HResult GetSourcePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSourcePath(ref this, Buffer, BufferSize, PathSize);
			public HResult GetSourcePathElement(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) mut => VT.GetSourcePathElement(ref this, Index, Buffer, BufferSize, ElementSize);
			public HResult SetSourcePath(char8* Path) mut => VT.SetSourcePath(ref this, Path);
			public HResult AppendSourcePath(char8* Addition) mut => VT.AppendSourcePath(ref this, Addition);
			public HResult FindSourceFile(uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFile(ref this, StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSourceFileLineOffsets(char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) mut => VT.GetSourceFileLineOffsets(ref this, File, Buffer, BufferLines, FileLines);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, out uint32 Options) GetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 Options) AddSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 Options) RemoveSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 Options) SetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Symbol, out uint64 Offset) GetOffsetByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNearNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 Line, char8* File, out uint64 Offset) GetOffsetByLine;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, out uint32 Loaded, out uint32 Unloaded) GetNumberModules;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 Index, out uint64 Base) GetModuleByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByModuleName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) GetModuleNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) GetModuleParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Symbol, out uint64 Base) GetSymbolModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetTypeName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Module, char8* Name, out uint32 TypeId) GetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Module, uint32 TypeId, out uint32 Size) GetTypeSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) GetFieldOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Symbol, out uint32 TypeId, uint64* Module) GetSymbolTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Offset, out uint32 TypeId, uint64* Module) GetOffsetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) GetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) SetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self) ResetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) GetScopeSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, out IDebugSymbolGroup* Group) CreateSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Pattern, out uint64 Handle) StartSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) GetNextSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint64 Handle) EndSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Module) Reload;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Path) SetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Addition) AppendSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Path) SetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Addition) AppendImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) GetSourcePathElement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Path) SetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* Addition) AppendSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols self, char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) GetSourceFileLineOffsets;
			}
		}
		[CRepr]
		public struct IDebugSymbols2 : IUnknown
		{
			public const new Guid IID = .(0x3a707211, 0xafdd, 0x4495, 0xad, 0x4f, 0x56, 0xfe, 0xcd, 0xf8, 0x16, 0x3f);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSymbolOptions(out uint32 Options) mut => VT.GetSymbolOptions(ref this, out Options);
			public HResult AddSymbolOptions(uint32 Options) mut => VT.AddSymbolOptions(ref this, Options);
			public HResult RemoveSymbolOptions(uint32 Options) mut => VT.RemoveSymbolOptions(ref this, Options);
			public HResult SetSymbolOptions(uint32 Options) mut => VT.SetSymbolOptions(ref this, Options);
			public HResult GetNameByOffset(uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByOffset(ref this, Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetOffsetByName(char8* Symbol, out uint64 Offset) mut => VT.GetOffsetByName(ref this, Symbol, out Offset);
			public HResult GetNearNameByOffset(uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNearNameByOffset(ref this, Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByOffset(uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByOffset(ref this, Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetOffsetByLine(uint32 Line, char8* File, out uint64 Offset) mut => VT.GetOffsetByLine(ref this, Line, File, out Offset);
			public HResult GetNumberModules(out uint32 Loaded, out uint32 Unloaded) mut => VT.GetNumberModules(ref this, out Loaded, out Unloaded);
			public HResult GetModuleByIndex(uint32 Index, out uint64 Base) mut => VT.GetModuleByIndex(ref this, Index, out Base);
			public HResult GetModuleByModuleName(char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName(ref this, Name, StartIndex, Index, Base);
			public HResult GetModuleByOffset(uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByOffset(ref this, Offset, StartIndex, Index, Base);
			public HResult GetModuleNames(uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) mut => VT.GetModuleNames(ref this, Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
			public HResult GetModuleParameters(uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) mut => VT.GetModuleParameters(ref this, Count, Bases, Start, Params);
			public HResult GetSymbolModule(char8* Symbol, out uint64 Base) mut => VT.GetSymbolModule(ref this, Symbol, out Base);
			public HResult GetTypeName(uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetTypeName(ref this, Module, TypeId, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeId(uint64 Module, char8* Name, out uint32 TypeId) mut => VT.GetTypeId(ref this, Module, Name, out TypeId);
			public HResult GetTypeSize(uint64 Module, uint32 TypeId, out uint32 Size) mut => VT.GetTypeSize(ref this, Module, TypeId, out Size);
			public HResult GetFieldOffset(uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) mut => VT.GetFieldOffset(ref this, Module, TypeId, Field, out Offset);
			public HResult GetSymbolTypeId(char8* Symbol, out uint32 TypeId, uint64* Module) mut => VT.GetSymbolTypeId(ref this, Symbol, out TypeId, Module);
			public HResult GetOffsetTypeId(uint64 Offset, out uint32 TypeId, uint64* Module) mut => VT.GetOffsetTypeId(ref this, Offset, out TypeId, Module);
			public HResult ReadTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataVirtual(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataVirtual(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult ReadTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataPhysical(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataPhysical(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult GetScope(uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.GetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult SetScope(uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.SetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult ResetScope() mut => VT.ResetScope(ref this);
			public HResult GetScopeSymbolGroup(uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) mut => VT.GetScopeSymbolGroup(ref this, Flags, Update, out Symbols);
			public HResult CreateSymbolGroup(out IDebugSymbolGroup* Group) mut => VT.CreateSymbolGroup(ref this, out Group);
			public HResult StartSymbolMatch(char8* Pattern, out uint64 Handle) mut => VT.StartSymbolMatch(ref this, Pattern, out Handle);
			public HResult GetNextSymbolMatch(uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) mut => VT.GetNextSymbolMatch(ref this, Handle, Buffer, BufferSize, MatchSize, Offset);
			public HResult EndSymbolMatch(uint64 Handle) mut => VT.EndSymbolMatch(ref this, Handle);
			public HResult Reload(char8* Module) mut => VT.Reload(ref this, Module);
			public HResult GetSymbolPath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSymbolPath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetSymbolPath(char8* Path) mut => VT.SetSymbolPath(ref this, Path);
			public HResult AppendSymbolPath(char8* Addition) mut => VT.AppendSymbolPath(ref this, Addition);
			public HResult GetImagePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetImagePath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetImagePath(char8* Path) mut => VT.SetImagePath(ref this, Path);
			public HResult AppendImagePath(char8* Addition) mut => VT.AppendImagePath(ref this, Addition);
			public HResult GetSourcePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSourcePath(ref this, Buffer, BufferSize, PathSize);
			public HResult GetSourcePathElement(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) mut => VT.GetSourcePathElement(ref this, Index, Buffer, BufferSize, ElementSize);
			public HResult SetSourcePath(char8* Path) mut => VT.SetSourcePath(ref this, Path);
			public HResult AppendSourcePath(char8* Addition) mut => VT.AppendSourcePath(ref this, Addition);
			public HResult FindSourceFile(uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFile(ref this, StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSourceFileLineOffsets(char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) mut => VT.GetSourceFileLineOffsets(ref this, File, Buffer, BufferLines, FileLines);
			public HResult GetModuleVersionInformation(uint32 Index, uint64 Base, char8* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) mut => VT.GetModuleVersionInformation(ref this, Index, Base, Item, Buffer, BufferSize, VerInfoSize);
			public HResult GetModuleNameString(uint32 Which, uint32 Index, uint64 Base, uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetModuleNameString(ref this, Which, Index, Base, Buffer, BufferSize, NameSize);
			public HResult GetConstantName(uint64 Module, uint32 TypeId, uint64 Value, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetConstantName(ref this, Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
			public HResult GetFieldName(uint64 Module, uint32 TypeId, uint32 FieldIndex, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetFieldName(ref this, Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeOptions(out uint32 Options) mut => VT.GetTypeOptions(ref this, out Options);
			public HResult AddTypeOptions(uint32 Options) mut => VT.AddTypeOptions(ref this, Options);
			public HResult RemoveTypeOptions(uint32 Options) mut => VT.RemoveTypeOptions(ref this, Options);
			public HResult SetTypeOptions(uint32 Options) mut => VT.SetTypeOptions(ref this, Options);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, out uint32 Options) GetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Options) AddSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Options) RemoveSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Options) SetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Symbol, out uint64 Offset) GetOffsetByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNearNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Line, char8* File, out uint64 Offset) GetOffsetByLine;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, out uint32 Loaded, out uint32 Unloaded) GetNumberModules;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Index, out uint64 Base) GetModuleByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByModuleName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) GetModuleNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) GetModuleParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Symbol, out uint64 Base) GetSymbolModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetTypeName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Module, char8* Name, out uint32 TypeId) GetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Module, uint32 TypeId, out uint32 Size) GetTypeSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) GetFieldOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Symbol, out uint32 TypeId, uint64* Module) GetSymbolTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Offset, out uint32 TypeId, uint64* Module) GetOffsetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) GetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) SetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self) ResetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) GetScopeSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, out IDebugSymbolGroup* Group) CreateSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Pattern, out uint64 Handle) StartSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) GetNextSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Handle) EndSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Module) Reload;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Path) SetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Addition) AppendSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Path) SetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Addition) AppendImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) GetSourcePathElement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Path) SetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* Addition) AppendSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) GetSourceFileLineOffsets;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Index, uint64 Base, char8* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) GetModuleVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Which, uint32 Index, uint64 Base, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetModuleNameString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Module, uint32 TypeId, uint64 Value, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetConstantName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint64 Module, uint32 TypeId, uint32 FieldIndex, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetFieldName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, out uint32 Options) GetTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Options) AddTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Options) RemoveTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols2 self, uint32 Options) SetTypeOptions;
			}
		}
		[CRepr]
		public struct IDebugSymbols3 : IUnknown
		{
			public const new Guid IID = .(0xf02fbecc, 0x50ac, 0x4f36, 0x9a, 0xd9, 0xc9, 0x75, 0xe8, 0xf3, 0x2f, 0xf8);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSymbolOptions(out uint32 Options) mut => VT.GetSymbolOptions(ref this, out Options);
			public HResult AddSymbolOptions(uint32 Options) mut => VT.AddSymbolOptions(ref this, Options);
			public HResult RemoveSymbolOptions(uint32 Options) mut => VT.RemoveSymbolOptions(ref this, Options);
			public HResult SetSymbolOptions(uint32 Options) mut => VT.SetSymbolOptions(ref this, Options);
			public HResult GetNameByOffset(uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByOffset(ref this, Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetOffsetByName(char8* Symbol, out uint64 Offset) mut => VT.GetOffsetByName(ref this, Symbol, out Offset);
			public HResult GetNearNameByOffset(uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNearNameByOffset(ref this, Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByOffset(uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByOffset(ref this, Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetOffsetByLine(uint32 Line, char8* File, out uint64 Offset) mut => VT.GetOffsetByLine(ref this, Line, File, out Offset);
			public HResult GetNumberModules(out uint32 Loaded, out uint32 Unloaded) mut => VT.GetNumberModules(ref this, out Loaded, out Unloaded);
			public HResult GetModuleByIndex(uint32 Index, out uint64 Base) mut => VT.GetModuleByIndex(ref this, Index, out Base);
			public HResult GetModuleByModuleName(char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName(ref this, Name, StartIndex, Index, Base);
			public HResult GetModuleByOffset(uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByOffset(ref this, Offset, StartIndex, Index, Base);
			public HResult GetModuleNames(uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) mut => VT.GetModuleNames(ref this, Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
			public HResult GetModuleParameters(uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) mut => VT.GetModuleParameters(ref this, Count, Bases, Start, Params);
			public HResult GetSymbolModule(char8* Symbol, out uint64 Base) mut => VT.GetSymbolModule(ref this, Symbol, out Base);
			public HResult GetTypeName(uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetTypeName(ref this, Module, TypeId, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeId(uint64 Module, char8* Name, out uint32 TypeId) mut => VT.GetTypeId(ref this, Module, Name, out TypeId);
			public HResult GetTypeSize(uint64 Module, uint32 TypeId, out uint32 Size) mut => VT.GetTypeSize(ref this, Module, TypeId, out Size);
			public HResult GetFieldOffset(uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) mut => VT.GetFieldOffset(ref this, Module, TypeId, Field, out Offset);
			public HResult GetSymbolTypeId(char8* Symbol, out uint32 TypeId, uint64* Module) mut => VT.GetSymbolTypeId(ref this, Symbol, out TypeId, Module);
			public HResult GetOffsetTypeId(uint64 Offset, out uint32 TypeId, uint64* Module) mut => VT.GetOffsetTypeId(ref this, Offset, out TypeId, Module);
			public HResult ReadTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataVirtual(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataVirtual(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult ReadTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataPhysical(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataPhysical(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult GetScope(uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.GetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult SetScope(uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.SetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult ResetScope() mut => VT.ResetScope(ref this);
			public HResult GetScopeSymbolGroup(uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) mut => VT.GetScopeSymbolGroup(ref this, Flags, Update, out Symbols);
			public HResult CreateSymbolGroup(out IDebugSymbolGroup* Group) mut => VT.CreateSymbolGroup(ref this, out Group);
			public HResult StartSymbolMatch(char8* Pattern, out uint64 Handle) mut => VT.StartSymbolMatch(ref this, Pattern, out Handle);
			public HResult GetNextSymbolMatch(uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) mut => VT.GetNextSymbolMatch(ref this, Handle, Buffer, BufferSize, MatchSize, Offset);
			public HResult EndSymbolMatch(uint64 Handle) mut => VT.EndSymbolMatch(ref this, Handle);
			public HResult Reload(char8* Module) mut => VT.Reload(ref this, Module);
			public HResult GetSymbolPath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSymbolPath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetSymbolPath(char8* Path) mut => VT.SetSymbolPath(ref this, Path);
			public HResult AppendSymbolPath(char8* Addition) mut => VT.AppendSymbolPath(ref this, Addition);
			public HResult GetImagePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetImagePath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetImagePath(char8* Path) mut => VT.SetImagePath(ref this, Path);
			public HResult AppendImagePath(char8* Addition) mut => VT.AppendImagePath(ref this, Addition);
			public HResult GetSourcePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSourcePath(ref this, Buffer, BufferSize, PathSize);
			public HResult GetSourcePathElement(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) mut => VT.GetSourcePathElement(ref this, Index, Buffer, BufferSize, ElementSize);
			public HResult SetSourcePath(char8* Path) mut => VT.SetSourcePath(ref this, Path);
			public HResult AppendSourcePath(char8* Addition) mut => VT.AppendSourcePath(ref this, Addition);
			public HResult FindSourceFile(uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFile(ref this, StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSourceFileLineOffsets(char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) mut => VT.GetSourceFileLineOffsets(ref this, File, Buffer, BufferLines, FileLines);
			public HResult GetModuleVersionInformation(uint32 Index, uint64 Base, char8* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) mut => VT.GetModuleVersionInformation(ref this, Index, Base, Item, Buffer, BufferSize, VerInfoSize);
			public HResult GetModuleNameString(uint32 Which, uint32 Index, uint64 Base, uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetModuleNameString(ref this, Which, Index, Base, Buffer, BufferSize, NameSize);
			public HResult GetConstantName(uint64 Module, uint32 TypeId, uint64 Value, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetConstantName(ref this, Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
			public HResult GetFieldName(uint64 Module, uint32 TypeId, uint32 FieldIndex, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetFieldName(ref this, Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeOptions(out uint32 Options) mut => VT.GetTypeOptions(ref this, out Options);
			public HResult AddTypeOptions(uint32 Options) mut => VT.AddTypeOptions(ref this, Options);
			public HResult RemoveTypeOptions(uint32 Options) mut => VT.RemoveTypeOptions(ref this, Options);
			public HResult SetTypeOptions(uint32 Options) mut => VT.SetTypeOptions(ref this, Options);
			public HResult GetNameByOffsetWide(uint64 Offset, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByOffsetWide(ref this, Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetOffsetByNameWide(char16* Symbol, out uint64 Offset) mut => VT.GetOffsetByNameWide(ref this, Symbol, out Offset);
			public HResult GetNearNameByOffsetWide(uint64 Offset, int32 Delta, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNearNameByOffsetWide(ref this, Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByOffsetWide(uint64 Offset, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByOffsetWide(ref this, Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetOffsetByLineWide(uint32 Line, char16* File, out uint64 Offset) mut => VT.GetOffsetByLineWide(ref this, Line, File, out Offset);
			public HResult GetModuleByModuleNameWide(char16* Name, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleNameWide(ref this, Name, StartIndex, Index, Base);
			public HResult GetSymbolModuleWide(char16* Symbol, out uint64 Base) mut => VT.GetSymbolModuleWide(ref this, Symbol, out Base);
			public HResult GetTypeNameWide(uint64 Module, uint32 TypeId, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetTypeNameWide(ref this, Module, TypeId, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeIdWide(uint64 Module, char16* Name, out uint32 TypeId) mut => VT.GetTypeIdWide(ref this, Module, Name, out TypeId);
			public HResult GetFieldOffsetWide(uint64 Module, uint32 TypeId, char16* Field, out uint32 Offset) mut => VT.GetFieldOffsetWide(ref this, Module, TypeId, Field, out Offset);
			public HResult GetSymbolTypeIdWide(char16* Symbol, out uint32 TypeId, uint64* Module) mut => VT.GetSymbolTypeIdWide(ref this, Symbol, out TypeId, Module);
			public HResult GetScopeSymbolGroup2(uint32 Flags, IDebugSymbolGroup2* Update, out IDebugSymbolGroup2* Symbols) mut => VT.GetScopeSymbolGroup2(ref this, Flags, Update, out Symbols);
			public HResult CreateSymbolGroup2(out IDebugSymbolGroup2* Group) mut => VT.CreateSymbolGroup2(ref this, out Group);
			public HResult StartSymbolMatchWide(char16* Pattern, out uint64 Handle) mut => VT.StartSymbolMatchWide(ref this, Pattern, out Handle);
			public HResult GetNextSymbolMatchWide(uint64 Handle, char16* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) mut => VT.GetNextSymbolMatchWide(ref this, Handle, Buffer, BufferSize, MatchSize, Offset);
			public HResult ReloadWide(char16* Module) mut => VT.ReloadWide(ref this, Module);
			public HResult GetSymbolPathWide(char16* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSymbolPathWide(ref this, Buffer, BufferSize, PathSize);
			public HResult SetSymbolPathWide(char16* Path) mut => VT.SetSymbolPathWide(ref this, Path);
			public HResult AppendSymbolPathWide(char16* Addition) mut => VT.AppendSymbolPathWide(ref this, Addition);
			public HResult GetImagePathWide(char16* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetImagePathWide(ref this, Buffer, BufferSize, PathSize);
			public HResult SetImagePathWide(char16* Path) mut => VT.SetImagePathWide(ref this, Path);
			public HResult AppendImagePathWide(char16* Addition) mut => VT.AppendImagePathWide(ref this, Addition);
			public HResult GetSourcePathWide(char16* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSourcePathWide(ref this, Buffer, BufferSize, PathSize);
			public HResult GetSourcePathElementWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ElementSize) mut => VT.GetSourcePathElementWide(ref this, Index, Buffer, BufferSize, ElementSize);
			public HResult SetSourcePathWide(char16* Path) mut => VT.SetSourcePathWide(ref this, Path);
			public HResult AppendSourcePathWide(char16* Addition) mut => VT.AppendSourcePathWide(ref this, Addition);
			public HResult FindSourceFileWide(uint32 StartElement, char16* File, uint32 Flags, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFileWide(ref this, StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSourceFileLineOffsetsWide(char16* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) mut => VT.GetSourceFileLineOffsetsWide(ref this, File, Buffer, BufferLines, FileLines);
			public HResult GetModuleVersionInformationWide(uint32 Index, uint64 Base, char16* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) mut => VT.GetModuleVersionInformationWide(ref this, Index, Base, Item, Buffer, BufferSize, VerInfoSize);
			public HResult GetModuleNameStringWide(uint32 Which, uint32 Index, uint64 Base, char16* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetModuleNameStringWide(ref this, Which, Index, Base, Buffer, BufferSize, NameSize);
			public HResult GetConstantNameWide(uint64 Module, uint32 TypeId, uint64 Value, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetConstantNameWide(ref this, Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
			public HResult GetFieldNameWide(uint64 Module, uint32 TypeId, uint32 FieldIndex, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetFieldNameWide(ref this, Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
			public HResult IsManagedModule(uint32 Index, uint64 Base) mut => VT.IsManagedModule(ref this, Index, Base);
			public HResult GetModuleByModuleName2(char8* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName2(ref this, Name, StartIndex, Flags, Index, Base);
			public HResult GetModuleByModuleName2Wide(char16* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName2Wide(ref this, Name, StartIndex, Flags, Index, Base);
			public HResult GetModuleByOffset2(uint64 Offset, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) mut => VT.GetModuleByOffset2(ref this, Offset, StartIndex, Flags, Index, Base);
			public HResult AddSyntheticModule(uint64 Base, uint32 Size, char8* ImagePath, char8* ModuleName, uint32 Flags) mut => VT.AddSyntheticModule(ref this, Base, Size, ImagePath, ModuleName, Flags);
			public HResult AddSyntheticModuleWide(uint64 Base, uint32 Size, char16* ImagePath, char16* ModuleName, uint32 Flags) mut => VT.AddSyntheticModuleWide(ref this, Base, Size, ImagePath, ModuleName, Flags);
			public HResult RemoveSyntheticModule(uint64 Base) mut => VT.RemoveSyntheticModule(ref this, Base);
			public HResult GetCurrentScopeFrameIndex(out uint32 Index) mut => VT.GetCurrentScopeFrameIndex(ref this, out Index);
			public HResult SetScopeFrameByIndex(uint32 Index) mut => VT.SetScopeFrameByIndex(ref this, Index);
			public HResult SetScopeFromJitDebugInfo(uint32 OutputControl, uint64 InfoOffset) mut => VT.SetScopeFromJitDebugInfo(ref this, OutputControl, InfoOffset);
			public HResult SetScopeFromStoredEvent() mut => VT.SetScopeFromStoredEvent(ref this);
			public HResult OutputSymbolByOffset(uint32 OutputControl, uint32 Flags, uint64 Offset) mut => VT.OutputSymbolByOffset(ref this, OutputControl, Flags, Offset);
			public HResult GetFunctionEntryByOffset(uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BufferNeeded) mut => VT.GetFunctionEntryByOffset(ref this, Offset, Flags, Buffer, BufferSize, BufferNeeded);
			public HResult GetFieldTypeAndOffset(uint64 Module, uint32 ContainerTypeId, char8* Field, uint32* FieldTypeId, uint32* Offset) mut => VT.GetFieldTypeAndOffset(ref this, Module, ContainerTypeId, Field, FieldTypeId, Offset);
			public HResult GetFieldTypeAndOffsetWide(uint64 Module, uint32 ContainerTypeId, char16* Field, uint32* FieldTypeId, uint32* Offset) mut => VT.GetFieldTypeAndOffsetWide(ref this, Module, ContainerTypeId, Field, FieldTypeId, Offset);
			public HResult AddSyntheticSymbol(uint64 Offset, uint32 Size, char8* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) mut => VT.AddSyntheticSymbol(ref this, Offset, Size, Name, Flags, Id);
			public HResult AddSyntheticSymbolWide(uint64 Offset, uint32 Size, char16* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) mut => VT.AddSyntheticSymbolWide(ref this, Offset, Size, Name, Flags, Id);
			public HResult RemoveSyntheticSymbol(ref DEBUG_MODULE_AND_ID Id) mut => VT.RemoveSyntheticSymbol(ref this, ref Id);
			public HResult GetSymbolEntriesByOffset(uint64 Offset, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint64* Displacements, uint32 IdsCount, uint32* Entries) mut => VT.GetSymbolEntriesByOffset(ref this, Offset, Flags, Ids, Displacements, IdsCount, Entries);
			public HResult GetSymbolEntriesByName(char8* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) mut => VT.GetSymbolEntriesByName(ref this, Symbol, Flags, Ids, IdsCount, Entries);
			public HResult GetSymbolEntriesByNameWide(char16* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) mut => VT.GetSymbolEntriesByNameWide(ref this, Symbol, Flags, Ids, IdsCount, Entries);
			public HResult GetSymbolEntryByToken(uint64 ModuleBase, uint32 Token, out DEBUG_MODULE_AND_ID Id) mut => VT.GetSymbolEntryByToken(ref this, ModuleBase, Token, out Id);
			public HResult GetSymbolEntryInformation(ref DEBUG_MODULE_AND_ID Id, out DEBUG_SYMBOL_ENTRY Info) mut => VT.GetSymbolEntryInformation(ref this, ref Id, out Info);
			public HResult GetSymbolEntryString(ref DEBUG_MODULE_AND_ID Id, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSymbolEntryString(ref this, ref Id, Which, Buffer, BufferSize, StringSize);
			public HResult GetSymbolEntryStringWide(ref DEBUG_MODULE_AND_ID Id, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSymbolEntryStringWide(ref this, ref Id, Which, Buffer, BufferSize, StringSize);
			public HResult GetSymbolEntryOffsetRegions(ref DEBUG_MODULE_AND_ID Id, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) mut => VT.GetSymbolEntryOffsetRegions(ref this, ref Id, Flags, Regions, RegionsCount, RegionsAvail);
			public HResult GetSymbolEntryBySymbolEntry(ref DEBUG_MODULE_AND_ID FromId, uint32 Flags, out DEBUG_MODULE_AND_ID ToId) mut => VT.GetSymbolEntryBySymbolEntry(ref this, ref FromId, Flags, out ToId);
			public HResult GetSourceEntriesByOffset(uint64 Offset, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) mut => VT.GetSourceEntriesByOffset(ref this, Offset, Flags, Entries, EntriesCount, EntriesAvail);
			public HResult GetSourceEntriesByLine(uint32 Line, char8* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) mut => VT.GetSourceEntriesByLine(ref this, Line, File, Flags, Entries, EntriesCount, EntriesAvail);
			public HResult GetSourceEntriesByLineWide(uint32 Line, char16* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) mut => VT.GetSourceEntriesByLineWide(ref this, Line, File, Flags, Entries, EntriesCount, EntriesAvail);
			public HResult GetSourceEntryString(ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSourceEntryString(ref this, ref Entry, Which, Buffer, BufferSize, StringSize);
			public HResult GetSourceEntryStringWide(ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSourceEntryStringWide(ref this, ref Entry, Which, Buffer, BufferSize, StringSize);
			public HResult GetSourceEntryOffsetRegions(ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) mut => VT.GetSourceEntryOffsetRegions(ref this, ref Entry, Flags, Regions, RegionsCount, RegionsAvail);
			public HResult GetSourceEntryBySourceEntry(ref DEBUG_SYMBOL_SOURCE_ENTRY FromEntry, uint32 Flags, out DEBUG_SYMBOL_SOURCE_ENTRY ToEntry) mut => VT.GetSourceEntryBySourceEntry(ref this, ref FromEntry, Flags, out ToEntry);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, out uint32 Options) GetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Options) AddSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Options) RemoveSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Options) SetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Symbol, out uint64 Offset) GetOffsetByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNearNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Line, char8* File, out uint64 Offset) GetOffsetByLine;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, out uint32 Loaded, out uint32 Unloaded) GetNumberModules;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Index, out uint64 Base) GetModuleByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByModuleName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) GetModuleNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) GetModuleParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Symbol, out uint64 Base) GetSymbolModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetTypeName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, char8* Name, out uint32 TypeId) GetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 TypeId, out uint32 Size) GetTypeSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) GetFieldOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Symbol, out uint32 TypeId, uint64* Module) GetSymbolTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, out uint32 TypeId, uint64* Module) GetOffsetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) GetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) SetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self) ResetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) GetScopeSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, out IDebugSymbolGroup* Group) CreateSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Pattern, out uint64 Handle) StartSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) GetNextSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Handle) EndSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Module) Reload;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Path) SetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Addition) AppendSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Path) SetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Addition) AppendImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) GetSourcePathElement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Path) SetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Addition) AppendSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) GetSourceFileLineOffsets;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Index, uint64 Base, char8* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) GetModuleVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Which, uint32 Index, uint64 Base, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetModuleNameString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 TypeId, uint64 Value, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetConstantName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 TypeId, uint32 FieldIndex, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetFieldName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, out uint32 Options) GetTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Options) AddTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Options) RemoveTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Options) SetTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Symbol, out uint64 Offset) GetOffsetByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, int32 Delta, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNearNameByOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Line, char16* File, out uint64 Offset) GetOffsetByLineWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Name, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByModuleNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Symbol, out uint64 Base) GetSymbolModuleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 TypeId, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetTypeNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, char16* Name, out uint32 TypeId) GetTypeIdWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 TypeId, char16* Field, out uint32 Offset) GetFieldOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Symbol, out uint32 TypeId, uint64* Module) GetSymbolTypeIdWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Flags, IDebugSymbolGroup2* Update, out IDebugSymbolGroup2* Symbols) GetScopeSymbolGroup2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, out IDebugSymbolGroup2* Group) CreateSymbolGroup2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Pattern, out uint64 Handle) StartSymbolMatchWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Handle, char16* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) GetNextSymbolMatchWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Module) ReloadWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Buffer, uint32 BufferSize, uint32* PathSize) GetSymbolPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Path) SetSymbolPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Addition) AppendSymbolPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Buffer, uint32 BufferSize, uint32* PathSize) GetImagePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Path) SetImagePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Addition) AppendImagePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Buffer, uint32 BufferSize, uint32* PathSize) GetSourcePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ElementSize) GetSourcePathElementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Path) SetSourcePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Addition) AppendSourcePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 StartElement, char16* File, uint32 Flags, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) GetSourceFileLineOffsetsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Index, uint64 Base, char16* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) GetModuleVersionInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Which, uint32 Index, uint64 Base, char16* Buffer, uint32 BufferSize, uint32* NameSize) GetModuleNameStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 TypeId, uint64 Value, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetConstantNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 TypeId, uint32 FieldIndex, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetFieldNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Index, uint64 Base) IsManagedModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) GetModuleByModuleName2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) GetModuleByModuleName2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) GetModuleByOffset2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Base, uint32 Size, char8* ImagePath, char8* ModuleName, uint32 Flags) AddSyntheticModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Base, uint32 Size, char16* ImagePath, char16* ModuleName, uint32 Flags) AddSyntheticModuleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Base) RemoveSyntheticModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, out uint32 Index) GetCurrentScopeFrameIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Index) SetScopeFrameByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 OutputControl, uint64 InfoOffset) SetScopeFromJitDebugInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self) SetScopeFromStoredEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 OutputControl, uint32 Flags, uint64 Offset) OutputSymbolByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BufferNeeded) GetFunctionEntryByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 ContainerTypeId, char8* Field, uint32* FieldTypeId, uint32* Offset) GetFieldTypeAndOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Module, uint32 ContainerTypeId, char16* Field, uint32* FieldTypeId, uint32* Offset) GetFieldTypeAndOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint32 Size, char8* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) AddSyntheticSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint32 Size, char16* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) AddSyntheticSymbolWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_MODULE_AND_ID Id) RemoveSyntheticSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint64* Displacements, uint32 IdsCount, uint32* Entries) GetSymbolEntriesByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char8* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) GetSymbolEntriesByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, char16* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) GetSymbolEntriesByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 ModuleBase, uint32 Token, out DEBUG_MODULE_AND_ID Id) GetSymbolEntryByToken;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_MODULE_AND_ID Id, out DEBUG_SYMBOL_ENTRY Info) GetSymbolEntryInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_MODULE_AND_ID Id, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSymbolEntryString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_MODULE_AND_ID Id, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSymbolEntryStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_MODULE_AND_ID Id, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) GetSymbolEntryOffsetRegions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_MODULE_AND_ID FromId, uint32 Flags, out DEBUG_MODULE_AND_ID ToId) GetSymbolEntryBySymbolEntry;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint64 Offset, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) GetSourceEntriesByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Line, char8* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) GetSourceEntriesByLine;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, uint32 Line, char16* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) GetSourceEntriesByLineWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSourceEntryString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSourceEntryStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) GetSourceEntryOffsetRegions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols3 self, ref DEBUG_SYMBOL_SOURCE_ENTRY FromEntry, uint32 Flags, out DEBUG_SYMBOL_SOURCE_ENTRY ToEntry) GetSourceEntryBySourceEntry;
			}
		}
		[CRepr]
		public struct IDebugSymbols4 : IUnknown
		{
			public const new Guid IID = .(0xe391bbd8, 0x9d8c, 0x4418, 0x84, 0x0b, 0xc0, 0x06, 0x59, 0x2a, 0x17, 0x52);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSymbolOptions(out uint32 Options) mut => VT.GetSymbolOptions(ref this, out Options);
			public HResult AddSymbolOptions(uint32 Options) mut => VT.AddSymbolOptions(ref this, Options);
			public HResult RemoveSymbolOptions(uint32 Options) mut => VT.RemoveSymbolOptions(ref this, Options);
			public HResult SetSymbolOptions(uint32 Options) mut => VT.SetSymbolOptions(ref this, Options);
			public HResult GetNameByOffset(uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByOffset(ref this, Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetOffsetByName(char8* Symbol, out uint64 Offset) mut => VT.GetOffsetByName(ref this, Symbol, out Offset);
			public HResult GetNearNameByOffset(uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNearNameByOffset(ref this, Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByOffset(uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByOffset(ref this, Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetOffsetByLine(uint32 Line, char8* File, out uint64 Offset) mut => VT.GetOffsetByLine(ref this, Line, File, out Offset);
			public HResult GetNumberModules(out uint32 Loaded, out uint32 Unloaded) mut => VT.GetNumberModules(ref this, out Loaded, out Unloaded);
			public HResult GetModuleByIndex(uint32 Index, out uint64 Base) mut => VT.GetModuleByIndex(ref this, Index, out Base);
			public HResult GetModuleByModuleName(char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName(ref this, Name, StartIndex, Index, Base);
			public HResult GetModuleByOffset(uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByOffset(ref this, Offset, StartIndex, Index, Base);
			public HResult GetModuleNames(uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) mut => VT.GetModuleNames(ref this, Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
			public HResult GetModuleParameters(uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) mut => VT.GetModuleParameters(ref this, Count, Bases, Start, Params);
			public HResult GetSymbolModule(char8* Symbol, out uint64 Base) mut => VT.GetSymbolModule(ref this, Symbol, out Base);
			public HResult GetTypeName(uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetTypeName(ref this, Module, TypeId, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeId(uint64 Module, char8* Name, out uint32 TypeId) mut => VT.GetTypeId(ref this, Module, Name, out TypeId);
			public HResult GetTypeSize(uint64 Module, uint32 TypeId, out uint32 Size) mut => VT.GetTypeSize(ref this, Module, TypeId, out Size);
			public HResult GetFieldOffset(uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) mut => VT.GetFieldOffset(ref this, Module, TypeId, Field, out Offset);
			public HResult GetSymbolTypeId(char8* Symbol, out uint32 TypeId, uint64* Module) mut => VT.GetSymbolTypeId(ref this, Symbol, out TypeId, Module);
			public HResult GetOffsetTypeId(uint64 Offset, out uint32 TypeId, uint64* Module) mut => VT.GetOffsetTypeId(ref this, Offset, out TypeId, Module);
			public HResult ReadTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataVirtual(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataVirtual(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult ReadTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataPhysical(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataPhysical(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult GetScope(uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.GetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult SetScope(uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.SetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult ResetScope() mut => VT.ResetScope(ref this);
			public HResult GetScopeSymbolGroup(uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) mut => VT.GetScopeSymbolGroup(ref this, Flags, Update, out Symbols);
			public HResult CreateSymbolGroup(out IDebugSymbolGroup* Group) mut => VT.CreateSymbolGroup(ref this, out Group);
			public HResult StartSymbolMatch(char8* Pattern, out uint64 Handle) mut => VT.StartSymbolMatch(ref this, Pattern, out Handle);
			public HResult GetNextSymbolMatch(uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) mut => VT.GetNextSymbolMatch(ref this, Handle, Buffer, BufferSize, MatchSize, Offset);
			public HResult EndSymbolMatch(uint64 Handle) mut => VT.EndSymbolMatch(ref this, Handle);
			public HResult Reload(char8* Module) mut => VT.Reload(ref this, Module);
			public HResult GetSymbolPath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSymbolPath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetSymbolPath(char8* Path) mut => VT.SetSymbolPath(ref this, Path);
			public HResult AppendSymbolPath(char8* Addition) mut => VT.AppendSymbolPath(ref this, Addition);
			public HResult GetImagePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetImagePath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetImagePath(char8* Path) mut => VT.SetImagePath(ref this, Path);
			public HResult AppendImagePath(char8* Addition) mut => VT.AppendImagePath(ref this, Addition);
			public HResult GetSourcePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSourcePath(ref this, Buffer, BufferSize, PathSize);
			public HResult GetSourcePathElement(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) mut => VT.GetSourcePathElement(ref this, Index, Buffer, BufferSize, ElementSize);
			public HResult SetSourcePath(char8* Path) mut => VT.SetSourcePath(ref this, Path);
			public HResult AppendSourcePath(char8* Addition) mut => VT.AppendSourcePath(ref this, Addition);
			public HResult FindSourceFile(uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFile(ref this, StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSourceFileLineOffsets(char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) mut => VT.GetSourceFileLineOffsets(ref this, File, Buffer, BufferLines, FileLines);
			public HResult GetModuleVersionInformation(uint32 Index, uint64 Base, char8* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) mut => VT.GetModuleVersionInformation(ref this, Index, Base, Item, Buffer, BufferSize, VerInfoSize);
			public HResult GetModuleNameString(uint32 Which, uint32 Index, uint64 Base, uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetModuleNameString(ref this, Which, Index, Base, Buffer, BufferSize, NameSize);
			public HResult GetConstantName(uint64 Module, uint32 TypeId, uint64 Value, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetConstantName(ref this, Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
			public HResult GetFieldName(uint64 Module, uint32 TypeId, uint32 FieldIndex, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetFieldName(ref this, Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeOptions(out uint32 Options) mut => VT.GetTypeOptions(ref this, out Options);
			public HResult AddTypeOptions(uint32 Options) mut => VT.AddTypeOptions(ref this, Options);
			public HResult RemoveTypeOptions(uint32 Options) mut => VT.RemoveTypeOptions(ref this, Options);
			public HResult SetTypeOptions(uint32 Options) mut => VT.SetTypeOptions(ref this, Options);
			public HResult GetNameByOffsetWide(uint64 Offset, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByOffsetWide(ref this, Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetOffsetByNameWide(char16* Symbol, out uint64 Offset) mut => VT.GetOffsetByNameWide(ref this, Symbol, out Offset);
			public HResult GetNearNameByOffsetWide(uint64 Offset, int32 Delta, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNearNameByOffsetWide(ref this, Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByOffsetWide(uint64 Offset, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByOffsetWide(ref this, Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetOffsetByLineWide(uint32 Line, char16* File, out uint64 Offset) mut => VT.GetOffsetByLineWide(ref this, Line, File, out Offset);
			public HResult GetModuleByModuleNameWide(char16* Name, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleNameWide(ref this, Name, StartIndex, Index, Base);
			public HResult GetSymbolModuleWide(char16* Symbol, out uint64 Base) mut => VT.GetSymbolModuleWide(ref this, Symbol, out Base);
			public HResult GetTypeNameWide(uint64 Module, uint32 TypeId, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetTypeNameWide(ref this, Module, TypeId, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeIdWide(uint64 Module, char16* Name, out uint32 TypeId) mut => VT.GetTypeIdWide(ref this, Module, Name, out TypeId);
			public HResult GetFieldOffsetWide(uint64 Module, uint32 TypeId, char16* Field, out uint32 Offset) mut => VT.GetFieldOffsetWide(ref this, Module, TypeId, Field, out Offset);
			public HResult GetSymbolTypeIdWide(char16* Symbol, out uint32 TypeId, uint64* Module) mut => VT.GetSymbolTypeIdWide(ref this, Symbol, out TypeId, Module);
			public HResult GetScopeSymbolGroup2(uint32 Flags, IDebugSymbolGroup2* Update, out IDebugSymbolGroup2* Symbols) mut => VT.GetScopeSymbolGroup2(ref this, Flags, Update, out Symbols);
			public HResult CreateSymbolGroup2(out IDebugSymbolGroup2* Group) mut => VT.CreateSymbolGroup2(ref this, out Group);
			public HResult StartSymbolMatchWide(char16* Pattern, out uint64 Handle) mut => VT.StartSymbolMatchWide(ref this, Pattern, out Handle);
			public HResult GetNextSymbolMatchWide(uint64 Handle, char16* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) mut => VT.GetNextSymbolMatchWide(ref this, Handle, Buffer, BufferSize, MatchSize, Offset);
			public HResult ReloadWide(char16* Module) mut => VT.ReloadWide(ref this, Module);
			public HResult GetSymbolPathWide(char16* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSymbolPathWide(ref this, Buffer, BufferSize, PathSize);
			public HResult SetSymbolPathWide(char16* Path) mut => VT.SetSymbolPathWide(ref this, Path);
			public HResult AppendSymbolPathWide(char16* Addition) mut => VT.AppendSymbolPathWide(ref this, Addition);
			public HResult GetImagePathWide(char16* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetImagePathWide(ref this, Buffer, BufferSize, PathSize);
			public HResult SetImagePathWide(char16* Path) mut => VT.SetImagePathWide(ref this, Path);
			public HResult AppendImagePathWide(char16* Addition) mut => VT.AppendImagePathWide(ref this, Addition);
			public HResult GetSourcePathWide(char16* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSourcePathWide(ref this, Buffer, BufferSize, PathSize);
			public HResult GetSourcePathElementWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ElementSize) mut => VT.GetSourcePathElementWide(ref this, Index, Buffer, BufferSize, ElementSize);
			public HResult SetSourcePathWide(char16* Path) mut => VT.SetSourcePathWide(ref this, Path);
			public HResult AppendSourcePathWide(char16* Addition) mut => VT.AppendSourcePathWide(ref this, Addition);
			public HResult FindSourceFileWide(uint32 StartElement, char16* File, uint32 Flags, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFileWide(ref this, StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSourceFileLineOffsetsWide(char16* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) mut => VT.GetSourceFileLineOffsetsWide(ref this, File, Buffer, BufferLines, FileLines);
			public HResult GetModuleVersionInformationWide(uint32 Index, uint64 Base, char16* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) mut => VT.GetModuleVersionInformationWide(ref this, Index, Base, Item, Buffer, BufferSize, VerInfoSize);
			public HResult GetModuleNameStringWide(uint32 Which, uint32 Index, uint64 Base, char16* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetModuleNameStringWide(ref this, Which, Index, Base, Buffer, BufferSize, NameSize);
			public HResult GetConstantNameWide(uint64 Module, uint32 TypeId, uint64 Value, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetConstantNameWide(ref this, Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
			public HResult GetFieldNameWide(uint64 Module, uint32 TypeId, uint32 FieldIndex, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetFieldNameWide(ref this, Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
			public HResult IsManagedModule(uint32 Index, uint64 Base) mut => VT.IsManagedModule(ref this, Index, Base);
			public HResult GetModuleByModuleName2(char8* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName2(ref this, Name, StartIndex, Flags, Index, Base);
			public HResult GetModuleByModuleName2Wide(char16* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName2Wide(ref this, Name, StartIndex, Flags, Index, Base);
			public HResult GetModuleByOffset2(uint64 Offset, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) mut => VT.GetModuleByOffset2(ref this, Offset, StartIndex, Flags, Index, Base);
			public HResult AddSyntheticModule(uint64 Base, uint32 Size, char8* ImagePath, char8* ModuleName, uint32 Flags) mut => VT.AddSyntheticModule(ref this, Base, Size, ImagePath, ModuleName, Flags);
			public HResult AddSyntheticModuleWide(uint64 Base, uint32 Size, char16* ImagePath, char16* ModuleName, uint32 Flags) mut => VT.AddSyntheticModuleWide(ref this, Base, Size, ImagePath, ModuleName, Flags);
			public HResult RemoveSyntheticModule(uint64 Base) mut => VT.RemoveSyntheticModule(ref this, Base);
			public HResult GetCurrentScopeFrameIndex(out uint32 Index) mut => VT.GetCurrentScopeFrameIndex(ref this, out Index);
			public HResult SetScopeFrameByIndex(uint32 Index) mut => VT.SetScopeFrameByIndex(ref this, Index);
			public HResult SetScopeFromJitDebugInfo(uint32 OutputControl, uint64 InfoOffset) mut => VT.SetScopeFromJitDebugInfo(ref this, OutputControl, InfoOffset);
			public HResult SetScopeFromStoredEvent() mut => VT.SetScopeFromStoredEvent(ref this);
			public HResult OutputSymbolByOffset(uint32 OutputControl, uint32 Flags, uint64 Offset) mut => VT.OutputSymbolByOffset(ref this, OutputControl, Flags, Offset);
			public HResult GetFunctionEntryByOffset(uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BufferNeeded) mut => VT.GetFunctionEntryByOffset(ref this, Offset, Flags, Buffer, BufferSize, BufferNeeded);
			public HResult GetFieldTypeAndOffset(uint64 Module, uint32 ContainerTypeId, char8* Field, uint32* FieldTypeId, uint32* Offset) mut => VT.GetFieldTypeAndOffset(ref this, Module, ContainerTypeId, Field, FieldTypeId, Offset);
			public HResult GetFieldTypeAndOffsetWide(uint64 Module, uint32 ContainerTypeId, char16* Field, uint32* FieldTypeId, uint32* Offset) mut => VT.GetFieldTypeAndOffsetWide(ref this, Module, ContainerTypeId, Field, FieldTypeId, Offset);
			public HResult AddSyntheticSymbol(uint64 Offset, uint32 Size, char8* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) mut => VT.AddSyntheticSymbol(ref this, Offset, Size, Name, Flags, Id);
			public HResult AddSyntheticSymbolWide(uint64 Offset, uint32 Size, char16* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) mut => VT.AddSyntheticSymbolWide(ref this, Offset, Size, Name, Flags, Id);
			public HResult RemoveSyntheticSymbol(ref DEBUG_MODULE_AND_ID Id) mut => VT.RemoveSyntheticSymbol(ref this, ref Id);
			public HResult GetSymbolEntriesByOffset(uint64 Offset, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint64* Displacements, uint32 IdsCount, uint32* Entries) mut => VT.GetSymbolEntriesByOffset(ref this, Offset, Flags, Ids, Displacements, IdsCount, Entries);
			public HResult GetSymbolEntriesByName(char8* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) mut => VT.GetSymbolEntriesByName(ref this, Symbol, Flags, Ids, IdsCount, Entries);
			public HResult GetSymbolEntriesByNameWide(char16* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) mut => VT.GetSymbolEntriesByNameWide(ref this, Symbol, Flags, Ids, IdsCount, Entries);
			public HResult GetSymbolEntryByToken(uint64 ModuleBase, uint32 Token, out DEBUG_MODULE_AND_ID Id) mut => VT.GetSymbolEntryByToken(ref this, ModuleBase, Token, out Id);
			public HResult GetSymbolEntryInformation(ref DEBUG_MODULE_AND_ID Id, out DEBUG_SYMBOL_ENTRY Info) mut => VT.GetSymbolEntryInformation(ref this, ref Id, out Info);
			public HResult GetSymbolEntryString(ref DEBUG_MODULE_AND_ID Id, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSymbolEntryString(ref this, ref Id, Which, Buffer, BufferSize, StringSize);
			public HResult GetSymbolEntryStringWide(ref DEBUG_MODULE_AND_ID Id, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSymbolEntryStringWide(ref this, ref Id, Which, Buffer, BufferSize, StringSize);
			public HResult GetSymbolEntryOffsetRegions(ref DEBUG_MODULE_AND_ID Id, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) mut => VT.GetSymbolEntryOffsetRegions(ref this, ref Id, Flags, Regions, RegionsCount, RegionsAvail);
			public HResult GetSymbolEntryBySymbolEntry(ref DEBUG_MODULE_AND_ID FromId, uint32 Flags, out DEBUG_MODULE_AND_ID ToId) mut => VT.GetSymbolEntryBySymbolEntry(ref this, ref FromId, Flags, out ToId);
			public HResult GetSourceEntriesByOffset(uint64 Offset, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) mut => VT.GetSourceEntriesByOffset(ref this, Offset, Flags, Entries, EntriesCount, EntriesAvail);
			public HResult GetSourceEntriesByLine(uint32 Line, char8* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) mut => VT.GetSourceEntriesByLine(ref this, Line, File, Flags, Entries, EntriesCount, EntriesAvail);
			public HResult GetSourceEntriesByLineWide(uint32 Line, char16* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) mut => VT.GetSourceEntriesByLineWide(ref this, Line, File, Flags, Entries, EntriesCount, EntriesAvail);
			public HResult GetSourceEntryString(ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSourceEntryString(ref this, ref Entry, Which, Buffer, BufferSize, StringSize);
			public HResult GetSourceEntryStringWide(ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSourceEntryStringWide(ref this, ref Entry, Which, Buffer, BufferSize, StringSize);
			public HResult GetSourceEntryOffsetRegions(ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) mut => VT.GetSourceEntryOffsetRegions(ref this, ref Entry, Flags, Regions, RegionsCount, RegionsAvail);
			public HResult GetSourceEntryBySourceEntry(ref DEBUG_SYMBOL_SOURCE_ENTRY FromEntry, uint32 Flags, out DEBUG_SYMBOL_SOURCE_ENTRY ToEntry) mut => VT.GetSourceEntryBySourceEntry(ref this, ref FromEntry, Flags, out ToEntry);
			public HResult GetScopeEx(uint64* InstructionOffset, DEBUG_STACK_FRAME_EX* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.GetScopeEx(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult SetScopeEx(uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.SetScopeEx(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult GetNameByInlineContext(uint64 Offset, uint32 InlineContext, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByInlineContext(ref this, Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetNameByInlineContextWide(uint64 Offset, uint32 InlineContext, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByInlineContextWide(ref this, Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByInlineContext(uint64 Offset, uint32 InlineContext, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByInlineContext(ref this, Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetLineByInlineContextWide(uint64 Offset, uint32 InlineContext, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByInlineContextWide(ref this, Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult OutputSymbolByInlineContext(uint32 OutputControl, uint32 Flags, uint64 Offset, uint32 InlineContext) mut => VT.OutputSymbolByInlineContext(ref this, OutputControl, Flags, Offset, InlineContext);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, out uint32 Options) GetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Options) AddSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Options) RemoveSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Options) SetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Symbol, out uint64 Offset) GetOffsetByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNearNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Line, char8* File, out uint64 Offset) GetOffsetByLine;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, out uint32 Loaded, out uint32 Unloaded) GetNumberModules;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Index, out uint64 Base) GetModuleByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByModuleName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) GetModuleNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) GetModuleParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Symbol, out uint64 Base) GetSymbolModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetTypeName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, char8* Name, out uint32 TypeId) GetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 TypeId, out uint32 Size) GetTypeSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) GetFieldOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Symbol, out uint32 TypeId, uint64* Module) GetSymbolTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, out uint32 TypeId, uint64* Module) GetOffsetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) GetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) SetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self) ResetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) GetScopeSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, out IDebugSymbolGroup* Group) CreateSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Pattern, out uint64 Handle) StartSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) GetNextSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Handle) EndSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Module) Reload;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Path) SetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Addition) AppendSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Path) SetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Addition) AppendImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) GetSourcePathElement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Path) SetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Addition) AppendSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) GetSourceFileLineOffsets;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Index, uint64 Base, char8* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) GetModuleVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Which, uint32 Index, uint64 Base, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetModuleNameString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 TypeId, uint64 Value, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetConstantName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 TypeId, uint32 FieldIndex, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetFieldName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, out uint32 Options) GetTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Options) AddTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Options) RemoveTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Options) SetTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Symbol, out uint64 Offset) GetOffsetByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, int32 Delta, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNearNameByOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Line, char16* File, out uint64 Offset) GetOffsetByLineWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Name, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByModuleNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Symbol, out uint64 Base) GetSymbolModuleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 TypeId, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetTypeNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, char16* Name, out uint32 TypeId) GetTypeIdWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 TypeId, char16* Field, out uint32 Offset) GetFieldOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Symbol, out uint32 TypeId, uint64* Module) GetSymbolTypeIdWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Flags, IDebugSymbolGroup2* Update, out IDebugSymbolGroup2* Symbols) GetScopeSymbolGroup2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, out IDebugSymbolGroup2* Group) CreateSymbolGroup2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Pattern, out uint64 Handle) StartSymbolMatchWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Handle, char16* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) GetNextSymbolMatchWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Module) ReloadWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Buffer, uint32 BufferSize, uint32* PathSize) GetSymbolPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Path) SetSymbolPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Addition) AppendSymbolPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Buffer, uint32 BufferSize, uint32* PathSize) GetImagePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Path) SetImagePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Addition) AppendImagePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Buffer, uint32 BufferSize, uint32* PathSize) GetSourcePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ElementSize) GetSourcePathElementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Path) SetSourcePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Addition) AppendSourcePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 StartElement, char16* File, uint32 Flags, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) GetSourceFileLineOffsetsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Index, uint64 Base, char16* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) GetModuleVersionInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Which, uint32 Index, uint64 Base, char16* Buffer, uint32 BufferSize, uint32* NameSize) GetModuleNameStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 TypeId, uint64 Value, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetConstantNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 TypeId, uint32 FieldIndex, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetFieldNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Index, uint64 Base) IsManagedModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) GetModuleByModuleName2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) GetModuleByModuleName2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) GetModuleByOffset2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Base, uint32 Size, char8* ImagePath, char8* ModuleName, uint32 Flags) AddSyntheticModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Base, uint32 Size, char16* ImagePath, char16* ModuleName, uint32 Flags) AddSyntheticModuleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Base) RemoveSyntheticModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, out uint32 Index) GetCurrentScopeFrameIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Index) SetScopeFrameByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 OutputControl, uint64 InfoOffset) SetScopeFromJitDebugInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self) SetScopeFromStoredEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 OutputControl, uint32 Flags, uint64 Offset) OutputSymbolByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BufferNeeded) GetFunctionEntryByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 ContainerTypeId, char8* Field, uint32* FieldTypeId, uint32* Offset) GetFieldTypeAndOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Module, uint32 ContainerTypeId, char16* Field, uint32* FieldTypeId, uint32* Offset) GetFieldTypeAndOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 Size, char8* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) AddSyntheticSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 Size, char16* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) AddSyntheticSymbolWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_MODULE_AND_ID Id) RemoveSyntheticSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint64* Displacements, uint32 IdsCount, uint32* Entries) GetSymbolEntriesByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char8* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) GetSymbolEntriesByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, char16* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) GetSymbolEntriesByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 ModuleBase, uint32 Token, out DEBUG_MODULE_AND_ID Id) GetSymbolEntryByToken;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_MODULE_AND_ID Id, out DEBUG_SYMBOL_ENTRY Info) GetSymbolEntryInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_MODULE_AND_ID Id, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSymbolEntryString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_MODULE_AND_ID Id, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSymbolEntryStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_MODULE_AND_ID Id, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) GetSymbolEntryOffsetRegions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_MODULE_AND_ID FromId, uint32 Flags, out DEBUG_MODULE_AND_ID ToId) GetSymbolEntryBySymbolEntry;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) GetSourceEntriesByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Line, char8* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) GetSourceEntriesByLine;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 Line, char16* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) GetSourceEntriesByLineWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSourceEntryString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSourceEntryStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) GetSourceEntryOffsetRegions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, ref DEBUG_SYMBOL_SOURCE_ENTRY FromEntry, uint32 Flags, out DEBUG_SYMBOL_SOURCE_ENTRY ToEntry) GetSourceEntryBySourceEntry;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64* InstructionOffset, DEBUG_STACK_FRAME_EX* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) GetScopeEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) SetScopeEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 InlineContext, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByInlineContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 InlineContext, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByInlineContextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 InlineContext, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByInlineContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint64 Offset, uint32 InlineContext, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByInlineContextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols4 self, uint32 OutputControl, uint32 Flags, uint64 Offset, uint32 InlineContext) OutputSymbolByInlineContext;
			}
		}
		[CRepr]
		public struct IDebugSymbols5 : IUnknown
		{
			public const new Guid IID = .(0xc65fa83e, 0x1e69, 0x475e, 0x8e, 0x0e, 0xb5, 0xd7, 0x9e, 0x9c, 0xc1, 0x7e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSymbolOptions(out uint32 Options) mut => VT.GetSymbolOptions(ref this, out Options);
			public HResult AddSymbolOptions(uint32 Options) mut => VT.AddSymbolOptions(ref this, Options);
			public HResult RemoveSymbolOptions(uint32 Options) mut => VT.RemoveSymbolOptions(ref this, Options);
			public HResult SetSymbolOptions(uint32 Options) mut => VT.SetSymbolOptions(ref this, Options);
			public HResult GetNameByOffset(uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByOffset(ref this, Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetOffsetByName(char8* Symbol, out uint64 Offset) mut => VT.GetOffsetByName(ref this, Symbol, out Offset);
			public HResult GetNearNameByOffset(uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNearNameByOffset(ref this, Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByOffset(uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByOffset(ref this, Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetOffsetByLine(uint32 Line, char8* File, out uint64 Offset) mut => VT.GetOffsetByLine(ref this, Line, File, out Offset);
			public HResult GetNumberModules(out uint32 Loaded, out uint32 Unloaded) mut => VT.GetNumberModules(ref this, out Loaded, out Unloaded);
			public HResult GetModuleByIndex(uint32 Index, out uint64 Base) mut => VT.GetModuleByIndex(ref this, Index, out Base);
			public HResult GetModuleByModuleName(char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName(ref this, Name, StartIndex, Index, Base);
			public HResult GetModuleByOffset(uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByOffset(ref this, Offset, StartIndex, Index, Base);
			public HResult GetModuleNames(uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) mut => VT.GetModuleNames(ref this, Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
			public HResult GetModuleParameters(uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) mut => VT.GetModuleParameters(ref this, Count, Bases, Start, Params);
			public HResult GetSymbolModule(char8* Symbol, out uint64 Base) mut => VT.GetSymbolModule(ref this, Symbol, out Base);
			public HResult GetTypeName(uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetTypeName(ref this, Module, TypeId, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeId(uint64 Module, char8* Name, out uint32 TypeId) mut => VT.GetTypeId(ref this, Module, Name, out TypeId);
			public HResult GetTypeSize(uint64 Module, uint32 TypeId, out uint32 Size) mut => VT.GetTypeSize(ref this, Module, TypeId, out Size);
			public HResult GetFieldOffset(uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) mut => VT.GetFieldOffset(ref this, Module, TypeId, Field, out Offset);
			public HResult GetSymbolTypeId(char8* Symbol, out uint32 TypeId, uint64* Module) mut => VT.GetSymbolTypeId(ref this, Symbol, out TypeId, Module);
			public HResult GetOffsetTypeId(uint64 Offset, out uint32 TypeId, uint64* Module) mut => VT.GetOffsetTypeId(ref this, Offset, out TypeId, Module);
			public HResult ReadTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataVirtual(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataVirtual(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataVirtual(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataVirtual(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult ReadTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) mut => VT.ReadTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
			public HResult WriteTypedDataPhysical(uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) mut => VT.WriteTypedDataPhysical(ref this, Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
			public HResult OutputTypedDataPhysical(uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) mut => VT.OutputTypedDataPhysical(ref this, OutputControl, Offset, Module, TypeId, Flags);
			public HResult GetScope(uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.GetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult SetScope(uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.SetScope(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult ResetScope() mut => VT.ResetScope(ref this);
			public HResult GetScopeSymbolGroup(uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) mut => VT.GetScopeSymbolGroup(ref this, Flags, Update, out Symbols);
			public HResult CreateSymbolGroup(out IDebugSymbolGroup* Group) mut => VT.CreateSymbolGroup(ref this, out Group);
			public HResult StartSymbolMatch(char8* Pattern, out uint64 Handle) mut => VT.StartSymbolMatch(ref this, Pattern, out Handle);
			public HResult GetNextSymbolMatch(uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) mut => VT.GetNextSymbolMatch(ref this, Handle, Buffer, BufferSize, MatchSize, Offset);
			public HResult EndSymbolMatch(uint64 Handle) mut => VT.EndSymbolMatch(ref this, Handle);
			public HResult Reload(char8* Module) mut => VT.Reload(ref this, Module);
			public HResult GetSymbolPath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSymbolPath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetSymbolPath(char8* Path) mut => VT.SetSymbolPath(ref this, Path);
			public HResult AppendSymbolPath(char8* Addition) mut => VT.AppendSymbolPath(ref this, Addition);
			public HResult GetImagePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetImagePath(ref this, Buffer, BufferSize, PathSize);
			public HResult SetImagePath(char8* Path) mut => VT.SetImagePath(ref this, Path);
			public HResult AppendImagePath(char8* Addition) mut => VT.AppendImagePath(ref this, Addition);
			public HResult GetSourcePath(uint8* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSourcePath(ref this, Buffer, BufferSize, PathSize);
			public HResult GetSourcePathElement(uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) mut => VT.GetSourcePathElement(ref this, Index, Buffer, BufferSize, ElementSize);
			public HResult SetSourcePath(char8* Path) mut => VT.SetSourcePath(ref this, Path);
			public HResult AppendSourcePath(char8* Addition) mut => VT.AppendSourcePath(ref this, Addition);
			public HResult FindSourceFile(uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFile(ref this, StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSourceFileLineOffsets(char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) mut => VT.GetSourceFileLineOffsets(ref this, File, Buffer, BufferLines, FileLines);
			public HResult GetModuleVersionInformation(uint32 Index, uint64 Base, char8* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) mut => VT.GetModuleVersionInformation(ref this, Index, Base, Item, Buffer, BufferSize, VerInfoSize);
			public HResult GetModuleNameString(uint32 Which, uint32 Index, uint64 Base, uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetModuleNameString(ref this, Which, Index, Base, Buffer, BufferSize, NameSize);
			public HResult GetConstantName(uint64 Module, uint32 TypeId, uint64 Value, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetConstantName(ref this, Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
			public HResult GetFieldName(uint64 Module, uint32 TypeId, uint32 FieldIndex, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetFieldName(ref this, Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeOptions(out uint32 Options) mut => VT.GetTypeOptions(ref this, out Options);
			public HResult AddTypeOptions(uint32 Options) mut => VT.AddTypeOptions(ref this, Options);
			public HResult RemoveTypeOptions(uint32 Options) mut => VT.RemoveTypeOptions(ref this, Options);
			public HResult SetTypeOptions(uint32 Options) mut => VT.SetTypeOptions(ref this, Options);
			public HResult GetNameByOffsetWide(uint64 Offset, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByOffsetWide(ref this, Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetOffsetByNameWide(char16* Symbol, out uint64 Offset) mut => VT.GetOffsetByNameWide(ref this, Symbol, out Offset);
			public HResult GetNearNameByOffsetWide(uint64 Offset, int32 Delta, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNearNameByOffsetWide(ref this, Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByOffsetWide(uint64 Offset, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByOffsetWide(ref this, Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetOffsetByLineWide(uint32 Line, char16* File, out uint64 Offset) mut => VT.GetOffsetByLineWide(ref this, Line, File, out Offset);
			public HResult GetModuleByModuleNameWide(char16* Name, uint32 StartIndex, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleNameWide(ref this, Name, StartIndex, Index, Base);
			public HResult GetSymbolModuleWide(char16* Symbol, out uint64 Base) mut => VT.GetSymbolModuleWide(ref this, Symbol, out Base);
			public HResult GetTypeNameWide(uint64 Module, uint32 TypeId, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetTypeNameWide(ref this, Module, TypeId, NameBuffer, NameBufferSize, NameSize);
			public HResult GetTypeIdWide(uint64 Module, char16* Name, out uint32 TypeId) mut => VT.GetTypeIdWide(ref this, Module, Name, out TypeId);
			public HResult GetFieldOffsetWide(uint64 Module, uint32 TypeId, char16* Field, out uint32 Offset) mut => VT.GetFieldOffsetWide(ref this, Module, TypeId, Field, out Offset);
			public HResult GetSymbolTypeIdWide(char16* Symbol, out uint32 TypeId, uint64* Module) mut => VT.GetSymbolTypeIdWide(ref this, Symbol, out TypeId, Module);
			public HResult GetScopeSymbolGroup2(uint32 Flags, IDebugSymbolGroup2* Update, out IDebugSymbolGroup2* Symbols) mut => VT.GetScopeSymbolGroup2(ref this, Flags, Update, out Symbols);
			public HResult CreateSymbolGroup2(out IDebugSymbolGroup2* Group) mut => VT.CreateSymbolGroup2(ref this, out Group);
			public HResult StartSymbolMatchWide(char16* Pattern, out uint64 Handle) mut => VT.StartSymbolMatchWide(ref this, Pattern, out Handle);
			public HResult GetNextSymbolMatchWide(uint64 Handle, char16* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) mut => VT.GetNextSymbolMatchWide(ref this, Handle, Buffer, BufferSize, MatchSize, Offset);
			public HResult ReloadWide(char16* Module) mut => VT.ReloadWide(ref this, Module);
			public HResult GetSymbolPathWide(char16* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSymbolPathWide(ref this, Buffer, BufferSize, PathSize);
			public HResult SetSymbolPathWide(char16* Path) mut => VT.SetSymbolPathWide(ref this, Path);
			public HResult AppendSymbolPathWide(char16* Addition) mut => VT.AppendSymbolPathWide(ref this, Addition);
			public HResult GetImagePathWide(char16* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetImagePathWide(ref this, Buffer, BufferSize, PathSize);
			public HResult SetImagePathWide(char16* Path) mut => VT.SetImagePathWide(ref this, Path);
			public HResult AppendImagePathWide(char16* Addition) mut => VT.AppendImagePathWide(ref this, Addition);
			public HResult GetSourcePathWide(char16* Buffer, uint32 BufferSize, uint32* PathSize) mut => VT.GetSourcePathWide(ref this, Buffer, BufferSize, PathSize);
			public HResult GetSourcePathElementWide(uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ElementSize) mut => VT.GetSourcePathElementWide(ref this, Index, Buffer, BufferSize, ElementSize);
			public HResult SetSourcePathWide(char16* Path) mut => VT.SetSourcePathWide(ref this, Path);
			public HResult AppendSourcePathWide(char16* Addition) mut => VT.AppendSourcePathWide(ref this, Addition);
			public HResult FindSourceFileWide(uint32 StartElement, char16* File, uint32 Flags, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) mut => VT.FindSourceFileWide(ref this, StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
			public HResult GetSourceFileLineOffsetsWide(char16* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) mut => VT.GetSourceFileLineOffsetsWide(ref this, File, Buffer, BufferLines, FileLines);
			public HResult GetModuleVersionInformationWide(uint32 Index, uint64 Base, char16* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) mut => VT.GetModuleVersionInformationWide(ref this, Index, Base, Item, Buffer, BufferSize, VerInfoSize);
			public HResult GetModuleNameStringWide(uint32 Which, uint32 Index, uint64 Base, char16* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetModuleNameStringWide(ref this, Which, Index, Base, Buffer, BufferSize, NameSize);
			public HResult GetConstantNameWide(uint64 Module, uint32 TypeId, uint64 Value, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetConstantNameWide(ref this, Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
			public HResult GetFieldNameWide(uint64 Module, uint32 TypeId, uint32 FieldIndex, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) mut => VT.GetFieldNameWide(ref this, Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
			public HResult IsManagedModule(uint32 Index, uint64 Base) mut => VT.IsManagedModule(ref this, Index, Base);
			public HResult GetModuleByModuleName2(char8* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName2(ref this, Name, StartIndex, Flags, Index, Base);
			public HResult GetModuleByModuleName2Wide(char16* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) mut => VT.GetModuleByModuleName2Wide(ref this, Name, StartIndex, Flags, Index, Base);
			public HResult GetModuleByOffset2(uint64 Offset, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) mut => VT.GetModuleByOffset2(ref this, Offset, StartIndex, Flags, Index, Base);
			public HResult AddSyntheticModule(uint64 Base, uint32 Size, char8* ImagePath, char8* ModuleName, uint32 Flags) mut => VT.AddSyntheticModule(ref this, Base, Size, ImagePath, ModuleName, Flags);
			public HResult AddSyntheticModuleWide(uint64 Base, uint32 Size, char16* ImagePath, char16* ModuleName, uint32 Flags) mut => VT.AddSyntheticModuleWide(ref this, Base, Size, ImagePath, ModuleName, Flags);
			public HResult RemoveSyntheticModule(uint64 Base) mut => VT.RemoveSyntheticModule(ref this, Base);
			public HResult GetCurrentScopeFrameIndex(out uint32 Index) mut => VT.GetCurrentScopeFrameIndex(ref this, out Index);
			public HResult SetScopeFrameByIndex(uint32 Index) mut => VT.SetScopeFrameByIndex(ref this, Index);
			public HResult SetScopeFromJitDebugInfo(uint32 OutputControl, uint64 InfoOffset) mut => VT.SetScopeFromJitDebugInfo(ref this, OutputControl, InfoOffset);
			public HResult SetScopeFromStoredEvent() mut => VT.SetScopeFromStoredEvent(ref this);
			public HResult OutputSymbolByOffset(uint32 OutputControl, uint32 Flags, uint64 Offset) mut => VT.OutputSymbolByOffset(ref this, OutputControl, Flags, Offset);
			public HResult GetFunctionEntryByOffset(uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BufferNeeded) mut => VT.GetFunctionEntryByOffset(ref this, Offset, Flags, Buffer, BufferSize, BufferNeeded);
			public HResult GetFieldTypeAndOffset(uint64 Module, uint32 ContainerTypeId, char8* Field, uint32* FieldTypeId, uint32* Offset) mut => VT.GetFieldTypeAndOffset(ref this, Module, ContainerTypeId, Field, FieldTypeId, Offset);
			public HResult GetFieldTypeAndOffsetWide(uint64 Module, uint32 ContainerTypeId, char16* Field, uint32* FieldTypeId, uint32* Offset) mut => VT.GetFieldTypeAndOffsetWide(ref this, Module, ContainerTypeId, Field, FieldTypeId, Offset);
			public HResult AddSyntheticSymbol(uint64 Offset, uint32 Size, char8* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) mut => VT.AddSyntheticSymbol(ref this, Offset, Size, Name, Flags, Id);
			public HResult AddSyntheticSymbolWide(uint64 Offset, uint32 Size, char16* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) mut => VT.AddSyntheticSymbolWide(ref this, Offset, Size, Name, Flags, Id);
			public HResult RemoveSyntheticSymbol(ref DEBUG_MODULE_AND_ID Id) mut => VT.RemoveSyntheticSymbol(ref this, ref Id);
			public HResult GetSymbolEntriesByOffset(uint64 Offset, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint64* Displacements, uint32 IdsCount, uint32* Entries) mut => VT.GetSymbolEntriesByOffset(ref this, Offset, Flags, Ids, Displacements, IdsCount, Entries);
			public HResult GetSymbolEntriesByName(char8* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) mut => VT.GetSymbolEntriesByName(ref this, Symbol, Flags, Ids, IdsCount, Entries);
			public HResult GetSymbolEntriesByNameWide(char16* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) mut => VT.GetSymbolEntriesByNameWide(ref this, Symbol, Flags, Ids, IdsCount, Entries);
			public HResult GetSymbolEntryByToken(uint64 ModuleBase, uint32 Token, out DEBUG_MODULE_AND_ID Id) mut => VT.GetSymbolEntryByToken(ref this, ModuleBase, Token, out Id);
			public HResult GetSymbolEntryInformation(ref DEBUG_MODULE_AND_ID Id, out DEBUG_SYMBOL_ENTRY Info) mut => VT.GetSymbolEntryInformation(ref this, ref Id, out Info);
			public HResult GetSymbolEntryString(ref DEBUG_MODULE_AND_ID Id, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSymbolEntryString(ref this, ref Id, Which, Buffer, BufferSize, StringSize);
			public HResult GetSymbolEntryStringWide(ref DEBUG_MODULE_AND_ID Id, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSymbolEntryStringWide(ref this, ref Id, Which, Buffer, BufferSize, StringSize);
			public HResult GetSymbolEntryOffsetRegions(ref DEBUG_MODULE_AND_ID Id, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) mut => VT.GetSymbolEntryOffsetRegions(ref this, ref Id, Flags, Regions, RegionsCount, RegionsAvail);
			public HResult GetSymbolEntryBySymbolEntry(ref DEBUG_MODULE_AND_ID FromId, uint32 Flags, out DEBUG_MODULE_AND_ID ToId) mut => VT.GetSymbolEntryBySymbolEntry(ref this, ref FromId, Flags, out ToId);
			public HResult GetSourceEntriesByOffset(uint64 Offset, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) mut => VT.GetSourceEntriesByOffset(ref this, Offset, Flags, Entries, EntriesCount, EntriesAvail);
			public HResult GetSourceEntriesByLine(uint32 Line, char8* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) mut => VT.GetSourceEntriesByLine(ref this, Line, File, Flags, Entries, EntriesCount, EntriesAvail);
			public HResult GetSourceEntriesByLineWide(uint32 Line, char16* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) mut => VT.GetSourceEntriesByLineWide(ref this, Line, File, Flags, Entries, EntriesCount, EntriesAvail);
			public HResult GetSourceEntryString(ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSourceEntryString(ref this, ref Entry, Which, Buffer, BufferSize, StringSize);
			public HResult GetSourceEntryStringWide(ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) mut => VT.GetSourceEntryStringWide(ref this, ref Entry, Which, Buffer, BufferSize, StringSize);
			public HResult GetSourceEntryOffsetRegions(ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) mut => VT.GetSourceEntryOffsetRegions(ref this, ref Entry, Flags, Regions, RegionsCount, RegionsAvail);
			public HResult GetSourceEntryBySourceEntry(ref DEBUG_SYMBOL_SOURCE_ENTRY FromEntry, uint32 Flags, out DEBUG_SYMBOL_SOURCE_ENTRY ToEntry) mut => VT.GetSourceEntryBySourceEntry(ref this, ref FromEntry, Flags, out ToEntry);
			public HResult GetScopeEx(uint64* InstructionOffset, DEBUG_STACK_FRAME_EX* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.GetScopeEx(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult SetScopeEx(uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) mut => VT.SetScopeEx(ref this, InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
			public HResult GetNameByInlineContext(uint64 Offset, uint32 InlineContext, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByInlineContext(ref this, Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetNameByInlineContextWide(uint64 Offset, uint32 InlineContext, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) mut => VT.GetNameByInlineContextWide(ref this, Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
			public HResult GetLineByInlineContext(uint64 Offset, uint32 InlineContext, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByInlineContext(ref this, Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult GetLineByInlineContextWide(uint64 Offset, uint32 InlineContext, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) mut => VT.GetLineByInlineContextWide(ref this, Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
			public HResult OutputSymbolByInlineContext(uint32 OutputControl, uint32 Flags, uint64 Offset, uint32 InlineContext) mut => VT.OutputSymbolByInlineContext(ref this, OutputControl, Flags, Offset, InlineContext);
			public HResult GetCurrentScopeFrameIndexEx(uint32 Flags, out uint32 Index) mut => VT.GetCurrentScopeFrameIndexEx(ref this, Flags, out Index);
			public HResult SetScopeFrameByIndexEx(uint32 Flags, uint32 Index) mut => VT.SetScopeFrameByIndexEx(ref this, Flags, Index);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, out uint32 Options) GetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Options) AddSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Options) RemoveSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Options) SetSymbolOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Symbol, out uint64 Offset) GetOffsetByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, int32 Delta, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNearNameByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Line, char8* File, out uint64 Offset) GetOffsetByLine;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, out uint32 Loaded, out uint32 Unloaded) GetNumberModules;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Index, out uint64 Base) GetModuleByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Name, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByModuleName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Index, uint64 Base, uint8* ImageNameBuffer, uint32 ImageNameBufferSize, uint32* ImageNameSize, uint8* ModuleNameBuffer, uint32 ModuleNameBufferSize, uint32* ModuleNameSize, uint8* LoadedImageNameBuffer, uint32 LoadedImageNameBufferSize, uint32* LoadedImageNameSize) GetModuleNames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Count, uint64* Bases, uint32 Start, DEBUG_MODULE_PARAMETERS* Params) GetModuleParameters;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Symbol, out uint64 Base) GetSymbolModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 TypeId, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetTypeName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, char8* Name, out uint32 TypeId) GetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 TypeId, out uint32 Size) GetTypeSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 TypeId, char8* Field, out uint32 Offset) GetFieldOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Symbol, out uint32 TypeId, uint64* Module) GetSymbolTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, out uint32 TypeId, uint64* Module) GetOffsetTypeId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataVirtual;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesRead) ReadTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint64 Module, uint32 TypeId, void* Buffer, uint32 BufferSize, uint32* BytesWritten) WriteTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 OutputControl, uint64 Offset, uint64 Module, uint32 TypeId, uint32 Flags) OutputTypedDataPhysical;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64* InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) GetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 InstructionOffset, DEBUG_STACK_FRAME* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) SetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self) ResetScope;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Flags, IDebugSymbolGroup* Update, out IDebugSymbolGroup* Symbols) GetScopeSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, out IDebugSymbolGroup* Group) CreateSymbolGroup;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Pattern, out uint64 Handle) StartSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Handle, uint8* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) GetNextSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Handle) EndSymbolMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Module) Reload;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Path) SetSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Addition) AppendSymbolPath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Path) SetImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Addition) AppendImagePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint8* Buffer, uint32 BufferSize, uint32* PathSize) GetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Index, uint8* Buffer, uint32 BufferSize, uint32* ElementSize) GetSourcePathElement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Path) SetSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Addition) AppendSourcePath;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 StartElement, char8* File, uint32 Flags, uint32* FoundElement, uint8* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFile;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) GetSourceFileLineOffsets;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Index, uint64 Base, char8* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) GetModuleVersionInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Which, uint32 Index, uint64 Base, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetModuleNameString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 TypeId, uint64 Value, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetConstantName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 TypeId, uint32 FieldIndex, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetFieldName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, out uint32 Options) GetTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Options) AddTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Options) RemoveTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Options) SetTypeOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Symbol, out uint64 Offset) GetOffsetByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, int32 Delta, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNearNameByOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Line, char16* File, out uint64 Offset) GetOffsetByLineWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Name, uint32 StartIndex, uint32* Index, uint64* Base) GetModuleByModuleNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Symbol, out uint64 Base) GetSymbolModuleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 TypeId, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetTypeNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, char16* Name, out uint32 TypeId) GetTypeIdWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 TypeId, char16* Field, out uint32 Offset) GetFieldOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Symbol, out uint32 TypeId, uint64* Module) GetSymbolTypeIdWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Flags, IDebugSymbolGroup2* Update, out IDebugSymbolGroup2* Symbols) GetScopeSymbolGroup2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, out IDebugSymbolGroup2* Group) CreateSymbolGroup2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Pattern, out uint64 Handle) StartSymbolMatchWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Handle, char16* Buffer, uint32 BufferSize, uint32* MatchSize, uint64* Offset) GetNextSymbolMatchWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Module) ReloadWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Buffer, uint32 BufferSize, uint32* PathSize) GetSymbolPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Path) SetSymbolPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Addition) AppendSymbolPathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Buffer, uint32 BufferSize, uint32* PathSize) GetImagePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Path) SetImagePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Addition) AppendImagePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Buffer, uint32 BufferSize, uint32* PathSize) GetSourcePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Index, char16* Buffer, uint32 BufferSize, uint32* ElementSize) GetSourcePathElementWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Path) SetSourcePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Addition) AppendSourcePathWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 StartElement, char16* File, uint32 Flags, uint32* FoundElement, char16* Buffer, uint32 BufferSize, uint32* FoundSize) FindSourceFileWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* File, uint64* Buffer, uint32 BufferLines, uint32* FileLines) GetSourceFileLineOffsetsWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Index, uint64 Base, char16* Item, void* Buffer, uint32 BufferSize, uint32* VerInfoSize) GetModuleVersionInformationWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Which, uint32 Index, uint64 Base, char16* Buffer, uint32 BufferSize, uint32* NameSize) GetModuleNameStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 TypeId, uint64 Value, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetConstantNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 TypeId, uint32 FieldIndex, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize) GetFieldNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Index, uint64 Base) IsManagedModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) GetModuleByModuleName2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Name, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) GetModuleByModuleName2Wide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 StartIndex, uint32 Flags, uint32* Index, uint64* Base) GetModuleByOffset2;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Base, uint32 Size, char8* ImagePath, char8* ModuleName, uint32 Flags) AddSyntheticModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Base, uint32 Size, char16* ImagePath, char16* ModuleName, uint32 Flags) AddSyntheticModuleWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Base) RemoveSyntheticModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, out uint32 Index) GetCurrentScopeFrameIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Index) SetScopeFrameByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 OutputControl, uint64 InfoOffset) SetScopeFromJitDebugInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self) SetScopeFromStoredEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 OutputControl, uint32 Flags, uint64 Offset) OutputSymbolByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 Flags, void* Buffer, uint32 BufferSize, uint32* BufferNeeded) GetFunctionEntryByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 ContainerTypeId, char8* Field, uint32* FieldTypeId, uint32* Offset) GetFieldTypeAndOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Module, uint32 ContainerTypeId, char16* Field, uint32* FieldTypeId, uint32* Offset) GetFieldTypeAndOffsetWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 Size, char8* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) AddSyntheticSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 Size, char16* Name, uint32 Flags, DEBUG_MODULE_AND_ID* Id) AddSyntheticSymbolWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_MODULE_AND_ID Id) RemoveSyntheticSymbol;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint64* Displacements, uint32 IdsCount, uint32* Entries) GetSymbolEntriesByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char8* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) GetSymbolEntriesByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, char16* Symbol, uint32 Flags, DEBUG_MODULE_AND_ID* Ids, uint32 IdsCount, uint32* Entries) GetSymbolEntriesByNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 ModuleBase, uint32 Token, out DEBUG_MODULE_AND_ID Id) GetSymbolEntryByToken;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_MODULE_AND_ID Id, out DEBUG_SYMBOL_ENTRY Info) GetSymbolEntryInformation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_MODULE_AND_ID Id, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSymbolEntryString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_MODULE_AND_ID Id, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSymbolEntryStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_MODULE_AND_ID Id, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) GetSymbolEntryOffsetRegions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_MODULE_AND_ID FromId, uint32 Flags, out DEBUG_MODULE_AND_ID ToId) GetSymbolEntryBySymbolEntry;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) GetSourceEntriesByOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Line, char8* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) GetSourceEntriesByLine;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Line, char16* File, uint32 Flags, DEBUG_SYMBOL_SOURCE_ENTRY* Entries, uint32 EntriesCount, uint32* EntriesAvail) GetSourceEntriesByLineWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, uint8* Buffer, uint32 BufferSize, uint32* StringSize) GetSourceEntryString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Which, char16* Buffer, uint32 BufferSize, uint32* StringSize) GetSourceEntryStringWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_SYMBOL_SOURCE_ENTRY Entry, uint32 Flags, DEBUG_OFFSET_REGION* Regions, uint32 RegionsCount, uint32* RegionsAvail) GetSourceEntryOffsetRegions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, ref DEBUG_SYMBOL_SOURCE_ENTRY FromEntry, uint32 Flags, out DEBUG_SYMBOL_SOURCE_ENTRY ToEntry) GetSourceEntryBySourceEntry;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64* InstructionOffset, DEBUG_STACK_FRAME_EX* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) GetScopeEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 InstructionOffset, DEBUG_STACK_FRAME_EX* ScopeFrame, void* ScopeContext, uint32 ScopeContextSize) SetScopeEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 InlineContext, uint8* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByInlineContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 InlineContext, char16* NameBuffer, uint32 NameBufferSize, uint32* NameSize, uint64* Displacement) GetNameByInlineContextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 InlineContext, uint32* Line, uint8* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByInlineContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint64 Offset, uint32 InlineContext, uint32* Line, char16* FileBuffer, uint32 FileBufferSize, uint32* FileSize, uint64* Displacement) GetLineByInlineContextWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 OutputControl, uint32 Flags, uint64 Offset, uint32 InlineContext) OutputSymbolByInlineContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Flags, out uint32 Index) GetCurrentScopeFrameIndexEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSymbols5 self, uint32 Flags, uint32 Index) SetScopeFrameByIndexEx;
			}
		}
		[CRepr]
		public struct IDebugSystemObjects : IUnknown
		{
			public const new Guid IID = .(0x6b86fe2c, 0x2c4f, 0x4f0c, 0x9d, 0xa2, 0x17, 0x43, 0x11, 0xac, 0xc3, 0x27);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetEventThread(out uint32 Id) mut => VT.GetEventThread(ref this, out Id);
			public HResult GetEventProcess(out uint32 Id) mut => VT.GetEventProcess(ref this, out Id);
			public HResult GetCurrentThreadId(out uint32 Id) mut => VT._GetCurrentThreadId(ref this, out Id);
			public HResult SetCurrentThreadId(uint32 Id) mut => VT.SetCurrentThreadId(ref this, Id);
			public HResult GetCurrentProcessId(out uint32 Id) mut => VT._GetCurrentProcessId(ref this, out Id);
			public HResult SetCurrentProcessId(uint32 Id) mut => VT.SetCurrentProcessId(ref this, Id);
			public HResult GetNumberThreads(out uint32 Number) mut => VT.GetNumberThreads(ref this, out Number);
			public HResult GetTotalNumberThreads(out uint32 Total, out uint32 LargestProcess) mut => VT.GetTotalNumberThreads(ref this, out Total, out LargestProcess);
			public HResult GetThreadIdsByIndex(uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) mut => VT.GetThreadIdsByIndex(ref this, Start, Count, Ids, SysIds);
			public HResult GetThreadIdByProcessor(uint32 Processor, out uint32 Id) mut => VT.GetThreadIdByProcessor(ref this, Processor, out Id);
			public HResult GetCurrentThreadDataOffset(out uint64 Offset) mut => VT.GetCurrentThreadDataOffset(ref this, out Offset);
			public HResult GetThreadIdByDataOffset(uint64 Offset, out uint32 Id) mut => VT.GetThreadIdByDataOffset(ref this, Offset, out Id);
			public HResult GetCurrentThreadTeb(out uint64 Offset) mut => VT.GetCurrentThreadTeb(ref this, out Offset);
			public HResult GetThreadIdByTeb(uint64 Offset, out uint32 Id) mut => VT.GetThreadIdByTeb(ref this, Offset, out Id);
			public HResult GetCurrentThreadSystemId(out uint32 SysId) mut => VT.GetCurrentThreadSystemId(ref this, out SysId);
			public HResult GetThreadIdBySystemId(uint32 SysId, out uint32 Id) mut => VT.GetThreadIdBySystemId(ref this, SysId, out Id);
			public HResult GetCurrentThreadHandle(out uint64 Handle) mut => VT.GetCurrentThreadHandle(ref this, out Handle);
			public HResult GetThreadIdByHandle(uint64 Handle, out uint32 Id) mut => VT.GetThreadIdByHandle(ref this, Handle, out Id);
			public HResult GetNumberProcesses(out uint32 Number) mut => VT.GetNumberProcesses(ref this, out Number);
			public HResult GetProcessIdsByIndex(uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) mut => VT.GetProcessIdsByIndex(ref this, Start, Count, Ids, SysIds);
			public HResult GetCurrentProcessDataOffset(out uint64 Offset) mut => VT.GetCurrentProcessDataOffset(ref this, out Offset);
			public HResult GetProcessIdByDataOffset(uint64 Offset, out uint32 Id) mut => VT.GetProcessIdByDataOffset(ref this, Offset, out Id);
			public HResult GetCurrentProcessPeb(out uint64 Offset) mut => VT.GetCurrentProcessPeb(ref this, out Offset);
			public HResult GetProcessIdByPeb(uint64 Offset, out uint32 Id) mut => VT.GetProcessIdByPeb(ref this, Offset, out Id);
			public HResult GetCurrentProcessSystemId(out uint32 SysId) mut => VT.GetCurrentProcessSystemId(ref this, out SysId);
			public HResult GetProcessIdBySystemId(uint32 SysId, out uint32 Id) mut => VT.GetProcessIdBySystemId(ref this, SysId, out Id);
			public HResult GetCurrentProcessHandle(out uint64 Handle) mut => VT.GetCurrentProcessHandle(ref this, out Handle);
			public HResult GetProcessIdByHandle(uint64 Handle, out uint32 Id) mut => VT.GetProcessIdByHandle(ref this, Handle, out Id);
			public HResult GetCurrentProcessExecutableName(uint8* Buffer, uint32 BufferSize, uint32* ExeSize) mut => VT.GetCurrentProcessExecutableName(ref this, Buffer, BufferSize, ExeSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint32 Id) GetEventThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint32 Id) GetEventProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint32 Id) _GetCurrentThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint32 Id) SetCurrentThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint32 Id) _GetCurrentProcessId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint32 Id) SetCurrentProcessId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint32 Number) GetNumberThreads;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint32 Total, out uint32 LargestProcess) GetTotalNumberThreads;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) GetThreadIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint32 Processor, out uint32 Id) GetThreadIdByProcessor;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint64 Offset) GetCurrentThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint64 Offset, out uint32 Id) GetThreadIdByDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint64 Offset) GetCurrentThreadTeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint64 Offset, out uint32 Id) GetThreadIdByTeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint32 SysId) GetCurrentThreadSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint32 SysId, out uint32 Id) GetThreadIdBySystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint64 Handle) GetCurrentThreadHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint64 Handle, out uint32 Id) GetThreadIdByHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint32 Number) GetNumberProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) GetProcessIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint64 Offset) GetCurrentProcessDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint64 Offset, out uint32 Id) GetProcessIdByDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint64 Offset) GetCurrentProcessPeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint64 Offset, out uint32 Id) GetProcessIdByPeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint32 SysId) GetCurrentProcessSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint32 SysId, out uint32 Id) GetProcessIdBySystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, out uint64 Handle) GetCurrentProcessHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint64 Handle, out uint32 Id) GetProcessIdByHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects self, uint8* Buffer, uint32 BufferSize, uint32* ExeSize) GetCurrentProcessExecutableName;
			}
		}
		[CRepr]
		public struct IDebugSystemObjects2 : IUnknown
		{
			public const new Guid IID = .(0x0ae9f5ff, 0x1852, 0x4679, 0xb0, 0x55, 0x49, 0x4b, 0xee, 0x64, 0x07, 0xee);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetEventThread(out uint32 Id) mut => VT.GetEventThread(ref this, out Id);
			public HResult GetEventProcess(out uint32 Id) mut => VT.GetEventProcess(ref this, out Id);
			public HResult GetCurrentThreadId(out uint32 Id) mut => VT._GetCurrentThreadId(ref this, out Id);
			public HResult SetCurrentThreadId(uint32 Id) mut => VT.SetCurrentThreadId(ref this, Id);
			public HResult GetCurrentProcessId(out uint32 Id) mut => VT._GetCurrentProcessId(ref this, out Id);
			public HResult SetCurrentProcessId(uint32 Id) mut => VT.SetCurrentProcessId(ref this, Id);
			public HResult GetNumberThreads(out uint32 Number) mut => VT.GetNumberThreads(ref this, out Number);
			public HResult GetTotalNumberThreads(out uint32 Total, out uint32 LargestProcess) mut => VT.GetTotalNumberThreads(ref this, out Total, out LargestProcess);
			public HResult GetThreadIdsByIndex(uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) mut => VT.GetThreadIdsByIndex(ref this, Start, Count, Ids, SysIds);
			public HResult GetThreadIdByProcessor(uint32 Processor, out uint32 Id) mut => VT.GetThreadIdByProcessor(ref this, Processor, out Id);
			public HResult GetCurrentThreadDataOffset(out uint64 Offset) mut => VT.GetCurrentThreadDataOffset(ref this, out Offset);
			public HResult GetThreadIdByDataOffset(uint64 Offset, out uint32 Id) mut => VT.GetThreadIdByDataOffset(ref this, Offset, out Id);
			public HResult GetCurrentThreadTeb(out uint64 Offset) mut => VT.GetCurrentThreadTeb(ref this, out Offset);
			public HResult GetThreadIdByTeb(uint64 Offset, out uint32 Id) mut => VT.GetThreadIdByTeb(ref this, Offset, out Id);
			public HResult GetCurrentThreadSystemId(out uint32 SysId) mut => VT.GetCurrentThreadSystemId(ref this, out SysId);
			public HResult GetThreadIdBySystemId(uint32 SysId, out uint32 Id) mut => VT.GetThreadIdBySystemId(ref this, SysId, out Id);
			public HResult GetCurrentThreadHandle(out uint64 Handle) mut => VT.GetCurrentThreadHandle(ref this, out Handle);
			public HResult GetThreadIdByHandle(uint64 Handle, out uint32 Id) mut => VT.GetThreadIdByHandle(ref this, Handle, out Id);
			public HResult GetNumberProcesses(out uint32 Number) mut => VT.GetNumberProcesses(ref this, out Number);
			public HResult GetProcessIdsByIndex(uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) mut => VT.GetProcessIdsByIndex(ref this, Start, Count, Ids, SysIds);
			public HResult GetCurrentProcessDataOffset(out uint64 Offset) mut => VT.GetCurrentProcessDataOffset(ref this, out Offset);
			public HResult GetProcessIdByDataOffset(uint64 Offset, out uint32 Id) mut => VT.GetProcessIdByDataOffset(ref this, Offset, out Id);
			public HResult GetCurrentProcessPeb(out uint64 Offset) mut => VT.GetCurrentProcessPeb(ref this, out Offset);
			public HResult GetProcessIdByPeb(uint64 Offset, out uint32 Id) mut => VT.GetProcessIdByPeb(ref this, Offset, out Id);
			public HResult GetCurrentProcessSystemId(out uint32 SysId) mut => VT.GetCurrentProcessSystemId(ref this, out SysId);
			public HResult GetProcessIdBySystemId(uint32 SysId, out uint32 Id) mut => VT.GetProcessIdBySystemId(ref this, SysId, out Id);
			public HResult GetCurrentProcessHandle(out uint64 Handle) mut => VT.GetCurrentProcessHandle(ref this, out Handle);
			public HResult GetProcessIdByHandle(uint64 Handle, out uint32 Id) mut => VT.GetProcessIdByHandle(ref this, Handle, out Id);
			public HResult GetCurrentProcessExecutableName(uint8* Buffer, uint32 BufferSize, uint32* ExeSize) mut => VT.GetCurrentProcessExecutableName(ref this, Buffer, BufferSize, ExeSize);
			public HResult GetCurrentProcessUpTime(out uint32 UpTime) mut => VT.GetCurrentProcessUpTime(ref this, out UpTime);
			public HResult GetImplicitThreadDataOffset(out uint64 Offset) mut => VT.GetImplicitThreadDataOffset(ref this, out Offset);
			public HResult SetImplicitThreadDataOffset(uint64 Offset) mut => VT.SetImplicitThreadDataOffset(ref this, Offset);
			public HResult GetImplicitProcessDataOffset(out uint64 Offset) mut => VT.GetImplicitProcessDataOffset(ref this, out Offset);
			public HResult SetImplicitProcessDataOffset(uint64 Offset) mut => VT.SetImplicitProcessDataOffset(ref this, Offset);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 Id) GetEventThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 Id) GetEventProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 Id) _GetCurrentThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint32 Id) SetCurrentThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 Id) _GetCurrentProcessId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint32 Id) SetCurrentProcessId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 Number) GetNumberThreads;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 Total, out uint32 LargestProcess) GetTotalNumberThreads;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) GetThreadIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint32 Processor, out uint32 Id) GetThreadIdByProcessor;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint64 Offset) GetCurrentThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint64 Offset, out uint32 Id) GetThreadIdByDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint64 Offset) GetCurrentThreadTeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint64 Offset, out uint32 Id) GetThreadIdByTeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 SysId) GetCurrentThreadSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint32 SysId, out uint32 Id) GetThreadIdBySystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint64 Handle) GetCurrentThreadHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint64 Handle, out uint32 Id) GetThreadIdByHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 Number) GetNumberProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) GetProcessIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint64 Offset) GetCurrentProcessDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint64 Offset, out uint32 Id) GetProcessIdByDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint64 Offset) GetCurrentProcessPeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint64 Offset, out uint32 Id) GetProcessIdByPeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 SysId) GetCurrentProcessSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint32 SysId, out uint32 Id) GetProcessIdBySystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint64 Handle) GetCurrentProcessHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint64 Handle, out uint32 Id) GetProcessIdByHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint8* Buffer, uint32 BufferSize, uint32* ExeSize) GetCurrentProcessExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint32 UpTime) GetCurrentProcessUpTime;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint64 Offset) GetImplicitThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint64 Offset) SetImplicitThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, out uint64 Offset) GetImplicitProcessDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects2 self, uint64 Offset) SetImplicitProcessDataOffset;
			}
		}
		[CRepr]
		public struct IDebugSystemObjects3 : IUnknown
		{
			public const new Guid IID = .(0xe9676e2f, 0xe286, 0x4ea3, 0xb0, 0xf9, 0xdf, 0xe5, 0xd9, 0xfc, 0x33, 0x0e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetEventThread(out uint32 Id) mut => VT.GetEventThread(ref this, out Id);
			public HResult GetEventProcess(out uint32 Id) mut => VT.GetEventProcess(ref this, out Id);
			public HResult GetCurrentThreadId(out uint32 Id) mut => VT._GetCurrentThreadId(ref this, out Id);
			public HResult SetCurrentThreadId(uint32 Id) mut => VT.SetCurrentThreadId(ref this, Id);
			public HResult GetCurrentProcessId(out uint32 Id) mut => VT._GetCurrentProcessId(ref this, out Id);
			public HResult SetCurrentProcessId(uint32 Id) mut => VT.SetCurrentProcessId(ref this, Id);
			public HResult GetNumberThreads(out uint32 Number) mut => VT.GetNumberThreads(ref this, out Number);
			public HResult GetTotalNumberThreads(out uint32 Total, out uint32 LargestProcess) mut => VT.GetTotalNumberThreads(ref this, out Total, out LargestProcess);
			public HResult GetThreadIdsByIndex(uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) mut => VT.GetThreadIdsByIndex(ref this, Start, Count, Ids, SysIds);
			public HResult GetThreadIdByProcessor(uint32 Processor, out uint32 Id) mut => VT.GetThreadIdByProcessor(ref this, Processor, out Id);
			public HResult GetCurrentThreadDataOffset(out uint64 Offset) mut => VT.GetCurrentThreadDataOffset(ref this, out Offset);
			public HResult GetThreadIdByDataOffset(uint64 Offset, out uint32 Id) mut => VT.GetThreadIdByDataOffset(ref this, Offset, out Id);
			public HResult GetCurrentThreadTeb(out uint64 Offset) mut => VT.GetCurrentThreadTeb(ref this, out Offset);
			public HResult GetThreadIdByTeb(uint64 Offset, out uint32 Id) mut => VT.GetThreadIdByTeb(ref this, Offset, out Id);
			public HResult GetCurrentThreadSystemId(out uint32 SysId) mut => VT.GetCurrentThreadSystemId(ref this, out SysId);
			public HResult GetThreadIdBySystemId(uint32 SysId, out uint32 Id) mut => VT.GetThreadIdBySystemId(ref this, SysId, out Id);
			public HResult GetCurrentThreadHandle(out uint64 Handle) mut => VT.GetCurrentThreadHandle(ref this, out Handle);
			public HResult GetThreadIdByHandle(uint64 Handle, out uint32 Id) mut => VT.GetThreadIdByHandle(ref this, Handle, out Id);
			public HResult GetNumberProcesses(out uint32 Number) mut => VT.GetNumberProcesses(ref this, out Number);
			public HResult GetProcessIdsByIndex(uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) mut => VT.GetProcessIdsByIndex(ref this, Start, Count, Ids, SysIds);
			public HResult GetCurrentProcessDataOffset(out uint64 Offset) mut => VT.GetCurrentProcessDataOffset(ref this, out Offset);
			public HResult GetProcessIdByDataOffset(uint64 Offset, out uint32 Id) mut => VT.GetProcessIdByDataOffset(ref this, Offset, out Id);
			public HResult GetCurrentProcessPeb(out uint64 Offset) mut => VT.GetCurrentProcessPeb(ref this, out Offset);
			public HResult GetProcessIdByPeb(uint64 Offset, out uint32 Id) mut => VT.GetProcessIdByPeb(ref this, Offset, out Id);
			public HResult GetCurrentProcessSystemId(out uint32 SysId) mut => VT.GetCurrentProcessSystemId(ref this, out SysId);
			public HResult GetProcessIdBySystemId(uint32 SysId, out uint32 Id) mut => VT.GetProcessIdBySystemId(ref this, SysId, out Id);
			public HResult GetCurrentProcessHandle(out uint64 Handle) mut => VT.GetCurrentProcessHandle(ref this, out Handle);
			public HResult GetProcessIdByHandle(uint64 Handle, out uint32 Id) mut => VT.GetProcessIdByHandle(ref this, Handle, out Id);
			public HResult GetCurrentProcessExecutableName(uint8* Buffer, uint32 BufferSize, uint32* ExeSize) mut => VT.GetCurrentProcessExecutableName(ref this, Buffer, BufferSize, ExeSize);
			public HResult GetCurrentProcessUpTime(out uint32 UpTime) mut => VT.GetCurrentProcessUpTime(ref this, out UpTime);
			public HResult GetImplicitThreadDataOffset(out uint64 Offset) mut => VT.GetImplicitThreadDataOffset(ref this, out Offset);
			public HResult SetImplicitThreadDataOffset(uint64 Offset) mut => VT.SetImplicitThreadDataOffset(ref this, Offset);
			public HResult GetImplicitProcessDataOffset(out uint64 Offset) mut => VT.GetImplicitProcessDataOffset(ref this, out Offset);
			public HResult SetImplicitProcessDataOffset(uint64 Offset) mut => VT.SetImplicitProcessDataOffset(ref this, Offset);
			public HResult GetEventSystem(out uint32 Id) mut => VT.GetEventSystem(ref this, out Id);
			public HResult GetCurrentSystemId(out uint32 Id) mut => VT.GetCurrentSystemId(ref this, out Id);
			public HResult SetCurrentSystemId(uint32 Id) mut => VT.SetCurrentSystemId(ref this, Id);
			public HResult GetNumberSystems(out uint32 Number) mut => VT.GetNumberSystems(ref this, out Number);
			public HResult GetSystemIdsByIndex(uint32 Start, uint32 Count, uint32* Ids) mut => VT.GetSystemIdsByIndex(ref this, Start, Count, Ids);
			public HResult GetTotalNumberThreadsAndProcesses(out uint32 TotalThreads, out uint32 TotalProcesses, out uint32 LargestProcessThreads, out uint32 LargestSystemThreads, out uint32 LargestSystemProcesses) mut => VT.GetTotalNumberThreadsAndProcesses(ref this, out TotalThreads, out TotalProcesses, out LargestProcessThreads, out LargestSystemThreads, out LargestSystemProcesses);
			public HResult GetCurrentSystemServer(out uint64 Server) mut => VT.GetCurrentSystemServer(ref this, out Server);
			public HResult GetSystemByServer(uint64 Server, out uint32 Id) mut => VT.GetSystemByServer(ref this, Server, out Id);
			public HResult GetCurrentSystemServerName(uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetCurrentSystemServerName(ref this, Buffer, BufferSize, NameSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Id) GetEventThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Id) GetEventProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Id) _GetCurrentThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint32 Id) SetCurrentThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Id) _GetCurrentProcessId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint32 Id) SetCurrentProcessId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Number) GetNumberThreads;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Total, out uint32 LargestProcess) GetTotalNumberThreads;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) GetThreadIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint32 Processor, out uint32 Id) GetThreadIdByProcessor;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint64 Offset) GetCurrentThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint64 Offset, out uint32 Id) GetThreadIdByDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint64 Offset) GetCurrentThreadTeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint64 Offset, out uint32 Id) GetThreadIdByTeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 SysId) GetCurrentThreadSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint32 SysId, out uint32 Id) GetThreadIdBySystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint64 Handle) GetCurrentThreadHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint64 Handle, out uint32 Id) GetThreadIdByHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Number) GetNumberProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) GetProcessIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint64 Offset) GetCurrentProcessDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint64 Offset, out uint32 Id) GetProcessIdByDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint64 Offset) GetCurrentProcessPeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint64 Offset, out uint32 Id) GetProcessIdByPeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 SysId) GetCurrentProcessSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint32 SysId, out uint32 Id) GetProcessIdBySystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint64 Handle) GetCurrentProcessHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint64 Handle, out uint32 Id) GetProcessIdByHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint8* Buffer, uint32 BufferSize, uint32* ExeSize) GetCurrentProcessExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 UpTime) GetCurrentProcessUpTime;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint64 Offset) GetImplicitThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint64 Offset) SetImplicitThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint64 Offset) GetImplicitProcessDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint64 Offset) SetImplicitProcessDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Id) GetEventSystem;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Id) GetCurrentSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint32 Id) SetCurrentSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 Number) GetNumberSystems;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint32 Start, uint32 Count, uint32* Ids) GetSystemIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint32 TotalThreads, out uint32 TotalProcesses, out uint32 LargestProcessThreads, out uint32 LargestSystemThreads, out uint32 LargestSystemProcesses) GetTotalNumberThreadsAndProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, out uint64 Server) GetCurrentSystemServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint64 Server, out uint32 Id) GetSystemByServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects3 self, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetCurrentSystemServerName;
			}
		}
		[CRepr]
		public struct IDebugSystemObjects4 : IUnknown
		{
			public const new Guid IID = .(0x489468e6, 0x7d0f, 0x4af5, 0x87, 0xab, 0x25, 0x20, 0x74, 0x54, 0xd5, 0x53);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetEventThread(out uint32 Id) mut => VT.GetEventThread(ref this, out Id);
			public HResult GetEventProcess(out uint32 Id) mut => VT.GetEventProcess(ref this, out Id);
			public HResult GetCurrentThreadId(out uint32 Id) mut => VT._GetCurrentThreadId(ref this, out Id);
			public HResult SetCurrentThreadId(uint32 Id) mut => VT.SetCurrentThreadId(ref this, Id);
			public HResult GetCurrentProcessId(out uint32 Id) mut => VT._GetCurrentProcessId(ref this, out Id);
			public HResult SetCurrentProcessId(uint32 Id) mut => VT.SetCurrentProcessId(ref this, Id);
			public HResult GetNumberThreads(out uint32 Number) mut => VT.GetNumberThreads(ref this, out Number);
			public HResult GetTotalNumberThreads(out uint32 Total, out uint32 LargestProcess) mut => VT.GetTotalNumberThreads(ref this, out Total, out LargestProcess);
			public HResult GetThreadIdsByIndex(uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) mut => VT.GetThreadIdsByIndex(ref this, Start, Count, Ids, SysIds);
			public HResult GetThreadIdByProcessor(uint32 Processor, out uint32 Id) mut => VT.GetThreadIdByProcessor(ref this, Processor, out Id);
			public HResult GetCurrentThreadDataOffset(out uint64 Offset) mut => VT.GetCurrentThreadDataOffset(ref this, out Offset);
			public HResult GetThreadIdByDataOffset(uint64 Offset, out uint32 Id) mut => VT.GetThreadIdByDataOffset(ref this, Offset, out Id);
			public HResult GetCurrentThreadTeb(out uint64 Offset) mut => VT.GetCurrentThreadTeb(ref this, out Offset);
			public HResult GetThreadIdByTeb(uint64 Offset, out uint32 Id) mut => VT.GetThreadIdByTeb(ref this, Offset, out Id);
			public HResult GetCurrentThreadSystemId(out uint32 SysId) mut => VT.GetCurrentThreadSystemId(ref this, out SysId);
			public HResult GetThreadIdBySystemId(uint32 SysId, out uint32 Id) mut => VT.GetThreadIdBySystemId(ref this, SysId, out Id);
			public HResult GetCurrentThreadHandle(out uint64 Handle) mut => VT.GetCurrentThreadHandle(ref this, out Handle);
			public HResult GetThreadIdByHandle(uint64 Handle, out uint32 Id) mut => VT.GetThreadIdByHandle(ref this, Handle, out Id);
			public HResult GetNumberProcesses(out uint32 Number) mut => VT.GetNumberProcesses(ref this, out Number);
			public HResult GetProcessIdsByIndex(uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) mut => VT.GetProcessIdsByIndex(ref this, Start, Count, Ids, SysIds);
			public HResult GetCurrentProcessDataOffset(out uint64 Offset) mut => VT.GetCurrentProcessDataOffset(ref this, out Offset);
			public HResult GetProcessIdByDataOffset(uint64 Offset, out uint32 Id) mut => VT.GetProcessIdByDataOffset(ref this, Offset, out Id);
			public HResult GetCurrentProcessPeb(out uint64 Offset) mut => VT.GetCurrentProcessPeb(ref this, out Offset);
			public HResult GetProcessIdByPeb(uint64 Offset, out uint32 Id) mut => VT.GetProcessIdByPeb(ref this, Offset, out Id);
			public HResult GetCurrentProcessSystemId(out uint32 SysId) mut => VT.GetCurrentProcessSystemId(ref this, out SysId);
			public HResult GetProcessIdBySystemId(uint32 SysId, out uint32 Id) mut => VT.GetProcessIdBySystemId(ref this, SysId, out Id);
			public HResult GetCurrentProcessHandle(out uint64 Handle) mut => VT.GetCurrentProcessHandle(ref this, out Handle);
			public HResult GetProcessIdByHandle(uint64 Handle, out uint32 Id) mut => VT.GetProcessIdByHandle(ref this, Handle, out Id);
			public HResult GetCurrentProcessExecutableName(uint8* Buffer, uint32 BufferSize, uint32* ExeSize) mut => VT.GetCurrentProcessExecutableName(ref this, Buffer, BufferSize, ExeSize);
			public HResult GetCurrentProcessUpTime(out uint32 UpTime) mut => VT.GetCurrentProcessUpTime(ref this, out UpTime);
			public HResult GetImplicitThreadDataOffset(out uint64 Offset) mut => VT.GetImplicitThreadDataOffset(ref this, out Offset);
			public HResult SetImplicitThreadDataOffset(uint64 Offset) mut => VT.SetImplicitThreadDataOffset(ref this, Offset);
			public HResult GetImplicitProcessDataOffset(out uint64 Offset) mut => VT.GetImplicitProcessDataOffset(ref this, out Offset);
			public HResult SetImplicitProcessDataOffset(uint64 Offset) mut => VT.SetImplicitProcessDataOffset(ref this, Offset);
			public HResult GetEventSystem(out uint32 Id) mut => VT.GetEventSystem(ref this, out Id);
			public HResult GetCurrentSystemId(out uint32 Id) mut => VT.GetCurrentSystemId(ref this, out Id);
			public HResult SetCurrentSystemId(uint32 Id) mut => VT.SetCurrentSystemId(ref this, Id);
			public HResult GetNumberSystems(out uint32 Number) mut => VT.GetNumberSystems(ref this, out Number);
			public HResult GetSystemIdsByIndex(uint32 Start, uint32 Count, uint32* Ids) mut => VT.GetSystemIdsByIndex(ref this, Start, Count, Ids);
			public HResult GetTotalNumberThreadsAndProcesses(out uint32 TotalThreads, out uint32 TotalProcesses, out uint32 LargestProcessThreads, out uint32 LargestSystemThreads, out uint32 LargestSystemProcesses) mut => VT.GetTotalNumberThreadsAndProcesses(ref this, out TotalThreads, out TotalProcesses, out LargestProcessThreads, out LargestSystemThreads, out LargestSystemProcesses);
			public HResult GetCurrentSystemServer(out uint64 Server) mut => VT.GetCurrentSystemServer(ref this, out Server);
			public HResult GetSystemByServer(uint64 Server, out uint32 Id) mut => VT.GetSystemByServer(ref this, Server, out Id);
			public HResult GetCurrentSystemServerName(uint8* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetCurrentSystemServerName(ref this, Buffer, BufferSize, NameSize);
			public HResult GetCurrentProcessExecutableNameWide(char16* Buffer, uint32 BufferSize, uint32* ExeSize) mut => VT.GetCurrentProcessExecutableNameWide(ref this, Buffer, BufferSize, ExeSize);
			public HResult GetCurrentSystemServerNameWide(char16* Buffer, uint32 BufferSize, uint32* NameSize) mut => VT.GetCurrentSystemServerNameWide(ref this, Buffer, BufferSize, NameSize);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Id) GetEventThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Id) GetEventProcess;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Id) _GetCurrentThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint32 Id) SetCurrentThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Id) _GetCurrentProcessId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint32 Id) SetCurrentProcessId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Number) GetNumberThreads;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Total, out uint32 LargestProcess) GetTotalNumberThreads;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) GetThreadIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint32 Processor, out uint32 Id) GetThreadIdByProcessor;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint64 Offset) GetCurrentThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint64 Offset, out uint32 Id) GetThreadIdByDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint64 Offset) GetCurrentThreadTeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint64 Offset, out uint32 Id) GetThreadIdByTeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 SysId) GetCurrentThreadSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint32 SysId, out uint32 Id) GetThreadIdBySystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint64 Handle) GetCurrentThreadHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint64 Handle, out uint32 Id) GetThreadIdByHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Number) GetNumberProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint32 Start, uint32 Count, uint32* Ids, uint32* SysIds) GetProcessIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint64 Offset) GetCurrentProcessDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint64 Offset, out uint32 Id) GetProcessIdByDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint64 Offset) GetCurrentProcessPeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint64 Offset, out uint32 Id) GetProcessIdByPeb;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 SysId) GetCurrentProcessSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint32 SysId, out uint32 Id) GetProcessIdBySystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint64 Handle) GetCurrentProcessHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint64 Handle, out uint32 Id) GetProcessIdByHandle;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint8* Buffer, uint32 BufferSize, uint32* ExeSize) GetCurrentProcessExecutableName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 UpTime) GetCurrentProcessUpTime;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint64 Offset) GetImplicitThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint64 Offset) SetImplicitThreadDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint64 Offset) GetImplicitProcessDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint64 Offset) SetImplicitProcessDataOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Id) GetEventSystem;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Id) GetCurrentSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint32 Id) SetCurrentSystemId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 Number) GetNumberSystems;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint32 Start, uint32 Count, uint32* Ids) GetSystemIdsByIndex;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint32 TotalThreads, out uint32 TotalProcesses, out uint32 LargestProcessThreads, out uint32 LargestSystemThreads, out uint32 LargestSystemProcesses) GetTotalNumberThreadsAndProcesses;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, out uint64 Server) GetCurrentSystemServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint64 Server, out uint32 Id) GetSystemByServer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, uint8* Buffer, uint32 BufferSize, uint32* NameSize) GetCurrentSystemServerName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, char16* Buffer, uint32 BufferSize, uint32* ExeSize) GetCurrentProcessExecutableNameWide;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSystemObjects4 self, char16* Buffer, uint32 BufferSize, uint32* NameSize) GetCurrentSystemServerNameWide;
			}
		}
		[CRepr]
		public struct DebugBaseEventCallbacks : IDebugEventCallbacks
		{
			public new VTable* VT { get => (.)vt; }
			
			[CRepr]
			public struct VTable : IDebugEventCallbacks.VTable {}
		}
		[CRepr]
		public struct DebugBaseEventCallbacksWide : IDebugEventCallbacksWide
		{
			public new VTable* VT { get => (.)vt; }
			
			[CRepr]
			public struct VTable : IDebugEventCallbacksWide.VTable {}
		}
		[CRepr]
		public struct IHostDataModelAccess : IUnknown
		{
			public const new Guid IID = .(0xf2bce54e, 0x4835, 0x4f8a, 0x83, 0x6e, 0x79, 0x81, 0xe2, 0x99, 0x04, 0xd1);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDataModel(out IDataModelManager* manager, out IDebugHost* host) mut => VT.GetDataModel(ref this, out manager, out host);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IHostDataModelAccess self, out IDataModelManager* manager, out IDebugHost* host) GetDataModel;
			}
		}
		[CRepr]
		public struct IKeyStore : IUnknown
		{
			public const new Guid IID = .(0x0fc7557d, 0x401d, 0x4fca, 0x93, 0x65, 0xda, 0x1e, 0x98, 0x50, 0x69, 0x7c);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetKey(char16* key, IModelObject** object, IKeyStore** metadata) mut => VT.GetKey(ref this, key, object, metadata);
			public HResult SetKey(char16* key, IModelObject* object, IKeyStore* metadata) mut => VT.SetKey(ref this, key, object, metadata);
			public HResult GetKeyValue(char16* key, IModelObject** object, IKeyStore** metadata) mut => VT.GetKeyValue(ref this, key, object, metadata);
			public HResult SetKeyValue(char16* key, ref IModelObject object) mut => VT.SetKeyValue(ref this, key, ref object);
			public HResult ClearKeys() mut => VT.ClearKeys(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IKeyStore self, char16* key, IModelObject** object, IKeyStore** metadata) GetKey;
				public new function [CallingConvention(.Stdcall)] HResult(ref IKeyStore self, char16* key, IModelObject* object, IKeyStore* metadata) SetKey;
				public new function [CallingConvention(.Stdcall)] HResult(ref IKeyStore self, char16* key, IModelObject** object, IKeyStore** metadata) GetKeyValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IKeyStore self, char16* key, ref IModelObject object) SetKeyValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IKeyStore self) ClearKeys;
			}
		}
		[CRepr]
		public struct IModelObject : IUnknown
		{
			public const new Guid IID = .(0xe28c7893, 0x3f4b, 0x4b96, 0xba, 0xca, 0x29, 0x3c, 0xdc, 0x55, 0xf4, 0x5d);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetContext(IDebugHostContext** context) mut => VT.GetContext(ref this, context);
			public HResult GetKind(out ModelObjectKind kind) mut => VT.GetKind(ref this, out kind);
			public HResult GetIntrinsicValue(out VARIANT intrinsicData) mut => VT.GetIntrinsicValue(ref this, out intrinsicData);
			public HResult GetIntrinsicValueAs(uint16 vt, out VARIANT intrinsicData) mut => VT.GetIntrinsicValueAs(ref this, vt, out intrinsicData);
			public HResult GetKeyValue(char16* key, IModelObject** object, IKeyStore** metadata) mut => VT.GetKeyValue(ref this, key, object, metadata);
			public HResult SetKeyValue(char16* key, IModelObject* object) mut => VT.SetKeyValue(ref this, key, object);
			public HResult EnumerateKeyValues(out IKeyEnumerator* enumerator) mut => VT.EnumerateKeyValues(ref this, out enumerator);
			public HResult GetRawValue(SymbolKind kind, char16* name, uint32 searchFlags, out IModelObject* object) mut => VT.GetRawValue(ref this, kind, name, searchFlags, out object);
			public HResult EnumerateRawValues(SymbolKind kind, uint32 searchFlags, out IRawEnumerator* enumerator) mut => VT.EnumerateRawValues(ref this, kind, searchFlags, out enumerator);
			public HResult Dereference(out IModelObject* object) mut => VT.Dereference(ref this, out object);
			public HResult TryCastToRuntimeType(out IModelObject* runtimeTypedObject) mut => VT.TryCastToRuntimeType(ref this, out runtimeTypedObject);
			public HResult GetConcept(in Guid conceptId, out IUnknown* conceptInterface, IKeyStore** conceptMetadata) mut => VT.GetConcept(ref this, conceptId, out conceptInterface, conceptMetadata);
			public HResult GetLocation(out Location location) mut => VT.GetLocation(ref this, out location);
			public HResult GetTypeInfo(out IDebugHostType* type) mut => VT.GetTypeInfo(ref this, out type);
			public HResult GetTargetInfo(out Location location, out IDebugHostType* type) mut => VT.GetTargetInfo(ref this, out location, out type);
			public HResult GetNumberOfParentModels(out uint64 numModels) mut => VT.GetNumberOfParentModels(ref this, out numModels);
			public HResult GetParentModel(uint64 i, out IModelObject* model, IModelObject** contextObject) mut => VT.GetParentModel(ref this, i, out model, contextObject);
			public HResult AddParentModel(ref IModelObject model, IModelObject* contextObject, uint8 @override) mut => VT.AddParentModel(ref this, ref model, contextObject, @override);
			public HResult RemoveParentModel(ref IModelObject model) mut => VT.RemoveParentModel(ref this, ref model);
			public HResult GetKey(char16* key, IModelObject** object, IKeyStore** metadata) mut => VT.GetKey(ref this, key, object, metadata);
			public HResult GetKeyReference(char16* key, IModelObject** objectReference, IKeyStore** metadata) mut => VT.GetKeyReference(ref this, key, objectReference, metadata);
			public HResult SetKey(char16* key, IModelObject* object, IKeyStore* metadata) mut => VT.SetKey(ref this, key, object, metadata);
			public HResult ClearKeys() mut => VT.ClearKeys(ref this);
			public HResult EnumerateKeys(out IKeyEnumerator* enumerator) mut => VT.EnumerateKeys(ref this, out enumerator);
			public HResult EnumerateKeyReferences(out IKeyEnumerator* enumerator) mut => VT.EnumerateKeyReferences(ref this, out enumerator);
			public HResult SetConcept(in Guid conceptId, ref IUnknown conceptInterface, IKeyStore* conceptMetadata) mut => VT.SetConcept(ref this, conceptId, ref conceptInterface, conceptMetadata);
			public HResult ClearConcepts() mut => VT.ClearConcepts(ref this);
			public HResult GetRawReference(SymbolKind kind, char16* name, uint32 searchFlags, out IModelObject* object) mut => VT.GetRawReference(ref this, kind, name, searchFlags, out object);
			public HResult EnumerateRawReferences(SymbolKind kind, uint32 searchFlags, out IRawEnumerator* enumerator) mut => VT.EnumerateRawReferences(ref this, kind, searchFlags, out enumerator);
			public HResult SetContextForDataModel(ref IModelObject dataModelObject, ref IUnknown context) mut => VT.SetContextForDataModel(ref this, ref dataModelObject, ref context);
			public HResult GetContextForDataModel(ref IModelObject dataModelObject, out IUnknown* context) mut => VT.GetContextForDataModel(ref this, ref dataModelObject, out context);
			public HResult Compare(ref IModelObject other, IModelObject** ppResult) mut => VT.Compare(ref this, ref other, ppResult);
			public HResult IsEqualTo(ref IModelObject other, out Boolean equal) mut => VT.IsEqualTo(ref this, ref other, out equal);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, IDebugHostContext** context) GetContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out ModelObjectKind kind) GetKind;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out VARIANT intrinsicData) GetIntrinsicValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, uint16 vt, out VARIANT intrinsicData) GetIntrinsicValueAs;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, char16* key, IModelObject** object, IKeyStore** metadata) GetKeyValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, char16* key, IModelObject* object) SetKeyValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out IKeyEnumerator* enumerator) EnumerateKeyValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, SymbolKind kind, char16* name, uint32 searchFlags, out IModelObject* object) GetRawValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, SymbolKind kind, uint32 searchFlags, out IRawEnumerator* enumerator) EnumerateRawValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out IModelObject* object) Dereference;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out IModelObject* runtimeTypedObject) TryCastToRuntimeType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, in Guid conceptId, out IUnknown* conceptInterface, IKeyStore** conceptMetadata) GetConcept;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out Location location) GetLocation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out IDebugHostType* type) GetTypeInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out Location location, out IDebugHostType* type) GetTargetInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out uint64 numModels) GetNumberOfParentModels;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, uint64 i, out IModelObject* model, IModelObject** contextObject) GetParentModel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, ref IModelObject model, IModelObject* contextObject, uint8 @override) AddParentModel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, ref IModelObject model) RemoveParentModel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, char16* key, IModelObject** object, IKeyStore** metadata) GetKey;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, char16* key, IModelObject** objectReference, IKeyStore** metadata) GetKeyReference;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, char16* key, IModelObject* object, IKeyStore* metadata) SetKey;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self) ClearKeys;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out IKeyEnumerator* enumerator) EnumerateKeys;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, out IKeyEnumerator* enumerator) EnumerateKeyReferences;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, in Guid conceptId, ref IUnknown conceptInterface, IKeyStore* conceptMetadata) SetConcept;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self) ClearConcepts;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, SymbolKind kind, char16* name, uint32 searchFlags, out IModelObject* object) GetRawReference;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, SymbolKind kind, uint32 searchFlags, out IRawEnumerator* enumerator) EnumerateRawReferences;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, ref IModelObject dataModelObject, ref IUnknown context) SetContextForDataModel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, ref IModelObject dataModelObject, out IUnknown* context) GetContextForDataModel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, ref IModelObject other, IModelObject** ppResult) Compare;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelObject self, ref IModelObject other, out Boolean equal) IsEqualTo;
			}
		}
		[CRepr]
		public struct IDataModelManager : IUnknown
		{
			public const new Guid IID = .(0x73fe19f4, 0xa110, 0x4500, 0x8e, 0xd9, 0x3c, 0x28, 0x89, 0x6f, 0x50, 0x8c);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Close() mut => VT.Close(ref this);
			public HResult CreateNoValue(out IModelObject* object) mut => VT.CreateNoValue(ref this, out object);
			public HResult CreateErrorObject(HResult hrError, char16* pwszMessage, out IModelObject* object) mut => VT.CreateErrorObject(ref this, hrError, pwszMessage, out object);
			public HResult CreateTypedObject(IDebugHostContext* context, Location objectLocation, ref IDebugHostType objectType, out IModelObject* object) mut => VT.CreateTypedObject(ref this, context, objectLocation, ref objectType, out object);
			public HResult CreateTypedObjectReference(IDebugHostContext* context, Location objectLocation, ref IDebugHostType objectType, out IModelObject* object) mut => VT.CreateTypedObjectReference(ref this, context, objectLocation, ref objectType, out object);
			public HResult CreateSyntheticObject(IDebugHostContext* context, out IModelObject* object) mut => VT.CreateSyntheticObject(ref this, context, out object);
			public HResult CreateDataModelObject(ref IDataModelConcept dataModel, out IModelObject* object) mut => VT.CreateDataModelObject(ref this, ref dataModel, out object);
			public HResult CreateIntrinsicObject(ModelObjectKind objectKind, ref VARIANT intrinsicData, out IModelObject* object) mut => VT.CreateIntrinsicObject(ref this, objectKind, ref intrinsicData, out object);
			public HResult CreateTypedIntrinsicObject(ref VARIANT intrinsicData, ref IDebugHostType type, out IModelObject* object) mut => VT.CreateTypedIntrinsicObject(ref this, ref intrinsicData, ref type, out object);
			public HResult GetModelForTypeSignature(ref IDebugHostTypeSignature typeSignature, out IModelObject* dataModel) mut => VT.GetModelForTypeSignature(ref this, ref typeSignature, out dataModel);
			public HResult GetModelForType(ref IDebugHostType type, out IModelObject* dataModel, IDebugHostTypeSignature** typeSignature, IDebugHostSymbolEnumerator** wildcardMatches) mut => VT.GetModelForType(ref this, ref type, out dataModel, typeSignature, wildcardMatches);
			public HResult RegisterModelForTypeSignature(ref IDebugHostTypeSignature typeSignature, ref IModelObject dataModel) mut => VT.RegisterModelForTypeSignature(ref this, ref typeSignature, ref dataModel);
			public HResult UnregisterModelForTypeSignature(ref IModelObject dataModel, IDebugHostTypeSignature* typeSignature) mut => VT.UnregisterModelForTypeSignature(ref this, ref dataModel, typeSignature);
			public HResult RegisterExtensionForTypeSignature(ref IDebugHostTypeSignature typeSignature, ref IModelObject dataModel) mut => VT.RegisterExtensionForTypeSignature(ref this, ref typeSignature, ref dataModel);
			public HResult UnregisterExtensionForTypeSignature(ref IModelObject dataModel, IDebugHostTypeSignature* typeSignature) mut => VT.UnregisterExtensionForTypeSignature(ref this, ref dataModel, typeSignature);
			public HResult CreateMetadataStore(IKeyStore* parentStore, out IKeyStore* metadataStore) mut => VT.CreateMetadataStore(ref this, parentStore, out metadataStore);
			public HResult GetRootNamespace(out IModelObject* rootNamespace) mut => VT.GetRootNamespace(ref this, out rootNamespace);
			public HResult RegisterNamedModel(char16* modelName, ref IModelObject modeObject) mut => VT.RegisterNamedModel(ref this, modelName, ref modeObject);
			public HResult UnregisterNamedModel(char16* modelName) mut => VT.UnregisterNamedModel(ref this, modelName);
			public HResult AcquireNamedModel(char16* modelName, out IModelObject* modelObject) mut => VT.AcquireNamedModel(ref this, modelName, out modelObject);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self) Close;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, out IModelObject* object) CreateNoValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, HResult hrError, char16* pwszMessage, out IModelObject* object) CreateErrorObject;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, IDebugHostContext* context, Location objectLocation, ref IDebugHostType objectType, out IModelObject* object) CreateTypedObject;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, IDebugHostContext* context, Location objectLocation, ref IDebugHostType objectType, out IModelObject* object) CreateTypedObjectReference;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, IDebugHostContext* context, out IModelObject* object) CreateSyntheticObject;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, ref IDataModelConcept dataModel, out IModelObject* object) CreateDataModelObject;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, ModelObjectKind objectKind, ref VARIANT intrinsicData, out IModelObject* object) CreateIntrinsicObject;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, ref VARIANT intrinsicData, ref IDebugHostType type, out IModelObject* object) CreateTypedIntrinsicObject;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, ref IDebugHostTypeSignature typeSignature, out IModelObject* dataModel) GetModelForTypeSignature;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, ref IDebugHostType type, out IModelObject* dataModel, IDebugHostTypeSignature** typeSignature, IDebugHostSymbolEnumerator** wildcardMatches) GetModelForType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, ref IDebugHostTypeSignature typeSignature, ref IModelObject dataModel) RegisterModelForTypeSignature;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, ref IModelObject dataModel, IDebugHostTypeSignature* typeSignature) UnregisterModelForTypeSignature;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, ref IDebugHostTypeSignature typeSignature, ref IModelObject dataModel) RegisterExtensionForTypeSignature;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, ref IModelObject dataModel, IDebugHostTypeSignature* typeSignature) UnregisterExtensionForTypeSignature;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, IKeyStore* parentStore, out IKeyStore* metadataStore) CreateMetadataStore;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, out IModelObject* rootNamespace) GetRootNamespace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, char16* modelName, ref IModelObject modeObject) RegisterNamedModel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, char16* modelName) UnregisterNamedModel;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager self, char16* modelName, out IModelObject* modelObject) AcquireNamedModel;
			}
		}
		[CRepr]
		public struct IModelKeyReference : IUnknown
		{
			public const new Guid IID = .(0x5253dcf8, 0x5aff, 0x4c62, 0xb3, 0x02, 0x56, 0xa2, 0x89, 0xe0, 0x09, 0x98);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetKeyName(out char16* keyName) mut => VT.GetKeyName(ref this, out keyName);
			public HResult GetOriginalObject(out IModelObject* originalObject) mut => VT.GetOriginalObject(ref this, out originalObject);
			public HResult GetContextObject(out IModelObject* containingObject) mut => VT.GetContextObject(ref this, out containingObject);
			public HResult GetKey(IModelObject** object, IKeyStore** metadata) mut => VT.GetKey(ref this, object, metadata);
			public HResult GetKeyValue(IModelObject** object, IKeyStore** metadata) mut => VT.GetKeyValue(ref this, object, metadata);
			public HResult SetKey(IModelObject* object, IKeyStore* metadata) mut => VT.SetKey(ref this, object, metadata);
			public HResult SetKeyValue(ref IModelObject object) mut => VT.SetKeyValue(ref this, ref object);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelKeyReference self, out char16* keyName) GetKeyName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelKeyReference self, out IModelObject* originalObject) GetOriginalObject;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelKeyReference self, out IModelObject* containingObject) GetContextObject;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelKeyReference self, IModelObject** object, IKeyStore** metadata) GetKey;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelKeyReference self, IModelObject** object, IKeyStore** metadata) GetKeyValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelKeyReference self, IModelObject* object, IKeyStore* metadata) SetKey;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelKeyReference self, ref IModelObject object) SetKeyValue;
			}
		}
		[CRepr]
		public struct IModelPropertyAccessor : IUnknown
		{
			public const new Guid IID = .(0x5a0c63d9, 0x0526, 0x42b8, 0x96, 0x0c, 0x95, 0x16, 0xa3, 0x25, 0x4c, 0x85);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetValue(char16* key, IModelObject* contextObject, out IModelObject* value) mut => VT.GetValue(ref this, key, contextObject, out value);
			public HResult SetValue(char16* key, IModelObject* contextObject, ref IModelObject value) mut => VT.SetValue(ref this, key, contextObject, ref value);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelPropertyAccessor self, char16* key, IModelObject* contextObject, out IModelObject* value) GetValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelPropertyAccessor self, char16* key, IModelObject* contextObject, ref IModelObject value) SetValue;
			}
		}
		[CRepr]
		public struct IModelMethod : IUnknown
		{
			public const new Guid IID = .(0x80600c1f, 0xb90b, 0x4896, 0x82, 0xad, 0x1c, 0x00, 0x20, 0x79, 0x09, 0xe8);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Call(IModelObject* pContextObject, uint64 argCount, IModelObject** ppArguments, out IModelObject* ppResult, IKeyStore** ppMetadata) mut => VT.Call(ref this, pContextObject, argCount, ppArguments, out ppResult, ppMetadata);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelMethod self, IModelObject* pContextObject, uint64 argCount, IModelObject** ppArguments, out IModelObject* ppResult, IKeyStore** ppMetadata) Call;
			}
		}
		[CRepr]
		public struct IKeyEnumerator : IUnknown
		{
			public const new Guid IID = .(0x345fa92e, 0x5e00, 0x4319, 0x9c, 0xae, 0x97, 0x1f, 0x76, 0x01, 0xcd, 0xcf);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult GetNext(out char16* key, IModelObject** value, IKeyStore** metadata) mut => VT.GetNext(ref this, out key, value, metadata);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IKeyEnumerator self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IKeyEnumerator self, out char16* key, IModelObject** value, IKeyStore** metadata) GetNext;
			}
		}
		[CRepr]
		public struct IRawEnumerator : IUnknown
		{
			public const new Guid IID = .(0xe13613f9, 0x3a3c, 0x40b5, 0x8f, 0x48, 0x1e, 0x5e, 0xbf, 0xb9, 0xb2, 0x1b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult GetNext(char16** name, SymbolKind* kind, IModelObject** value) mut => VT.GetNext(ref this, name, kind, value);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IRawEnumerator self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRawEnumerator self, char16** name, SymbolKind* kind, IModelObject** value) GetNext;
			}
		}
		[CRepr]
		public struct IDataModelConcept : IUnknown
		{
			public const new Guid IID = .(0xfcb98d1d, 0x1114, 0x4fbf, 0xb2, 0x4c, 0xef, 0xfc, 0xb5, 0xde, 0xf0, 0xd3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult InitializeObject(ref IModelObject modelObject, IDebugHostTypeSignature* matchingTypeSignature, IDebugHostSymbolEnumerator* wildcardMatches) mut => VT.InitializeObject(ref this, ref modelObject, matchingTypeSignature, wildcardMatches);
			public HResult GetName(out char16* modelName) mut => VT.GetName(ref this, out modelName);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelConcept self, ref IModelObject modelObject, IDebugHostTypeSignature* matchingTypeSignature, IDebugHostSymbolEnumerator* wildcardMatches) InitializeObject;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelConcept self, out char16* modelName) GetName;
			}
		}
		[CRepr]
		public struct IStringDisplayableConcept : IUnknown
		{
			public const new Guid IID = .(0xd28e8d70, 0x6c00, 0x4205, 0x94, 0x0d, 0x50, 0x10, 0x16, 0x60, 0x1e, 0xa3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ToDisplayString(ref IModelObject contextObject, IKeyStore* metadata, out char16* displayString) mut => VT.ToDisplayString(ref this, ref contextObject, metadata, out displayString);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IStringDisplayableConcept self, ref IModelObject contextObject, IKeyStore* metadata, out char16* displayString) ToDisplayString;
			}
		}
		[CRepr]
		public struct ICodeAddressConcept : IUnknown
		{
			public const new Guid IID = .(0xc7371568, 0x5c78, 0x4a00, 0xa4, 0xab, 0x6e, 0xf8, 0x82, 0x31, 0x84, 0xcb);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetContainingSymbol(ref IModelObject pContextObject, out IDebugHostSymbol* ppSymbol) mut => VT.GetContainingSymbol(ref this, ref pContextObject, out ppSymbol);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref ICodeAddressConcept self, ref IModelObject pContextObject, out IDebugHostSymbol* ppSymbol) GetContainingSymbol;
			}
		}
		[CRepr]
		public struct IModelIterator : IUnknown
		{
			public const new Guid IID = .(0xe4622136, 0x927d, 0x4490, 0x87, 0x4f, 0x58, 0x1f, 0x3e, 0x4e, 0x36, 0x88);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult GetNext(out IModelObject* object, uint64 dimensions, IModelObject** indexers, IKeyStore** metadata) mut => VT.GetNext(ref this, out object, dimensions, indexers, metadata);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelIterator self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelIterator self, out IModelObject* object, uint64 dimensions, IModelObject** indexers, IKeyStore** metadata) GetNext;
			}
		}
		[CRepr]
		public struct IIterableConcept : IUnknown
		{
			public const new Guid IID = .(0xf5d49d0c, 0x0b02, 0x4301, 0x9c, 0x9b, 0xb3, 0xa6, 0x03, 0x76, 0x28, 0xf3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDefaultIndexDimensionality(ref IModelObject contextObject, out uint64 dimensionality) mut => VT.GetDefaultIndexDimensionality(ref this, ref contextObject, out dimensionality);
			public HResult GetIterator(ref IModelObject contextObject, out IModelIterator* iterator) mut => VT.GetIterator(ref this, ref contextObject, out iterator);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IIterableConcept self, ref IModelObject contextObject, out uint64 dimensionality) GetDefaultIndexDimensionality;
				public new function [CallingConvention(.Stdcall)] HResult(ref IIterableConcept self, ref IModelObject contextObject, out IModelIterator* iterator) GetIterator;
			}
		}
		[CRepr]
		public struct IIndexableConcept : IUnknown
		{
			public const new Guid IID = .(0xd1fad99f, 0x3f53, 0x4457, 0x85, 0x0c, 0x80, 0x51, 0xdf, 0x2d, 0x3f, 0xb5);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDimensionality(ref IModelObject contextObject, out uint64 dimensionality) mut => VT.GetDimensionality(ref this, ref contextObject, out dimensionality);
			public HResult GetAt(ref IModelObject contextObject, uint64 indexerCount, IModelObject** indexers, out IModelObject* object, IKeyStore** metadata) mut => VT.GetAt(ref this, ref contextObject, indexerCount, indexers, out object, metadata);
			public HResult SetAt(ref IModelObject contextObject, uint64 indexerCount, IModelObject** indexers, ref IModelObject value) mut => VT.SetAt(ref this, ref contextObject, indexerCount, indexers, ref value);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IIndexableConcept self, ref IModelObject contextObject, out uint64 dimensionality) GetDimensionality;
				public new function [CallingConvention(.Stdcall)] HResult(ref IIndexableConcept self, ref IModelObject contextObject, uint64 indexerCount, IModelObject** indexers, out IModelObject* object, IKeyStore** metadata) GetAt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IIndexableConcept self, ref IModelObject contextObject, uint64 indexerCount, IModelObject** indexers, ref IModelObject value) SetAt;
			}
		}
		[CRepr]
		public struct IPreferredRuntimeTypeConcept : IUnknown
		{
			public const new Guid IID = .(0x9d6c1d7b, 0xa76f, 0x4618, 0x80, 0x68, 0x5f, 0x76, 0xbd, 0x9a, 0x4e, 0x8a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CastToPreferredRuntimeType(ref IModelObject contextObject, out IModelObject* object) mut => VT.CastToPreferredRuntimeType(ref this, ref contextObject, out object);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IPreferredRuntimeTypeConcept self, ref IModelObject contextObject, out IModelObject* object) CastToPreferredRuntimeType;
			}
		}
		[CRepr]
		public struct IDebugHost : IUnknown
		{
			public const new Guid IID = .(0xb8c74943, 0x6b2c, 0x4eeb, 0xb5, 0xc5, 0x35, 0xd3, 0x78, 0xa6, 0xd9, 0x9d);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetHostDefinedInterface(out IUnknown* hostUnk) mut => VT.GetHostDefinedInterface(ref this, out hostUnk);
			public HResult GetCurrentContext(out IDebugHostContext* context) mut => VT.GetCurrentContext(ref this, out context);
			public HResult GetDefaultMetadata(out IKeyStore* defaultMetadataStore) mut => VT.GetDefaultMetadata(ref this, out defaultMetadataStore);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHost self, out IUnknown* hostUnk) GetHostDefinedInterface;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHost self, out IDebugHostContext* context) GetCurrentContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHost self, out IKeyStore* defaultMetadataStore) GetDefaultMetadata;
			}
		}
		[CRepr]
		public struct IDebugHostContext : IUnknown
		{
			public const new Guid IID = .(0xa68c70d8, 0x5ec0, 0x46e5, 0xb7, 0x75, 0x31, 0x34, 0xa4, 0x8e, 0xa2, 0xe3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult IsEqualTo(ref IDebugHostContext pContext, out Boolean pIsEqual) mut => VT.IsEqualTo(ref this, ref pContext, out pIsEqual);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostContext self, ref IDebugHostContext pContext, out Boolean pIsEqual) IsEqualTo;
			}
		}
		[CRepr]
		public struct IDebugHostErrorSink : IUnknown
		{
			public const new Guid IID = .(0xc8ff0f0b, 0xfce9, 0x467e, 0x8b, 0xb3, 0x5d, 0x69, 0xef, 0x10, 0x9c, 0x00);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ReportError(ErrorClass errClass, HResult hrError, char16* message) mut => VT.ReportError(ref this, errClass, hrError, message);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostErrorSink self, ErrorClass errClass, HResult hrError, char16* message) ReportError;
			}
		}
		[CRepr]
		public struct IDebugHostSymbol : IUnknown
		{
			public const new Guid IID = .(0x0f819103, 0x87de, 0x4e96, 0x82, 0x77, 0xe0, 0x5c, 0xd4, 0x41, 0xfb, 0x22);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetContext(out IDebugHostContext* context) mut => VT.GetContext(ref this, out context);
			public HResult EnumerateChildren(SymbolKind kind, char16* name, out IDebugHostSymbolEnumerator* ppEnum) mut => VT.EnumerateChildren(ref this, kind, name, out ppEnum);
			public HResult GetSymbolKind(out SymbolKind kind) mut => VT.GetSymbolKind(ref this, out kind);
			public HResult GetName(out char16* symbolName) mut => VT.GetName(ref this, out symbolName);
			public HResult ComGetType(out IDebugHostType* type) mut => VT.ComGetType(ref this, out type);
			public HResult GetContainingModule(out IDebugHostModule* containingModule) mut => VT.GetContainingModule(ref this, out containingModule);
			public HResult CompareAgainst(ref IDebugHostSymbol pComparisonSymbol, uint32 comparisonFlags, out Boolean pMatches) mut => VT.CompareAgainst(ref this, ref pComparisonSymbol, comparisonFlags, out pMatches);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbol self, out IDebugHostContext* context) GetContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbol self, SymbolKind kind, char16* name, out IDebugHostSymbolEnumerator* ppEnum) EnumerateChildren;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbol self, out SymbolKind kind) GetSymbolKind;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbol self, out char16* symbolName) GetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbol self, out IDebugHostType* type) ComGetType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbol self, out IDebugHostModule* containingModule) GetContainingModule;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbol self, ref IDebugHostSymbol pComparisonSymbol, uint32 comparisonFlags, out Boolean pMatches) CompareAgainst;
			}
		}
		[CRepr]
		public struct IDebugHostSymbolEnumerator : IUnknown
		{
			public const new Guid IID = .(0x28d96c86, 0x10a3, 0x4976, 0xb1, 0x4e, 0xea, 0xef, 0x47, 0x90, 0xaa, 0x1f);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult GetNext(out IDebugHostSymbol* symbol) mut => VT.GetNext(ref this, out symbol);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbolEnumerator self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbolEnumerator self, out IDebugHostSymbol* symbol) GetNext;
			}
		}
		[CRepr]
		public struct IDebugHostModule : IDebugHostSymbol
		{
			public const new Guid IID = .(0xc9ba3e18, 0xd070, 0x4378, 0xbb, 0xd0, 0x34, 0x61, 0x3b, 0x34, 0x6e, 0x1e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetImageName(uint8 allowPath, out char16* imageName) mut => VT.GetImageName(ref this, allowPath, out imageName);
			public HResult GetBaseLocation(out Location moduleBaseLocation) mut => VT.GetBaseLocation(ref this, out moduleBaseLocation);
			public HResult GetVersion(uint64* fileVersion, uint64* productVersion) mut => VT._GetVersion(ref this, fileVersion, productVersion);
			public HResult FindTypeByName(char16* typeName, out IDebugHostType* type) mut => VT.FindTypeByName(ref this, typeName, out type);
			public HResult FindSymbolByRVA(uint64 rva, out IDebugHostSymbol* symbol) mut => VT.FindSymbolByRVA(ref this, rva, out symbol);
			public HResult FindSymbolByName(char16* symbolName, out IDebugHostSymbol* symbol) mut => VT.FindSymbolByName(ref this, symbolName, out symbol);

			[CRepr]
			public struct VTable : IDebugHostSymbol.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostModule self, uint8 allowPath, out char16* imageName) GetImageName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostModule self, out Location moduleBaseLocation) GetBaseLocation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostModule self, uint64* fileVersion, uint64* productVersion) _GetVersion;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostModule self, char16* typeName, out IDebugHostType* type) FindTypeByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostModule self, uint64 rva, out IDebugHostSymbol* symbol) FindSymbolByRVA;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostModule self, char16* symbolName, out IDebugHostSymbol* symbol) FindSymbolByName;
			}
		}
		[CRepr]
		public struct IDebugHostType : IDebugHostSymbol
		{
			public const new Guid IID = .(0x3aadc353, 0x2b14, 0x4abb, 0x98, 0x93, 0x5e, 0x03, 0x45, 0x8e, 0x07, 0xee);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetTypeKind(out TypeKind kind) mut => VT.GetTypeKind(ref this, out kind);
			public HResult GetSize(out uint64 size) mut => VT.GetSize(ref this, out size);
			public HResult GetBaseType(out IDebugHostType* baseType) mut => VT.GetBaseType(ref this, out baseType);
			public HResult GetHashCode(out uint32 hashCode) mut => VT.GetHashCode(ref this, out hashCode);
			public HResult GetIntrinsicType(IntrinsicKind* intrinsicKind, uint16* carrierType) mut => VT.GetIntrinsicType(ref this, intrinsicKind, carrierType);
			public HResult GetBitField(out uint32 lsbOfField, out uint32 lengthOfField) mut => VT.GetBitField(ref this, out lsbOfField, out lengthOfField);
			public HResult GetPointerKind(out PointerKind pointerKind) mut => VT.GetPointerKind(ref this, out pointerKind);
			public HResult GetMemberType(out IDebugHostType* memberType) mut => VT.GetMemberType(ref this, out memberType);
			public HResult CreatePointerTo(PointerKind kind, out IDebugHostType* newType) mut => VT.CreatePointerTo(ref this, kind, out newType);
			public HResult GetArrayDimensionality(out uint64 arrayDimensionality) mut => VT.GetArrayDimensionality(ref this, out arrayDimensionality);
			public HResult GetArrayDimensions(uint64 dimensions, ArrayDimension* pDimensions) mut => VT.GetArrayDimensions(ref this, dimensions, pDimensions);
			public HResult CreateArrayOf(uint64 dimensions, ArrayDimension* pDimensions, out IDebugHostType* newType) mut => VT.CreateArrayOf(ref this, dimensions, pDimensions, out newType);
			public HResult GetFunctionCallingConvention(out CallingConventionKind conventionKind) mut => VT.GetFunctionCallingConvention(ref this, out conventionKind);
			public HResult GetFunctionReturnType(out IDebugHostType* returnType) mut => VT.GetFunctionReturnType(ref this, out returnType);
			public HResult GetFunctionParameterTypeCount(out uint64 count) mut => VT.GetFunctionParameterTypeCount(ref this, out count);
			public HResult GetFunctionParameterTypeAt(uint64 i, out IDebugHostType* parameterType) mut => VT.GetFunctionParameterTypeAt(ref this, i, out parameterType);
			public HResult IsGeneric(out Boolean isGeneric) mut => VT.IsGeneric(ref this, out isGeneric);
			public HResult GetGenericArgumentCount(out uint64 argCount) mut => VT.GetGenericArgumentCount(ref this, out argCount);
			public HResult GetGenericArgumentAt(uint64 i, out IDebugHostSymbol* argument) mut => VT.GetGenericArgumentAt(ref this, i, out argument);

			[CRepr]
			public struct VTable : IDebugHostSymbol.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out TypeKind kind) GetTypeKind;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out uint64 size) GetSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out IDebugHostType* baseType) GetBaseType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out uint32 hashCode) GetHashCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, IntrinsicKind* intrinsicKind, uint16* carrierType) GetIntrinsicType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out uint32 lsbOfField, out uint32 lengthOfField) GetBitField;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out PointerKind pointerKind) GetPointerKind;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out IDebugHostType* memberType) GetMemberType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, PointerKind kind, out IDebugHostType* newType) CreatePointerTo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out uint64 arrayDimensionality) GetArrayDimensionality;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, uint64 dimensions, ArrayDimension* pDimensions) GetArrayDimensions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, uint64 dimensions, ArrayDimension* pDimensions, out IDebugHostType* newType) CreateArrayOf;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out CallingConventionKind conventionKind) GetFunctionCallingConvention;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out IDebugHostType* returnType) GetFunctionReturnType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out uint64 count) GetFunctionParameterTypeCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, uint64 i, out IDebugHostType* parameterType) GetFunctionParameterTypeAt;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out Boolean isGeneric) IsGeneric;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, out uint64 argCount) GetGenericArgumentCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType self, uint64 i, out IDebugHostSymbol* argument) GetGenericArgumentAt;
			}
		}
		[CRepr]
		public struct IDebugHostConstant : IDebugHostSymbol
		{
			public const new Guid IID = .(0x62787edc, 0xfa76, 0x4690, 0xbd, 0x71, 0x5e, 0x8c, 0x3e, 0x29, 0x37, 0xec);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetValue(out VARIANT value) mut => VT.GetValue(ref this, out value);

			[CRepr]
			public struct VTable : IDebugHostSymbol.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostConstant self, out VARIANT value) GetValue;
			}
		}
		[CRepr]
		public struct IDebugHostField : IDebugHostSymbol
		{
			public const new Guid IID = .(0xe06f6495, 0x16bc, 0x4cc9, 0xb1, 0x1d, 0x2a, 0x6b, 0x23, 0xfa, 0x72, 0xf3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetLocationKind(out LocationKind locationKind) mut => VT.GetLocationKind(ref this, out locationKind);
			public HResult GetOffset(out uint64 offset) mut => VT.GetOffset(ref this, out offset);
			public HResult GetLocation(out Location location) mut => VT.GetLocation(ref this, out location);
			public HResult GetValue(out VARIANT value) mut => VT.GetValue(ref this, out value);

			[CRepr]
			public struct VTable : IDebugHostSymbol.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostField self, out LocationKind locationKind) GetLocationKind;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostField self, out uint64 offset) GetOffset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostField self, out Location location) GetLocation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostField self, out VARIANT value) GetValue;
			}
		}
		[CRepr]
		public struct IDebugHostData : IDebugHostSymbol
		{
			public const new Guid IID = .(0xa3d64993, 0x826c, 0x44fa, 0x89, 0x7d, 0x92, 0x6f, 0x2f, 0xe7, 0xad, 0x0b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetLocationKind(out LocationKind locationKind) mut => VT.GetLocationKind(ref this, out locationKind);
			public HResult GetLocation(out Location location) mut => VT.GetLocation(ref this, out location);
			public HResult GetValue(out VARIANT value) mut => VT.GetValue(ref this, out value);

			[CRepr]
			public struct VTable : IDebugHostSymbol.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostData self, out LocationKind locationKind) GetLocationKind;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostData self, out Location location) GetLocation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostData self, out VARIANT value) GetValue;
			}
		}
		[CRepr]
		public struct IDebugHostPublic : IDebugHostSymbol
		{
			public const new Guid IID = .(0x6c597ac9, 0xfb4d, 0x4f6d, 0x9f, 0x39, 0x22, 0x48, 0x85, 0x39, 0xf8, 0xf4);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetLocationKind(out LocationKind locationKind) mut => VT.GetLocationKind(ref this, out locationKind);
			public HResult GetLocation(out Location location) mut => VT.GetLocation(ref this, out location);

			[CRepr]
			public struct VTable : IDebugHostSymbol.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostPublic self, out LocationKind locationKind) GetLocationKind;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostPublic self, out Location location) GetLocation;
			}
		}
		[CRepr]
		public struct IDebugHostBaseClass : IDebugHostSymbol
		{
			public const new Guid IID = .(0xb94d57d2, 0x390b, 0x40f7, 0xb5, 0xb4, 0xb6, 0xdb, 0x89, 0x7d, 0x97, 0x4b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetOffset(out uint64 offset) mut => VT.GetOffset(ref this, out offset);

			[CRepr]
			public struct VTable : IDebugHostSymbol.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostBaseClass self, out uint64 offset) GetOffset;
			}
		}
		[CRepr]
		public struct IDebugHostSymbols : IUnknown
		{
			public const new Guid IID = .(0x854fd751, 0xc2e1, 0x4eb2, 0xb5, 0x25, 0x66, 0x19, 0xcb, 0x97, 0xa5, 0x88);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CreateModuleSignature(char16* pwszModuleName, char16* pwszMinVersion, char16* pwszMaxVersion, out IDebugHostModuleSignature* ppModuleSignature) mut => VT.CreateModuleSignature(ref this, pwszModuleName, pwszMinVersion, pwszMaxVersion, out ppModuleSignature);
			public HResult CreateTypeSignature(char16* signatureSpecification, IDebugHostModule* module, out IDebugHostTypeSignature* typeSignature) mut => VT.CreateTypeSignature(ref this, signatureSpecification, module, out typeSignature);
			public HResult CreateTypeSignatureForModuleRange(char16* signatureSpecification, char16* moduleName, char16* minVersion, char16* maxVersion, out IDebugHostTypeSignature* typeSignature) mut => VT.CreateTypeSignatureForModuleRange(ref this, signatureSpecification, moduleName, minVersion, maxVersion, out typeSignature);
			public HResult EnumerateModules(ref IDebugHostContext context, out IDebugHostSymbolEnumerator* moduleEnum) mut => VT.EnumerateModules(ref this, ref context, out moduleEnum);
			public HResult FindModuleByName(ref IDebugHostContext context, char16* moduleName, out IDebugHostModule* module) mut => VT.FindModuleByName(ref this, ref context, moduleName, out module);
			public HResult FindModuleByLocation(ref IDebugHostContext context, Location moduleLocation, out IDebugHostModule* module) mut => VT.FindModuleByLocation(ref this, ref context, moduleLocation, out module);
			public HResult GetMostDerivedObject(IDebugHostContext* pContext, Location location, ref IDebugHostType objectType, out Location derivedLocation, out IDebugHostType* derivedType) mut => VT.GetMostDerivedObject(ref this, pContext, location, ref objectType, out derivedLocation, out derivedType);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbols self, char16* pwszModuleName, char16* pwszMinVersion, char16* pwszMaxVersion, out IDebugHostModuleSignature* ppModuleSignature) CreateModuleSignature;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbols self, char16* signatureSpecification, IDebugHostModule* module, out IDebugHostTypeSignature* typeSignature) CreateTypeSignature;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbols self, char16* signatureSpecification, char16* moduleName, char16* minVersion, char16* maxVersion, out IDebugHostTypeSignature* typeSignature) CreateTypeSignatureForModuleRange;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbols self, ref IDebugHostContext context, out IDebugHostSymbolEnumerator* moduleEnum) EnumerateModules;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbols self, ref IDebugHostContext context, char16* moduleName, out IDebugHostModule* module) FindModuleByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbols self, ref IDebugHostContext context, Location moduleLocation, out IDebugHostModule* module) FindModuleByLocation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbols self, IDebugHostContext* pContext, Location location, ref IDebugHostType objectType, out Location derivedLocation, out IDebugHostType* derivedType) GetMostDerivedObject;
			}
		}
		[CRepr]
		public struct IDebugHostMemory : IUnknown
		{
			public const new Guid IID = .(0x212149c9, 0x9183, 0x4a3e, 0xb0, 0x0e, 0x4f, 0xd1, 0xdc, 0x95, 0x33, 0x9b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ReadBytes(ref IDebugHostContext context, Location location, void* buffer, uint64 bufferSize, uint64* bytesRead) mut => VT.ReadBytes(ref this, ref context, location, buffer, bufferSize, bytesRead);
			public HResult WriteBytes(ref IDebugHostContext context, Location location, void* buffer, uint64 bufferSize, uint64* bytesWritten) mut => VT.WriteBytes(ref this, ref context, location, buffer, bufferSize, bytesWritten);
			public HResult ReadPointers(ref IDebugHostContext context, Location location, uint64 count, uint64* pointers) mut => VT.ReadPointers(ref this, ref context, location, count, pointers);
			public HResult WritePointers(ref IDebugHostContext context, Location location, uint64 count, uint64* pointers) mut => VT.WritePointers(ref this, ref context, location, count, pointers);
			public HResult GetDisplayStringForLocation(ref IDebugHostContext context, Location location, uint8 verbose, out char16* locationName) mut => VT.GetDisplayStringForLocation(ref this, ref context, location, verbose, out locationName);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostMemory self, ref IDebugHostContext context, Location location, void* buffer, uint64 bufferSize, uint64* bytesRead) ReadBytes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostMemory self, ref IDebugHostContext context, Location location, void* buffer, uint64 bufferSize, uint64* bytesWritten) WriteBytes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostMemory self, ref IDebugHostContext context, Location location, uint64 count, uint64* pointers) ReadPointers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostMemory self, ref IDebugHostContext context, Location location, uint64 count, uint64* pointers) WritePointers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostMemory self, ref IDebugHostContext context, Location location, uint8 verbose, out char16* locationName) GetDisplayStringForLocation;
			}
		}
		[CRepr]
		public struct IDebugHostEvaluator : IUnknown
		{
			public const new Guid IID = .(0x0fef9a21, 0x577e, 0x4997, 0xac, 0x7b, 0x1c, 0x48, 0x83, 0x24, 0x1d, 0x99);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EvaluateExpression(ref IDebugHostContext context, char16* expression, IModelObject* bindingContext, out IModelObject* result, IKeyStore** metadata) mut => VT.EvaluateExpression(ref this, ref context, expression, bindingContext, out result, metadata);
			public HResult EvaluateExtendedExpression(ref IDebugHostContext context, char16* expression, IModelObject* bindingContext, out IModelObject* result, IKeyStore** metadata) mut => VT.EvaluateExtendedExpression(ref this, ref context, expression, bindingContext, out result, metadata);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostEvaluator self, ref IDebugHostContext context, char16* expression, IModelObject* bindingContext, out IModelObject* result, IKeyStore** metadata) EvaluateExpression;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostEvaluator self, ref IDebugHostContext context, char16* expression, IModelObject* bindingContext, out IModelObject* result, IKeyStore** metadata) EvaluateExtendedExpression;
			}
		}
		[CRepr]
		public struct IDebugHostModuleSignature : IUnknown
		{
			public const new Guid IID = .(0x31e53a5a, 0x01ee, 0x4bbb, 0xb8, 0x99, 0x4b, 0x46, 0xae, 0x7d, 0x59, 0x5c);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult IsMatch(ref IDebugHostModule pModule, out Boolean isMatch) mut => VT.IsMatch(ref this, ref pModule, out isMatch);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostModuleSignature self, ref IDebugHostModule pModule, out Boolean isMatch) IsMatch;
			}
		}
		[CRepr]
		public struct IDebugHostTypeSignature : IUnknown
		{
			public const new Guid IID = .(0x3aadc353, 0x2b14, 0x4abb, 0x98, 0x93, 0x5e, 0x03, 0x45, 0x8e, 0x07, 0xee);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetHashCode(out uint32 hashCode) mut => VT.GetHashCode(ref this, out hashCode);
			public HResult IsMatch(ref IDebugHostType type, out Boolean isMatch, IDebugHostSymbolEnumerator** wildcardMatches) mut => VT.IsMatch(ref this, ref type, out isMatch, wildcardMatches);
			public HResult CompareAgainst(ref IDebugHostTypeSignature typeSignature, out SignatureComparison result) mut => VT.CompareAgainst(ref this, ref typeSignature, out result);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostTypeSignature self, out uint32 hashCode) GetHashCode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostTypeSignature self, ref IDebugHostType type, out Boolean isMatch, IDebugHostSymbolEnumerator** wildcardMatches) IsMatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostTypeSignature self, ref IDebugHostTypeSignature typeSignature, out SignatureComparison result) CompareAgainst;
			}
		}
		[CRepr]
		public struct IDebugHostSymbol2 : IDebugHostSymbol
		{
			public const new Guid IID = .(0x21515b67, 0x6720, 0x4257, 0x8a, 0x68, 0x07, 0x7d, 0xc9, 0x44, 0x47, 0x1c);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetLanguage(out LanguageKind pKind) mut => VT.GetLanguage(ref this, out pKind);

			[CRepr]
			public struct VTable : IDebugHostSymbol.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostSymbol2 self, out LanguageKind pKind) GetLanguage;
			}
		}
		[CRepr]
		public struct IDebugHostType2 : IDebugHostType
		{
			public const new Guid IID = .(0xb28632b9, 0x8506, 0x4676, 0x87, 0xce, 0x8f, 0x7e, 0x05, 0xe5, 0x98, 0x76);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult IsTypedef(out Boolean isTypedef) mut => VT.IsTypedef(ref this, out isTypedef);
			public HResult GetTypedefBaseType(out IDebugHostType2* baseType) mut => VT.GetTypedefBaseType(ref this, out baseType);
			public HResult GetTypedefFinalBaseType(out IDebugHostType2* finalBaseType) mut => VT.GetTypedefFinalBaseType(ref this, out finalBaseType);
			public HResult GetFunctionVarArgsKind(out VarArgsKind varArgsKind) mut => VT.GetFunctionVarArgsKind(ref this, out varArgsKind);
			public HResult GetFunctionInstancePointerType(out IDebugHostType2* instancePointerType) mut => VT.GetFunctionInstancePointerType(ref this, out instancePointerType);

			[CRepr]
			public struct VTable : IDebugHostType.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType2 self, out Boolean isTypedef) IsTypedef;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType2 self, out IDebugHostType2* baseType) GetTypedefBaseType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType2 self, out IDebugHostType2* finalBaseType) GetTypedefFinalBaseType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType2 self, out VarArgsKind varArgsKind) GetFunctionVarArgsKind;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostType2 self, out IDebugHostType2* instancePointerType) GetFunctionInstancePointerType;
			}
		}
		[CRepr]
		public struct IDebugHostStatus : IUnknown
		{
			public const new Guid IID = .(0x4f3e1ce2, 0x86b2, 0x4c7a, 0x9c, 0x65, 0xd0, 0xa9, 0xd0, 0xee, 0xcf, 0x44);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult PollUserInterrupt(out Boolean interruptRequested) mut => VT.PollUserInterrupt(ref this, out interruptRequested);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostStatus self, out Boolean interruptRequested) PollUserInterrupt;
			}
		}
		[CRepr]
		public struct IDataModelScriptClient : IUnknown
		{
			public const new Guid IID = .(0x3b362b0e, 0x89f0, 0x46c6, 0xa6, 0x63, 0xdf, 0xdc, 0x95, 0x19, 0x4a, 0xef);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ReportError(ErrorClass errClass, HResult hrFail, char16* message, uint32 line, uint32 position) mut => VT.ReportError(ref this, errClass, hrFail, message, line, position);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptClient self, ErrorClass errClass, HResult hrFail, char16* message, uint32 line, uint32 position) ReportError;
			}
		}
		[CRepr]
		public struct IDataModelScriptTemplate : IUnknown
		{
			public const new Guid IID = .(0x1303dec4, 0xfa3b, 0x4f1b, 0x92, 0x24, 0xb9, 0x53, 0xd1, 0x6b, 0xab, 0xb5);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetName(out char16* templateName) mut => VT.GetName(ref this, out templateName);
			public HResult GetDescription(out char16* templateDescription) mut => VT.GetDescription(ref this, out templateDescription);
			public HResult GetContent(out IStream* contentStream) mut => VT.GetContent(ref this, out contentStream);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptTemplate self, out char16* templateName) GetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptTemplate self, out char16* templateDescription) GetDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptTemplate self, out IStream* contentStream) GetContent;
			}
		}
		[CRepr]
		public struct IDataModelScript : IUnknown
		{
			public const new Guid IID = .(0x7b4d30fc, 0xb14a, 0x49f8, 0x8d, 0x87, 0xd9, 0xa1, 0x48, 0x0c, 0x97, 0xf7);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetName(out char16* scriptName) mut => VT.GetName(ref this, out scriptName);
			public HResult Rename(char16* scriptName) mut => VT.Rename(ref this, scriptName);
			public HResult Populate(ref IStream contentStream) mut => VT.Populate(ref this, ref contentStream);
			public HResult Execute(ref IDataModelScriptClient client) mut => VT.Execute(ref this, ref client);
			public HResult Unlink() mut => VT.Unlink(ref this);
			public HResult IsInvocable(out Boolean isInvocable) mut => VT.IsInvocable(ref this, out isInvocable);
			public HResult InvokeMain(ref IDataModelScriptClient client) mut => VT.InvokeMain(ref this, ref client);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScript self, out char16* scriptName) GetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScript self, char16* scriptName) Rename;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScript self, ref IStream contentStream) Populate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScript self, ref IDataModelScriptClient client) Execute;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScript self) Unlink;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScript self, out Boolean isInvocable) IsInvocable;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScript self, ref IDataModelScriptClient client) InvokeMain;
			}
		}
		[CRepr]
		public struct IDataModelScriptTemplateEnumerator : IUnknown
		{
			public const new Guid IID = .(0x69ce6ae2, 0x2268, 0x4e6f, 0xb0, 0x62, 0x20, 0xce, 0x62, 0xbf, 0xe6, 0x77);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult GetNext(out IDataModelScriptTemplate* templateContent) mut => VT.GetNext(ref this, out templateContent);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptTemplateEnumerator self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptTemplateEnumerator self, out IDataModelScriptTemplate* templateContent) GetNext;
			}
		}
		[CRepr]
		public struct IDataModelScriptProvider : IUnknown
		{
			public const new Guid IID = .(0x513461e0, 0x4fca, 0x48ce, 0x86, 0x58, 0x32, 0xf3, 0xe2, 0x05, 0x6f, 0x3b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetName(out char16* name) mut => VT.GetName(ref this, out name);
			public HResult GetExtension(out char16* @extension) mut => VT.GetExtension(ref this, out @extension);
			public HResult CreateScript(out IDataModelScript* script) mut => VT.CreateScript(ref this, out script);
			public HResult GetDefaultTemplateContent(out IDataModelScriptTemplate* templateContent) mut => VT.GetDefaultTemplateContent(ref this, out templateContent);
			public HResult EnumerateTemplates(out IDataModelScriptTemplateEnumerator* enumerator) mut => VT.EnumerateTemplates(ref this, out enumerator);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptProvider self, out char16* name) GetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptProvider self, out char16* @extension) GetExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptProvider self, out IDataModelScript* script) CreateScript;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptProvider self, out IDataModelScriptTemplate* templateContent) GetDefaultTemplateContent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptProvider self, out IDataModelScriptTemplateEnumerator* enumerator) EnumerateTemplates;
			}
		}
		[CRepr]
		public struct IDataModelScriptProviderEnumerator : IUnknown
		{
			public const new Guid IID = .(0x95ba00e2, 0x704a, 0x4fe2, 0xa8, 0xf1, 0xa7, 0xe7, 0xd8, 0xfb, 0x09, 0x41);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult GetNext(out IDataModelScriptProvider* provider) mut => VT.GetNext(ref this, out provider);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptProviderEnumerator self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptProviderEnumerator self, out IDataModelScriptProvider* provider) GetNext;
			}
		}
		[CRepr]
		public struct IDataModelScriptManager : IUnknown
		{
			public const new Guid IID = .(0x6fd11e33, 0xe5ad, 0x410b, 0x80, 0x11, 0x68, 0xc6, 0xbc, 0x4b, 0xf8, 0x0d);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDefaultNameBinder(out IDataModelNameBinder* ppNameBinder) mut => VT.GetDefaultNameBinder(ref this, out ppNameBinder);
			public HResult RegisterScriptProvider(ref IDataModelScriptProvider provider) mut => VT.RegisterScriptProvider(ref this, ref provider);
			public HResult UnregisterScriptProvider(ref IDataModelScriptProvider provider) mut => VT.UnregisterScriptProvider(ref this, ref provider);
			public HResult FindProviderForScriptType(char16* scriptType, out IDataModelScriptProvider* provider) mut => VT.FindProviderForScriptType(ref this, scriptType, out provider);
			public HResult FindProviderForScriptExtension(char16* scriptExtension, out IDataModelScriptProvider* provider) mut => VT.FindProviderForScriptExtension(ref this, scriptExtension, out provider);
			public HResult EnumerateScriptProviders(out IDataModelScriptProviderEnumerator* enumerator) mut => VT.EnumerateScriptProviders(ref this, out enumerator);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptManager self, out IDataModelNameBinder* ppNameBinder) GetDefaultNameBinder;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptManager self, ref IDataModelScriptProvider provider) RegisterScriptProvider;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptManager self, ref IDataModelScriptProvider provider) UnregisterScriptProvider;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptManager self, char16* scriptType, out IDataModelScriptProvider* provider) FindProviderForScriptType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptManager self, char16* scriptExtension, out IDataModelScriptProvider* provider) FindProviderForScriptExtension;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptManager self, out IDataModelScriptProviderEnumerator* enumerator) EnumerateScriptProviders;
			}
		}
		[CRepr]
		public struct IDynamicKeyProviderConcept : IUnknown
		{
			public const new Guid IID = .(0xe7983fa1, 0x80a7, 0x498c, 0x98, 0x8f, 0x51, 0x8d, 0xdc, 0x5d, 0x40, 0x25);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetKey(ref IModelObject contextObject, char16* key, IModelObject** keyValue, IKeyStore** metadata, Boolean* hasKey) mut => VT.GetKey(ref this, ref contextObject, key, keyValue, metadata, hasKey);
			public HResult SetKey(ref IModelObject contextObject, char16* key, ref IModelObject keyValue, ref IKeyStore metadata) mut => VT.SetKey(ref this, ref contextObject, key, ref keyValue, ref metadata);
			public HResult EnumerateKeys(ref IModelObject contextObject, out IKeyEnumerator* ppEnumerator) mut => VT.EnumerateKeys(ref this, ref contextObject, out ppEnumerator);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDynamicKeyProviderConcept self, ref IModelObject contextObject, char16* key, IModelObject** keyValue, IKeyStore** metadata, Boolean* hasKey) GetKey;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDynamicKeyProviderConcept self, ref IModelObject contextObject, char16* key, ref IModelObject keyValue, ref IKeyStore metadata) SetKey;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDynamicKeyProviderConcept self, ref IModelObject contextObject, out IKeyEnumerator* ppEnumerator) EnumerateKeys;
			}
		}
		[CRepr]
		public struct IDynamicConceptProviderConcept : IUnknown
		{
			public const new Guid IID = .(0x95a7f7dd, 0x602e, 0x483f, 0x9d, 0x06, 0xa1, 0x5c, 0x0e, 0xe1, 0x31, 0x74);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetConcept(ref IModelObject contextObject, in Guid conceptId, IUnknown** conceptInterface, IKeyStore** conceptMetadata, out Boolean hasConcept) mut => VT.GetConcept(ref this, ref contextObject, conceptId, conceptInterface, conceptMetadata, out hasConcept);
			public HResult SetConcept(ref IModelObject contextObject, in Guid conceptId, ref IUnknown conceptInterface, IKeyStore* conceptMetadata) mut => VT.SetConcept(ref this, ref contextObject, conceptId, ref conceptInterface, conceptMetadata);
			public HResult NotifyParent(ref IModelObject parentModel) mut => VT.NotifyParent(ref this, ref parentModel);
			public HResult NotifyParentChange(ref IModelObject parentModel) mut => VT.NotifyParentChange(ref this, ref parentModel);
			public HResult NotifyDestruct() mut => VT.NotifyDestruct(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDynamicConceptProviderConcept self, ref IModelObject contextObject, in Guid conceptId, IUnknown** conceptInterface, IKeyStore** conceptMetadata, out Boolean hasConcept) GetConcept;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDynamicConceptProviderConcept self, ref IModelObject contextObject, in Guid conceptId, ref IUnknown conceptInterface, IKeyStore* conceptMetadata) SetConcept;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDynamicConceptProviderConcept self, ref IModelObject parentModel) NotifyParent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDynamicConceptProviderConcept self, ref IModelObject parentModel) NotifyParentChange;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDynamicConceptProviderConcept self) NotifyDestruct;
			}
		}
		[CRepr]
		public struct IDataModelScriptHostContext : IUnknown
		{
			public const new Guid IID = .(0x014d366a, 0x1f23, 0x4981, 0x92, 0x19, 0xb2, 0xdb, 0x8b, 0x40, 0x20, 0x54);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult NotifyScriptChange(ref IDataModelScript script, ScriptChangeKind changeKind) mut => VT.NotifyScriptChange(ref this, ref script, changeKind);
			public HResult GetNamespaceObject(out IModelObject* namespaceObject) mut => VT.GetNamespaceObject(ref this, out namespaceObject);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptHostContext self, ref IDataModelScript script, ScriptChangeKind changeKind) NotifyScriptChange;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptHostContext self, out IModelObject* namespaceObject) GetNamespaceObject;
			}
		}
		[CRepr]
		public struct IDebugHostScriptHost : IUnknown
		{
			public const new Guid IID = .(0xb70334a4, 0xb92c, 0x4570, 0x93, 0xa1, 0xd3, 0xeb, 0x68, 0x66, 0x49, 0xa0);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CreateContext(ref IDataModelScript script, out IDataModelScriptHostContext* scriptContext) mut => VT.CreateContext(ref this, ref script, out scriptContext);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostScriptHost self, ref IDataModelScript script, out IDataModelScriptHostContext* scriptContext) CreateContext;
			}
		}
		[CRepr]
		public struct IDataModelNameBinder : IUnknown
		{
			public const new Guid IID = .(0xaf352b7b, 0x8292, 0x4c01, 0xb3, 0x60, 0x2d, 0xc3, 0x69, 0x6c, 0x65, 0xe7);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult BindValue(ref IModelObject contextObject, char16* name, out IModelObject* value, IKeyStore** metadata) mut => VT.BindValue(ref this, ref contextObject, name, out value, metadata);
			public HResult BindReference(ref IModelObject contextObject, char16* name, out IModelObject* reference, IKeyStore** metadata) mut => VT.BindReference(ref this, ref contextObject, name, out reference, metadata);
			public HResult EnumerateValues(ref IModelObject contextObject, out IKeyEnumerator* enumerator) mut => VT.EnumerateValues(ref this, ref contextObject, out enumerator);
			public HResult EnumerateReferences(ref IModelObject contextObject, out IKeyEnumerator* enumerator) mut => VT.EnumerateReferences(ref this, ref contextObject, out enumerator);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelNameBinder self, ref IModelObject contextObject, char16* name, out IModelObject* value, IKeyStore** metadata) BindValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelNameBinder self, ref IModelObject contextObject, char16* name, out IModelObject* reference, IKeyStore** metadata) BindReference;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelNameBinder self, ref IModelObject contextObject, out IKeyEnumerator* enumerator) EnumerateValues;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelNameBinder self, ref IModelObject contextObject, out IKeyEnumerator* enumerator) EnumerateReferences;
			}
		}
		[CRepr]
		public struct IModelKeyReference2 : IModelKeyReference
		{
			public const new Guid IID = .(0x80e2f7c5, 0x7159, 0x4e92, 0x88, 0x7e, 0x7e, 0x03, 0x47, 0xe8, 0x84, 0x06);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult OverrideContextObject(ref IModelObject newContextObject) mut => VT.OverrideContextObject(ref this, ref newContextObject);

			[CRepr]
			public struct VTable : IModelKeyReference.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IModelKeyReference2 self, ref IModelObject newContextObject) OverrideContextObject;
			}
		}
		[CRepr]
		public struct IDebugHostEvaluator2 : IDebugHostEvaluator
		{
			public const new Guid IID = .(0xa117a435, 0x1fb4, 0x4092, 0xa2, 0xab, 0xa9, 0x29, 0x57, 0x6c, 0x1e, 0x87);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AssignTo(ref IModelObject assignmentReference, ref IModelObject assignmentValue, out IModelObject* assignmentResult, IKeyStore** assignmentMetadata) mut => VT.AssignTo(ref this, ref assignmentReference, ref assignmentValue, out assignmentResult, assignmentMetadata);

			[CRepr]
			public struct VTable : IDebugHostEvaluator.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostEvaluator2 self, ref IModelObject assignmentReference, ref IModelObject assignmentValue, out IModelObject* assignmentResult, IKeyStore** assignmentMetadata) AssignTo;
			}
		}
		[CRepr]
		public struct IDataModelManager2 : IDataModelManager
		{
			public const new Guid IID = .(0xf412c5ea, 0x2284, 0x4622, 0xa6, 0x60, 0xa6, 0x97, 0x16, 0x0d, 0x33, 0x12);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AcquireSubNamespace(char16* modelName, char16* subNamespaceModelName, char16* accessName, IKeyStore* metadata, out IModelObject* namespaceModelObject) mut => VT.AcquireSubNamespace(ref this, modelName, subNamespaceModelName, accessName, metadata, out namespaceModelObject);
			public HResult CreateTypedIntrinsicObjectEx(IDebugHostContext* context, ref VARIANT intrinsicData, ref IDebugHostType type, out IModelObject* object) mut => VT.CreateTypedIntrinsicObjectEx(ref this, context, ref intrinsicData, ref type, out object);

			[CRepr]
			public struct VTable : IDataModelManager.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager2 self, char16* modelName, char16* subNamespaceModelName, char16* accessName, IKeyStore* metadata, out IModelObject* namespaceModelObject) AcquireSubNamespace;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelManager2 self, IDebugHostContext* context, ref VARIANT intrinsicData, ref IDebugHostType type, out IModelObject* object) CreateTypedIntrinsicObjectEx;
			}
		}
		[CRepr]
		public struct IDebugHostMemory2 : IDebugHostMemory
		{
			public const new Guid IID = .(0xeea033de, 0x38f6, 0x416b, 0xa2, 0x51, 0x1d, 0x37, 0x71, 0x00, 0x12, 0x70);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult LinearizeLocation(ref IDebugHostContext context, Location location, out Location pLinearizedLocation) mut => VT.LinearizeLocation(ref this, ref context, location, out pLinearizedLocation);

			[CRepr]
			public struct VTable : IDebugHostMemory.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostMemory2 self, ref IDebugHostContext context, Location location, out Location pLinearizedLocation) LinearizeLocation;
			}
		}
		[CRepr]
		public struct IDebugHostExtensibility : IUnknown
		{
			public const new Guid IID = .(0x3c2b24e1, 0x11d0, 0x4f86, 0x8a, 0xe5, 0x4d, 0xf1, 0x66, 0xf7, 0x32, 0x53);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CreateFunctionAlias(char16* aliasName, ref IModelObject functionObject) mut => VT.CreateFunctionAlias(ref this, aliasName, ref functionObject);
			public HResult DestroyFunctionAlias(char16* aliasName) mut => VT.DestroyFunctionAlias(ref this, aliasName);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostExtensibility self, char16* aliasName, ref IModelObject functionObject) CreateFunctionAlias;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostExtensibility self, char16* aliasName) DestroyFunctionAlias;
			}
		}
		[CRepr]
		public struct IDataModelScriptDebugClient : IUnknown
		{
			public const new Guid IID = .(0x53159b6d, 0xd4c4, 0x471b, 0xa8, 0x63, 0x5b, 0x11, 0x0c, 0xa8, 0x00, 0xca);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult NotifyDebugEvent(ref ScriptDebugEventInformation pEventInfo, ref IDataModelScript pScript, IModelObject* pEventDataObject, out ScriptExecutionKind resumeEventKind) mut => VT.NotifyDebugEvent(ref this, ref pEventInfo, ref pScript, pEventDataObject, out resumeEventKind);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugClient self, ref ScriptDebugEventInformation pEventInfo, ref IDataModelScript pScript, IModelObject* pEventDataObject, out ScriptExecutionKind resumeEventKind) NotifyDebugEvent;
			}
		}
		[CRepr]
		public struct IDataModelScriptDebugVariableSetEnumerator : IUnknown
		{
			public const new Guid IID = .(0x0f9feed7, 0xd045, 0x4ac3, 0x98, 0xa8, 0xa9, 0x89, 0x42, 0xcf, 0x6a, 0x35);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult GetNext(out char16* variableName, IModelObject** variableValue, IKeyStore** variableMetadata) mut => VT.GetNext(ref this, out variableName, variableValue, variableMetadata);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugVariableSetEnumerator self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugVariableSetEnumerator self, out char16* variableName, IModelObject** variableValue, IKeyStore** variableMetadata) GetNext;
			}
		}
		[CRepr]
		public struct IDataModelScriptDebugStackFrame : IUnknown
		{
			public const new Guid IID = .(0xdec6ed5e, 0x6360, 0x4941, 0xab, 0x4c, 0xa2, 0x64, 0x09, 0xde, 0x4f, 0x82);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetName(out char16* name) mut => VT.GetName(ref this, out name);
			public HResult GetPosition(out ScriptDebugPosition position, ScriptDebugPosition* positionSpanEnd, char16** lineText) mut => VT.GetPosition(ref this, out position, positionSpanEnd, lineText);
			public HResult IsTransitionPoint(out Boolean isTransitionPoint) mut => VT.IsTransitionPoint(ref this, out isTransitionPoint);
			public HResult GetTransition(out IDataModelScript* transitionScript, out Boolean isTransitionContiguous) mut => VT.GetTransition(ref this, out transitionScript, out isTransitionContiguous);
			public HResult Evaluate(char16* pwszExpression, out IModelObject* ppResult) mut => VT.Evaluate(ref this, pwszExpression, out ppResult);
			public HResult EnumerateLocals(out IDataModelScriptDebugVariableSetEnumerator* variablesEnum) mut => VT.EnumerateLocals(ref this, out variablesEnum);
			public HResult EnumerateArguments(out IDataModelScriptDebugVariableSetEnumerator* variablesEnum) mut => VT.EnumerateArguments(ref this, out variablesEnum);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugStackFrame self, out char16* name) GetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugStackFrame self, out ScriptDebugPosition position, ScriptDebugPosition* positionSpanEnd, char16** lineText) GetPosition;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugStackFrame self, out Boolean isTransitionPoint) IsTransitionPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugStackFrame self, out IDataModelScript* transitionScript, out Boolean isTransitionContiguous) GetTransition;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugStackFrame self, char16* pwszExpression, out IModelObject* ppResult) Evaluate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugStackFrame self, out IDataModelScriptDebugVariableSetEnumerator* variablesEnum) EnumerateLocals;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugStackFrame self, out IDataModelScriptDebugVariableSetEnumerator* variablesEnum) EnumerateArguments;
			}
		}
		[CRepr]
		public struct IDataModelScriptDebugStack : IUnknown
		{
			public const new Guid IID = .(0x051364dd, 0xe449, 0x443e, 0x97, 0x62, 0xfe, 0x57, 0x8f, 0x4a, 0x54, 0x73);
			
			public new VTable* VT { get => (.)vt; }
			
			public uint64 GetFrameCount() mut => VT.GetFrameCount(ref this);
			public HResult GetStackFrame(uint64 frameNumber, out IDataModelScriptDebugStackFrame* stackFrame) mut => VT.GetStackFrame(ref this, frameNumber, out stackFrame);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] uint64(ref IDataModelScriptDebugStack self) GetFrameCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugStack self, uint64 frameNumber, out IDataModelScriptDebugStackFrame* stackFrame) GetStackFrame;
			}
		}
		[CRepr]
		public struct IDataModelScriptDebugBreakpoint : IUnknown
		{
			public const new Guid IID = .(0x6bb27b35, 0x02e6, 0x47cb, 0x90, 0xa0, 0x53, 0x71, 0x24, 0x40, 0x32, 0xde);
			
			public new VTable* VT { get => (.)vt; }
			
			public uint64 GetId() mut => VT.GetId(ref this);
			public Boolean IsEnabled() mut => VT.IsEnabled(ref this);
			public void Enable() mut => VT.Enable(ref this);
			public void Disable() mut => VT.Disable(ref this);
			public void Remove() mut => VT.Remove(ref this);
			public HResult GetPosition(out ScriptDebugPosition position, ScriptDebugPosition* positionSpanEnd, char16** lineText) mut => VT.GetPosition(ref this, out position, positionSpanEnd, lineText);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] uint64(ref IDataModelScriptDebugBreakpoint self) GetId;
				public new function [CallingConvention(.Stdcall)] Boolean(ref IDataModelScriptDebugBreakpoint self) IsEnabled;
				public new function [CallingConvention(.Stdcall)] void(ref IDataModelScriptDebugBreakpoint self) Enable;
				public new function [CallingConvention(.Stdcall)] void(ref IDataModelScriptDebugBreakpoint self) Disable;
				public new function [CallingConvention(.Stdcall)] void(ref IDataModelScriptDebugBreakpoint self) Remove;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugBreakpoint self, out ScriptDebugPosition position, ScriptDebugPosition* positionSpanEnd, char16** lineText) GetPosition;
			}
		}
		[CRepr]
		public struct IDataModelScriptDebugBreakpointEnumerator : IUnknown
		{
			public const new Guid IID = .(0x39484a75, 0xb4f3, 0x4799, 0x86, 0xda, 0x69, 0x1a, 0xfa, 0x57, 0xb2, 0x99);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult GetNext(out IDataModelScriptDebugBreakpoint* breakpoint) mut => VT.GetNext(ref this, out breakpoint);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugBreakpointEnumerator self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebugBreakpointEnumerator self, out IDataModelScriptDebugBreakpoint* breakpoint) GetNext;
			}
		}
		[CRepr]
		public struct IDataModelScriptDebug : IUnknown
		{
			public const new Guid IID = .(0xde8e0945, 0x9750, 0x4471, 0xab, 0x76, 0xa8, 0xf7, 0x9d, 0x6e, 0xc3, 0x50);
			
			public new VTable* VT { get => (.)vt; }
			
			public ScriptDebugState GetDebugState() mut => VT.GetDebugState(ref this);
			public HResult GetCurrentPosition(out ScriptDebugPosition currentPosition, ScriptDebugPosition* positionSpanEnd, char16** lineText) mut => VT.GetCurrentPosition(ref this, out currentPosition, positionSpanEnd, lineText);
			public HResult GetStack(out IDataModelScriptDebugStack* @stack) mut => VT.GetStack(ref this, out @stack);
			public HResult SetBreakpoint(uint32 linePosition, uint32 columnPosition, out IDataModelScriptDebugBreakpoint* breakpoint) mut => VT.SetBreakpoint(ref this, linePosition, columnPosition, out breakpoint);
			public HResult FindBreakpointById(uint64 breakpointId, out IDataModelScriptDebugBreakpoint* breakpoint) mut => VT.FindBreakpointById(ref this, breakpointId, out breakpoint);
			public HResult EnumerateBreakpoints(out IDataModelScriptDebugBreakpointEnumerator* breakpointEnum) mut => VT.EnumerateBreakpoints(ref this, out breakpointEnum);
			public HResult GetEventFilter(ScriptDebugEventFilter eventFilter, out Boolean isBreakEnabled) mut => VT.GetEventFilter(ref this, eventFilter, out isBreakEnabled);
			public HResult SetEventFilter(ScriptDebugEventFilter eventFilter, uint8 isBreakEnabled) mut => VT.SetEventFilter(ref this, eventFilter, isBreakEnabled);
			public HResult StartDebugging(ref IDataModelScriptDebugClient debugClient) mut => VT.StartDebugging(ref this, ref debugClient);
			public HResult StopDebugging(ref IDataModelScriptDebugClient debugClient) mut => VT.StopDebugging(ref this, ref debugClient);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] ScriptDebugState(ref IDataModelScriptDebug self) GetDebugState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug self, out ScriptDebugPosition currentPosition, ScriptDebugPosition* positionSpanEnd, char16** lineText) GetCurrentPosition;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug self, out IDataModelScriptDebugStack* @stack) GetStack;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug self, uint32 linePosition, uint32 columnPosition, out IDataModelScriptDebugBreakpoint* breakpoint) SetBreakpoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug self, uint64 breakpointId, out IDataModelScriptDebugBreakpoint* breakpoint) FindBreakpointById;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug self, out IDataModelScriptDebugBreakpointEnumerator* breakpointEnum) EnumerateBreakpoints;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug self, ScriptDebugEventFilter eventFilter, out Boolean isBreakEnabled) GetEventFilter;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug self, ScriptDebugEventFilter eventFilter, uint8 isBreakEnabled) SetEventFilter;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug self, ref IDataModelScriptDebugClient debugClient) StartDebugging;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug self, ref IDataModelScriptDebugClient debugClient) StopDebugging;
			}
		}
		[CRepr]
		public struct IDataModelScriptDebug2 : IDataModelScriptDebug
		{
			public const new Guid IID = .(0xcbb10ed3, 0x839e, 0x426c, 0x92, 0x43, 0xe2, 0x35, 0x35, 0xc1, 0xae, 0x1a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SetBreakpointAtFunction(char16* functionName, out IDataModelScriptDebugBreakpoint* breakpoint) mut => VT.SetBreakpointAtFunction(ref this, functionName, out breakpoint);

			[CRepr]
			public struct VTable : IDataModelScriptDebug.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDataModelScriptDebug2 self, char16* functionName, out IDataModelScriptDebugBreakpoint* breakpoint) SetBreakpointAtFunction;
			}
		}
		[CRepr]
		public struct IDebugHostModule2 : IDebugHostModule
		{
			public const new Guid IID = .(0xb51887e8, 0xbcd0, 0x4e8f, 0xa8, 0xc7, 0x43, 0x43, 0x98, 0xb7, 0x8c, 0x37);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult FindContainingSymbolByRVA(uint64 rva, out IDebugHostSymbol* symbol, out uint64 offset) mut => VT.FindContainingSymbolByRVA(ref this, rva, out symbol, out offset);

			[CRepr]
			public struct VTable : IDebugHostModule.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHostModule2 self, uint64 rva, out IDebugHostSymbol* symbol, out uint64 offset) FindContainingSymbolByRVA;
			}
		}
		[CRepr]
		public struct IComparableConcept : IUnknown
		{
			public const new Guid IID = .(0xa7830646, 0x9f0c, 0x4a31, 0xba, 0x19, 0x50, 0x3f, 0x33, 0xe6, 0xc8, 0xa3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CompareObjects(ref IModelObject contextObject, ref IModelObject otherObject, out int32 comparisonResult) mut => VT.CompareObjects(ref this, ref contextObject, ref otherObject, out comparisonResult);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IComparableConcept self, ref IModelObject contextObject, ref IModelObject otherObject, out int32 comparisonResult) CompareObjects;
			}
		}
		[CRepr]
		public struct IEquatableConcept : IUnknown
		{
			public const new Guid IID = .(0xc52d5d3d, 0x609d, 0x4d5d, 0x8a, 0x82, 0x46, 0xb0, 0xac, 0xde, 0xc4, 0xf4);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AreObjectsEqual(ref IModelObject contextObject, ref IModelObject otherObject, out Boolean isEqual) mut => VT.AreObjectsEqual(ref this, ref contextObject, ref otherObject, out isEqual);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEquatableConcept self, ref IModelObject contextObject, ref IModelObject otherObject, out Boolean isEqual) AreObjectsEqual;
			}
		}
		[CRepr]
		public struct IActiveScriptSite : IUnknown
		{
			public const new Guid IID = .(0xdb01a1e3, 0xa42b, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetLCID(out uint32 plcid) mut => VT.GetLCID(ref this, out plcid);
			public HResult GetItemInfo(char16* pstrName, uint32 dwReturnMask, out IUnknown* ppiunkItem, out ITypeInfo* ppti) mut => VT.GetItemInfo(ref this, pstrName, dwReturnMask, out ppiunkItem, out ppti);
			public HResult GetDocVersionString(out char16* pbstrVersion) mut => VT.GetDocVersionString(ref this, out pbstrVersion);
			public HResult OnScriptTerminate(in VARIANT pvarResult, in EXCEPINFO pexcepinfo) mut => VT.OnScriptTerminate(ref this, pvarResult, pexcepinfo);
			public HResult OnStateChange(SCRIPTSTATE ssScriptState) mut => VT.OnStateChange(ref this, ssScriptState);
			public HResult OnScriptError(ref IActiveScriptError pscripterror) mut => VT.OnScriptError(ref this, ref pscripterror);
			public HResult OnEnterScript() mut => VT.OnEnterScript(ref this);
			public HResult OnLeaveScript() mut => VT.OnLeaveScript(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSite self, out uint32 plcid) GetLCID;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSite self, char16* pstrName, uint32 dwReturnMask, out IUnknown* ppiunkItem, out ITypeInfo* ppti) GetItemInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSite self, out char16* pbstrVersion) GetDocVersionString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSite self, in VARIANT pvarResult, in EXCEPINFO pexcepinfo) OnScriptTerminate;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSite self, SCRIPTSTATE ssScriptState) OnStateChange;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSite self, ref IActiveScriptError pscripterror) OnScriptError;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSite self) OnEnterScript;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSite self) OnLeaveScript;
			}
		}
		[CRepr]
		public struct IActiveScriptError : IUnknown
		{
			public const new Guid IID = .(0xeae1ba61, 0xa4ed, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetExceptionInfo(out EXCEPINFO pexcepinfo) mut => VT.GetExceptionInfo(ref this, out pexcepinfo);
			public HResult GetSourcePosition(out uint32 pdwSourceContext, out uint32 pulLineNumber, out int32 plCharacterPosition) mut => VT.GetSourcePosition(ref this, out pdwSourceContext, out pulLineNumber, out plCharacterPosition);
			public HResult GetSourceLineText(out char16* pbstrSourceLine) mut => VT.GetSourceLineText(ref this, out pbstrSourceLine);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptError self, out EXCEPINFO pexcepinfo) GetExceptionInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptError self, out uint32 pdwSourceContext, out uint32 pulLineNumber, out int32 plCharacterPosition) GetSourcePosition;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptError self, out char16* pbstrSourceLine) GetSourceLineText;
			}
		}
		[CRepr]
		public struct IActiveScriptError64 : IActiveScriptError
		{
			public const new Guid IID = .(0xb21fb2a1, 0x5b8f, 0x4963, 0x8c, 0x21, 0x21, 0x45, 0x0f, 0x84, 0xed, 0x7f);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSourcePosition64(out uint64 pdwSourceContext, out uint32 pulLineNumber, out int32 plCharacterPosition) mut => VT.GetSourcePosition64(ref this, out pdwSourceContext, out pulLineNumber, out plCharacterPosition);

			[CRepr]
			public struct VTable : IActiveScriptError.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptError64 self, out uint64 pdwSourceContext, out uint32 pulLineNumber, out int32 plCharacterPosition) GetSourcePosition64;
			}
		}
		[CRepr]
		public struct IActiveScriptSiteWindow : IUnknown
		{
			public const new Guid IID = .(0xd10f6761, 0x83e9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetWindow(out HWnd phwnd) mut => VT._GetWindow(ref this, out phwnd);
			public HResult EnableModeless(IntBool fEnable) mut => VT.EnableModeless(ref this, fEnable);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteWindow self, out HWnd phwnd) _GetWindow;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteWindow self, IntBool fEnable) EnableModeless;
			}
		}
		[CRepr]
		public struct IActiveScriptSiteUIControl : IUnknown
		{
			public const new Guid IID = .(0xaedae97e, 0xd7ee, 0x4796, 0xb9, 0x60, 0x7f, 0x09, 0x2a, 0xe8, 0x44, 0xab);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetUIBehavior(SCRIPTUICITEM UicItem, out SCRIPTUICHANDLING pUicHandling) mut => VT.GetUIBehavior(ref this, UicItem, out pUicHandling);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteUIControl self, SCRIPTUICITEM UicItem, out SCRIPTUICHANDLING pUicHandling) GetUIBehavior;
			}
		}
		[CRepr]
		public struct IActiveScriptSiteInterruptPoll : IUnknown
		{
			public const new Guid IID = .(0x539698a0, 0xcdca, 0x11cf, 0xa5, 0xeb, 0x00, 0xaa, 0x00, 0x47, 0xa0, 0x63);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult QueryContinue() mut => VT.QueryContinue(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteInterruptPoll self) QueryContinue;
			}
		}
		[CRepr]
		public struct IActiveScript : IUnknown
		{
			public const new Guid IID = .(0xbb1a2ae1, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SetScriptSite(ref IActiveScriptSite pass) mut => VT.SetScriptSite(ref this, ref pass);
			public HResult GetScriptSite(in Guid riid, void** ppvObject) mut => VT.GetScriptSite(ref this, riid, ppvObject);
			public HResult SetScriptState(SCRIPTSTATE ss) mut => VT.SetScriptState(ref this, ss);
			public HResult GetScriptState(out SCRIPTSTATE pssState) mut => VT.GetScriptState(ref this, out pssState);
			public HResult Close() mut => VT.Close(ref this);
			public HResult AddNamedItem(char16* pstrName, uint32 dwFlags) mut => VT.AddNamedItem(ref this, pstrName, dwFlags);
			public HResult AddTypeLib(in Guid rguidTypeLib, uint32 dwMajor, uint32 dwMinor, uint32 dwFlags) mut => VT.AddTypeLib(ref this, rguidTypeLib, dwMajor, dwMinor, dwFlags);
			public HResult GetScriptDispatch(char16* pstrItemName, out IDispatch* ppdisp) mut => VT.GetScriptDispatch(ref this, pstrItemName, out ppdisp);
			public HResult GetCurrentScriptThreadID(out uint32 pstidThread) mut => VT.GetCurrentScriptThreadID(ref this, out pstidThread);
			public HResult GetScriptThreadID(uint32 dwWin32ThreadId, out uint32 pstidThread) mut => VT.GetScriptThreadID(ref this, dwWin32ThreadId, out pstidThread);
			public HResult GetScriptThreadState(uint32 stidThread, out SCRIPTTHREADSTATE pstsState) mut => VT.GetScriptThreadState(ref this, stidThread, out pstsState);
			public HResult InterruptScriptThread(uint32 stidThread, in EXCEPINFO pexcepinfo, uint32 dwFlags) mut => VT.InterruptScriptThread(ref this, stidThread, pexcepinfo, dwFlags);
			public HResult Clone(out IActiveScript* ppscript) mut => VT.Clone(ref this, out ppscript);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, ref IActiveScriptSite pass) SetScriptSite;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, in Guid riid, void** ppvObject) GetScriptSite;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, SCRIPTSTATE ss) SetScriptState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, out SCRIPTSTATE pssState) GetScriptState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self) Close;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, char16* pstrName, uint32 dwFlags) AddNamedItem;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, in Guid rguidTypeLib, uint32 dwMajor, uint32 dwMinor, uint32 dwFlags) AddTypeLib;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, char16* pstrItemName, out IDispatch* ppdisp) GetScriptDispatch;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, out uint32 pstidThread) GetCurrentScriptThreadID;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, uint32 dwWin32ThreadId, out uint32 pstidThread) GetScriptThreadID;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, uint32 stidThread, out SCRIPTTHREADSTATE pstsState) GetScriptThreadState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, uint32 stidThread, in EXCEPINFO pexcepinfo, uint32 dwFlags) InterruptScriptThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScript self, out IActiveScript* ppscript) Clone;
			}
		}
		[CRepr]
		public struct IActiveScriptParse32 : IUnknown
		{
			public const new Guid IID = .(0xbb1a2ae2, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult InitNew() mut => VT.InitNew(ref this);
			public HResult AddScriptlet(char16* pstrDefaultName, char16* pstrCode, char16* pstrItemName, char16* pstrSubItemName, char16* pstrEventName, char16* pstrDelimiter, uint32 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out char16* pbstrName, out EXCEPINFO pexcepinfo) mut => VT.AddScriptlet(ref this, pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, out pbstrName, out pexcepinfo);
			public HResult ParseScriptText(char16* pstrCode, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint32 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out VARIANT pvarResult, out EXCEPINFO pexcepinfo) mut => VT.ParseScriptText(ref this, pstrCode, pstrItemName, ref punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, out pvarResult, out pexcepinfo);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParse32 self) InitNew;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParse32 self, char16* pstrDefaultName, char16* pstrCode, char16* pstrItemName, char16* pstrSubItemName, char16* pstrEventName, char16* pstrDelimiter, uint32 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out char16* pbstrName, out EXCEPINFO pexcepinfo) AddScriptlet;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParse32 self, char16* pstrCode, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint32 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out VARIANT pvarResult, out EXCEPINFO pexcepinfo) ParseScriptText;
			}
		}
		[CRepr]
		public struct IActiveScriptParse64 : IUnknown
		{
			public const new Guid IID = .(0xc7ef7658, 0xe1ee, 0x480e, 0x97, 0xea, 0xd5, 0x2c, 0xb4, 0xd7, 0x6d, 0x17);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult InitNew() mut => VT.InitNew(ref this);
			public HResult AddScriptlet(char16* pstrDefaultName, char16* pstrCode, char16* pstrItemName, char16* pstrSubItemName, char16* pstrEventName, char16* pstrDelimiter, uint64 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out char16* pbstrName, out EXCEPINFO pexcepinfo) mut => VT.AddScriptlet(ref this, pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, out pbstrName, out pexcepinfo);
			public HResult ParseScriptText(char16* pstrCode, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint64 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out VARIANT pvarResult, out EXCEPINFO pexcepinfo) mut => VT.ParseScriptText(ref this, pstrCode, pstrItemName, ref punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, out pvarResult, out pexcepinfo);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParse64 self) InitNew;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParse64 self, char16* pstrDefaultName, char16* pstrCode, char16* pstrItemName, char16* pstrSubItemName, char16* pstrEventName, char16* pstrDelimiter, uint64 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out char16* pbstrName, out EXCEPINFO pexcepinfo) AddScriptlet;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParse64 self, char16* pstrCode, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint64 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out VARIANT pvarResult, out EXCEPINFO pexcepinfo) ParseScriptText;
			}
		}
		[CRepr]
		public struct IActiveScriptParseProcedureOld32 : IUnknown
		{
			public const new Guid IID = .(0x1cff0050, 0x6fdd, 0x11d0, 0x93, 0x28, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ParseProcedureText(char16* pstrCode, char16* pstrFormalParams, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint32 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out IDispatch* ppdisp) mut => VT.ParseProcedureText(ref this, pstrCode, pstrFormalParams, pstrItemName, ref punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, out ppdisp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParseProcedureOld32 self, char16* pstrCode, char16* pstrFormalParams, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint32 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out IDispatch* ppdisp) ParseProcedureText;
			}
		}
		[CRepr]
		public struct IActiveScriptParseProcedureOld64 : IUnknown
		{
			public const new Guid IID = .(0x21f57128, 0x08c9, 0x4638, 0xba, 0x12, 0x22, 0xd1, 0x5d, 0x88, 0xdc, 0x5c);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ParseProcedureText(char16* pstrCode, char16* pstrFormalParams, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint64 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out IDispatch* ppdisp) mut => VT.ParseProcedureText(ref this, pstrCode, pstrFormalParams, pstrItemName, ref punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, out ppdisp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParseProcedureOld64 self, char16* pstrCode, char16* pstrFormalParams, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint64 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out IDispatch* ppdisp) ParseProcedureText;
			}
		}
		[CRepr]
		public struct IActiveScriptParseProcedure32 : IUnknown
		{
			public const new Guid IID = .(0xaa5b6a80, 0xb834, 0x11d0, 0x93, 0x2f, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ParseProcedureText(char16* pstrCode, char16* pstrFormalParams, char16* pstrProcedureName, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint32 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out IDispatch* ppdisp) mut => VT.ParseProcedureText(ref this, pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, ref punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, out ppdisp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParseProcedure32 self, char16* pstrCode, char16* pstrFormalParams, char16* pstrProcedureName, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint32 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out IDispatch* ppdisp) ParseProcedureText;
			}
		}
		[CRepr]
		public struct IActiveScriptParseProcedure64 : IUnknown
		{
			public const new Guid IID = .(0xc64713b6, 0xe029, 0x4cc5, 0x92, 0x00, 0x43, 0x8b, 0x72, 0x89, 0x0b, 0x6a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ParseProcedureText(char16* pstrCode, char16* pstrFormalParams, char16* pstrProcedureName, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint64 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out IDispatch* ppdisp) mut => VT.ParseProcedureText(ref this, pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, ref punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, out ppdisp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptParseProcedure64 self, char16* pstrCode, char16* pstrFormalParams, char16* pstrProcedureName, char16* pstrItemName, ref IUnknown punkContext, char16* pstrDelimiter, uint64 dwSourceContextCookie, uint32 ulStartingLineNumber, uint32 dwFlags, out IDispatch* ppdisp) ParseProcedureText;
			}
		}
		[CRepr]
		public struct IActiveScriptParseProcedure2_32 : IActiveScriptParseProcedure32
		{
			public const new Guid IID = .(0x71ee5b20, 0xfb04, 0x11d1, 0xb3, 0xa8, 0x00, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);
			
			public new VTable* VT { get => (.)vt; }
			
			[CRepr]
			public struct VTable : IActiveScriptParseProcedure32.VTable {}
		}
		[CRepr]
		public struct IActiveScriptParseProcedure2_64 : IActiveScriptParseProcedure64
		{
			public const new Guid IID = .(0xfe7c4271, 0x210c, 0x448d, 0x9f, 0x54, 0x76, 0xda, 0xb7, 0x04, 0x7b, 0x28);
			
			public new VTable* VT { get => (.)vt; }
			
			[CRepr]
			public struct VTable : IActiveScriptParseProcedure64.VTable {}
		}
		[CRepr]
		public struct IActiveScriptEncode : IUnknown
		{
			public const new Guid IID = .(0xbb1a2ae3, 0xa4f9, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EncodeSection(char16* pchIn, uint32 cchIn, char16* pchOut, uint32 cchOut, out uint32 pcchRet) mut => VT.EncodeSection(ref this, pchIn, cchIn, pchOut, cchOut, out pcchRet);
			public HResult DecodeScript(char16* pchIn, uint32 cchIn, char16* pchOut, uint32 cchOut, out uint32 pcchRet) mut => VT.DecodeScript(ref this, pchIn, cchIn, pchOut, cchOut, out pcchRet);
			public HResult GetEncodeProgId(out char16* pbstrOut) mut => VT.GetEncodeProgId(ref this, out pbstrOut);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptEncode self, char16* pchIn, uint32 cchIn, char16* pchOut, uint32 cchOut, out uint32 pcchRet) EncodeSection;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptEncode self, char16* pchIn, uint32 cchIn, char16* pchOut, uint32 cchOut, out uint32 pcchRet) DecodeScript;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptEncode self, out char16* pbstrOut) GetEncodeProgId;
			}
		}
		[CRepr]
		public struct IActiveScriptHostEncode : IUnknown
		{
			public const new Guid IID = .(0xbee9b76e, 0xcfe3, 0x11d1, 0xb7, 0x47, 0x00, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EncodeScriptHostFile(char16* bstrInFile, out char16* pbstrOutFile, uint32 cFlags, char16* bstrDefaultLang) mut => VT.EncodeScriptHostFile(ref this, bstrInFile, out pbstrOutFile, cFlags, bstrDefaultLang);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptHostEncode self, char16* bstrInFile, out char16* pbstrOutFile, uint32 cFlags, char16* bstrDefaultLang) EncodeScriptHostFile;
			}
		}
		[CRepr]
		public struct IBindEventHandler : IUnknown
		{
			public const new Guid IID = .(0x63cdbcb0, 0xc1b1, 0x11d0, 0x93, 0x36, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult BindHandler(char16* pstrEvent, ref IDispatch pdisp) mut => VT.BindHandler(ref this, pstrEvent, ref pdisp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IBindEventHandler self, char16* pstrEvent, ref IDispatch pdisp) BindHandler;
			}
		}
		[CRepr]
		public struct IActiveScriptStats : IUnknown
		{
			public const new Guid IID = .(0xb8da6310, 0xe19b, 0x11d0, 0x93, 0x3c, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetStat(uint32 stid, out uint32 pluHi, out uint32 pluLo) mut => VT.GetStat(ref this, stid, out pluHi, out pluLo);
			public HResult GetStatEx(in Guid guid, out uint32 pluHi, out uint32 pluLo) mut => VT.GetStatEx(ref this, guid, out pluHi, out pluLo);
			public HResult ResetStats() mut => VT.ResetStats(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptStats self, uint32 stid, out uint32 pluHi, out uint32 pluLo) GetStat;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptStats self, in Guid guid, out uint32 pluHi, out uint32 pluLo) GetStatEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptStats self) ResetStats;
			}
		}
		[CRepr]
		public struct IActiveScriptProperty : IUnknown
		{
			public const new Guid IID = .(0x4954e0d0, 0xfbc7, 0x11d1, 0x84, 0x10, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetProperty(uint32 dwProperty, ref VARIANT pvarIndex, out VARIANT pvarValue) mut => VT.GetProperty(ref this, dwProperty, ref pvarIndex, out pvarValue);
			public HResult SetProperty(uint32 dwProperty, ref VARIANT pvarIndex, ref VARIANT pvarValue) mut => VT.SetProperty(ref this, dwProperty, ref pvarIndex, ref pvarValue);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProperty self, uint32 dwProperty, ref VARIANT pvarIndex, out VARIANT pvarValue) GetProperty;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProperty self, uint32 dwProperty, ref VARIANT pvarIndex, ref VARIANT pvarValue) SetProperty;
			}
		}
		[CRepr]
		public struct ITridentEventSink : IUnknown
		{
			public const new Guid IID = .(0x1dc9ca50, 0x06ef, 0x11d2, 0x84, 0x15, 0x00, 0x60, 0x08, 0xc3, 0xfb, 0xfc);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult FireEvent(char16* pstrEvent, ref DISPPARAMS pdp, out VARIANT pvarRes, out EXCEPINFO pei) mut => VT.FireEvent(ref this, pstrEvent, ref pdp, out pvarRes, out pei);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref ITridentEventSink self, char16* pstrEvent, ref DISPPARAMS pdp, out VARIANT pvarRes, out EXCEPINFO pei) FireEvent;
			}
		}
		[CRepr]
		public struct IActiveScriptGarbageCollector : IUnknown
		{
			public const new Guid IID = .(0x6aa2c4a0, 0x2b53, 0x11d4, 0xa2, 0xa0, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CollectGarbage(SCRIPTGCTYPE scriptgctype) mut => VT.CollectGarbage(ref this, scriptgctype);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptGarbageCollector self, SCRIPTGCTYPE scriptgctype) CollectGarbage;
			}
		}
		[CRepr]
		public struct IActiveScriptSIPInfo : IUnknown
		{
			public const new Guid IID = .(0x764651d0, 0x38de, 0x11d4, 0xa2, 0xa3, 0x00, 0x10, 0x4b, 0xd3, 0x50, 0x90);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSIPOID(out Guid poid_sip) mut => VT.GetSIPOID(ref this, out poid_sip);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSIPInfo self, out Guid poid_sip) GetSIPOID;
			}
		}
		[CRepr]
		public struct IActiveScriptSiteTraceInfo : IUnknown
		{
			public const new Guid IID = .(0x4b7272ae, 0x1955, 0x4bfe, 0x98, 0xb0, 0x78, 0x06, 0x21, 0x88, 0x85, 0x69);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SendScriptTraceInfo(SCRIPTTRACEINFO stiEventType, Guid guidContextID, uint32 dwScriptContextCookie, int32 lScriptStatementStart, int32 lScriptStatementEnd, uint64 dwReserved) mut => VT.SendScriptTraceInfo(ref this, stiEventType, guidContextID, dwScriptContextCookie, lScriptStatementStart, lScriptStatementEnd, dwReserved);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteTraceInfo self, SCRIPTTRACEINFO stiEventType, Guid guidContextID, uint32 dwScriptContextCookie, int32 lScriptStatementStart, int32 lScriptStatementEnd, uint64 dwReserved) SendScriptTraceInfo;
			}
		}
		[CRepr]
		public struct IActiveScriptTraceInfo : IUnknown
		{
			public const new Guid IID = .(0xc35456e7, 0xbebf, 0x4a1b, 0x86, 0xa9, 0x24, 0xd5, 0x6b, 0xe8, 0xb3, 0x69);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult StartScriptTracing(ref IActiveScriptSiteTraceInfo pSiteTraceInfo, Guid guidContextID) mut => VT.StartScriptTracing(ref this, ref pSiteTraceInfo, guidContextID);
			public HResult StopScriptTracing() mut => VT.StopScriptTracing(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptTraceInfo self, ref IActiveScriptSiteTraceInfo pSiteTraceInfo, Guid guidContextID) StartScriptTracing;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptTraceInfo self) StopScriptTracing;
			}
		}
		[CRepr]
		public struct IActiveScriptStringCompare : IUnknown
		{
			public const new Guid IID = .(0x58562769, 0xed52, 0x42f7, 0x84, 0x03, 0x49, 0x63, 0x51, 0x4e, 0x1f, 0x11);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult StrComp(char16* bszStr1, char16* bszStr2, out int32 iRet) mut => VT.StrComp(ref this, bszStr1, bszStr2, out iRet);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptStringCompare self, char16* bszStr1, char16* bszStr2, out int32 iRet) StrComp;
			}
		}
		[CRepr]
		public struct IDebugProperty : IUnknown
		{
			public const new Guid IID = .(0x51973c50, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetPropertyInfo(uint32 dwFieldSpec, uint32 nRadix, out DebugPropertyInfo pPropertyInfo) mut => VT.GetPropertyInfo(ref this, dwFieldSpec, nRadix, out pPropertyInfo);
			public HResult GetExtendedInfo(uint32 cInfos, Guid* rgguidExtendedInfo, VARIANT* rgvar) mut => VT.GetExtendedInfo(ref this, cInfos, rgguidExtendedInfo, rgvar);
			public HResult SetValueAsString(char16* pszValue, uint32 nRadix) mut => VT.SetValueAsString(ref this, pszValue, nRadix);
			public HResult EnumMembers(uint32 dwFieldSpec, uint32 nRadix, in Guid refiid, out IEnumDebugPropertyInfo* ppepi) mut => VT.EnumMembers(ref this, dwFieldSpec, nRadix, refiid, out ppepi);
			public HResult GetParent(out IDebugProperty* ppDebugProp) mut => VT._GetParent(ref this, out ppDebugProp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugProperty self, uint32 dwFieldSpec, uint32 nRadix, out DebugPropertyInfo pPropertyInfo) GetPropertyInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugProperty self, uint32 cInfos, Guid* rgguidExtendedInfo, VARIANT* rgvar) GetExtendedInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugProperty self, char16* pszValue, uint32 nRadix) SetValueAsString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugProperty self, uint32 dwFieldSpec, uint32 nRadix, in Guid refiid, out IEnumDebugPropertyInfo* ppepi) EnumMembers;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugProperty self, out IDebugProperty* ppDebugProp) _GetParent;
			}
		}
		[CRepr]
		public struct IEnumDebugPropertyInfo : IUnknown
		{
			public const new Guid IID = .(0x51973c51, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 celt, DebugPropertyInfo* pi, out uint32 pcEltsfetched) mut => VT.Next(ref this, celt, pi, out pcEltsfetched);
			public HResult Skip(uint32 celt) mut => VT.Skip(ref this, celt);
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult Clone(out IEnumDebugPropertyInfo* ppepi) mut => VT.Clone(ref this, out ppepi);
			public HResult GetCount(out uint32 pcelt) mut => VT.GetCount(ref this, out pcelt);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugPropertyInfo self, uint32 celt, DebugPropertyInfo* pi, out uint32 pcEltsfetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugPropertyInfo self, uint32 celt) Skip;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugPropertyInfo self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugPropertyInfo self, out IEnumDebugPropertyInfo* ppepi) Clone;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugPropertyInfo self, out uint32 pcelt) GetCount;
			}
		}
		[CRepr]
		public struct IDebugExtendedProperty : IDebugProperty
		{
			public const new Guid IID = .(0x51973c52, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetExtendedPropertyInfo(uint32 dwFieldSpec, uint32 nRadix, out ExtendedDebugPropertyInfo pExtendedPropertyInfo) mut => VT.GetExtendedPropertyInfo(ref this, dwFieldSpec, nRadix, out pExtendedPropertyInfo);
			public HResult EnumExtendedMembers(uint32 dwFieldSpec, uint32 nRadix, out IEnumDebugExtendedPropertyInfo* ppeepi) mut => VT.EnumExtendedMembers(ref this, dwFieldSpec, nRadix, out ppeepi);

			[CRepr]
			public struct VTable : IDebugProperty.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExtendedProperty self, uint32 dwFieldSpec, uint32 nRadix, out ExtendedDebugPropertyInfo pExtendedPropertyInfo) GetExtendedPropertyInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExtendedProperty self, uint32 dwFieldSpec, uint32 nRadix, out IEnumDebugExtendedPropertyInfo* ppeepi) EnumExtendedMembers;
			}
		}
		[CRepr]
		public struct IEnumDebugExtendedPropertyInfo : IUnknown
		{
			public const new Guid IID = .(0x51973c53, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 celt, ExtendedDebugPropertyInfo* rgExtendedPropertyInfo, out uint32 pceltFetched) mut => VT.Next(ref this, celt, rgExtendedPropertyInfo, out pceltFetched);
			public HResult Skip(uint32 celt) mut => VT.Skip(ref this, celt);
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult Clone(out IEnumDebugExtendedPropertyInfo* pedpe) mut => VT.Clone(ref this, out pedpe);
			public HResult GetCount(out uint32 pcelt) mut => VT.GetCount(ref this, out pcelt);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugExtendedPropertyInfo self, uint32 celt, ExtendedDebugPropertyInfo* rgExtendedPropertyInfo, out uint32 pceltFetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugExtendedPropertyInfo self, uint32 celt) Skip;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugExtendedPropertyInfo self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugExtendedPropertyInfo self, out IEnumDebugExtendedPropertyInfo* pedpe) Clone;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugExtendedPropertyInfo self, out uint32 pcelt) GetCount;
			}
		}
		[CRepr]
		public struct IPerPropertyBrowsing2 : IUnknown
		{
			public const new Guid IID = .(0x51973c54, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDisplayString(int32 dispid, out char16* pBstr) mut => VT.GetDisplayString(ref this, dispid, out pBstr);
			public HResult MapPropertyToPage(int32 dispid, out Guid pClsidPropPage) mut => VT.MapPropertyToPage(ref this, dispid, out pClsidPropPage);
			public HResult GetPredefinedStrings(int32 dispid, out CALPOLESTR pCaStrings, out CADWORD pCaCookies) mut => VT.GetPredefinedStrings(ref this, dispid, out pCaStrings, out pCaCookies);
			public HResult SetPredefinedValue(int32 dispid, uint32 dwCookie) mut => VT.SetPredefinedValue(ref this, dispid, dwCookie);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IPerPropertyBrowsing2 self, int32 dispid, out char16* pBstr) GetDisplayString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IPerPropertyBrowsing2 self, int32 dispid, out Guid pClsidPropPage) MapPropertyToPage;
				public new function [CallingConvention(.Stdcall)] HResult(ref IPerPropertyBrowsing2 self, int32 dispid, out CALPOLESTR pCaStrings, out CADWORD pCaCookies) GetPredefinedStrings;
				public new function [CallingConvention(.Stdcall)] HResult(ref IPerPropertyBrowsing2 self, int32 dispid, uint32 dwCookie) SetPredefinedValue;
			}
		}
		[CRepr]
		public struct IDebugPropertyEnumType_All : IUnknown
		{
			public const new Guid IID = .(0x51973c55, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetName(out char16* __MIDL__IDebugPropertyEnumType_All0000) mut => VT.GetName(ref this, out __MIDL__IDebugPropertyEnumType_All0000);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugPropertyEnumType_All self, out char16* __MIDL__IDebugPropertyEnumType_All0000) GetName;
			}
		}
		[CRepr]
		public struct IDebugPropertyEnumType_Locals : IDebugPropertyEnumType_All
		{
			public const new Guid IID = .(0x51973c56, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			[CRepr]
			public struct VTable : IDebugPropertyEnumType_All.VTable {}
		}
		[CRepr]
		public struct IDebugPropertyEnumType_Arguments : IDebugPropertyEnumType_All
		{
			public const new Guid IID = .(0x51973c57, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			[CRepr]
			public struct VTable : IDebugPropertyEnumType_All.VTable {}
		}
		[CRepr]
		public struct IDebugPropertyEnumType_LocalsPlusArgs : IDebugPropertyEnumType_All
		{
			public const new Guid IID = .(0x51973c58, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			[CRepr]
			public struct VTable : IDebugPropertyEnumType_All.VTable {}
		}
		[CRepr]
		public struct IDebugPropertyEnumType_Registers : IDebugPropertyEnumType_All
		{
			public const new Guid IID = .(0x51973c59, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			[CRepr]
			public struct VTable : IDebugPropertyEnumType_All.VTable {}
		}
		[CRepr]
		public struct IActiveScriptDebug32 : IUnknown
		{
			public const new Guid IID = .(0x51973c10, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetScriptTextAttributes(char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) mut => VT.GetScriptTextAttributes(ref this, pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
			public HResult GetScriptletTextAttributes(char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) mut => VT.GetScriptletTextAttributes(ref this, pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
			public HResult EnumCodeContextsOfPosition(uint32 dwSourceContext, uint32 uCharacterOffset, uint32 uNumChars, out IEnumDebugCodeContexts* ppescc) mut => VT.EnumCodeContextsOfPosition(ref this, dwSourceContext, uCharacterOffset, uNumChars, out ppescc);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptDebug32 self, char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) GetScriptTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptDebug32 self, char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) GetScriptletTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptDebug32 self, uint32 dwSourceContext, uint32 uCharacterOffset, uint32 uNumChars, out IEnumDebugCodeContexts* ppescc) EnumCodeContextsOfPosition;
			}
		}
		[CRepr]
		public struct IActiveScriptDebug64 : IUnknown
		{
			public const new Guid IID = .(0xbc437e23, 0xf5b8, 0x47f4, 0xbb, 0x79, 0x7d, 0x1c, 0xe5, 0x48, 0x3b, 0x86);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetScriptTextAttributes(char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) mut => VT.GetScriptTextAttributes(ref this, pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
			public HResult GetScriptletTextAttributes(char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) mut => VT.GetScriptletTextAttributes(ref this, pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
			public HResult EnumCodeContextsOfPosition(uint64 dwSourceContext, uint32 uCharacterOffset, uint32 uNumChars, out IEnumDebugCodeContexts* ppescc) mut => VT.EnumCodeContextsOfPosition(ref this, dwSourceContext, uCharacterOffset, uNumChars, out ppescc);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptDebug64 self, char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) GetScriptTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptDebug64 self, char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) GetScriptletTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptDebug64 self, uint64 dwSourceContext, uint32 uCharacterOffset, uint32 uNumChars, out IEnumDebugCodeContexts* ppescc) EnumCodeContextsOfPosition;
			}
		}
		[CRepr]
		public struct IActiveScriptSiteDebug32 : IUnknown
		{
			public const new Guid IID = .(0x51973c11, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDocumentContextFromPosition(uint32 dwSourceContext, uint32 uCharacterOffset, uint32 uNumChars, out IDebugDocumentContext* ppsc) mut => VT.GetDocumentContextFromPosition(ref this, dwSourceContext, uCharacterOffset, uNumChars, out ppsc);
			public HResult GetApplication(out IDebugApplication32* ppda) mut => VT.GetApplication(ref this, out ppda);
			public HResult GetRootApplicationNode(out IDebugApplicationNode* ppdanRoot) mut => VT.GetRootApplicationNode(ref this, out ppdanRoot);
			public HResult OnScriptErrorDebug(ref IActiveScriptErrorDebug pErrorDebug, out IntBool pfEnterDebugger, out IntBool pfCallOnScriptErrorWhenContinuing) mut => VT.OnScriptErrorDebug(ref this, ref pErrorDebug, out pfEnterDebugger, out pfCallOnScriptErrorWhenContinuing);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteDebug32 self, uint32 dwSourceContext, uint32 uCharacterOffset, uint32 uNumChars, out IDebugDocumentContext* ppsc) GetDocumentContextFromPosition;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteDebug32 self, out IDebugApplication32* ppda) GetApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteDebug32 self, out IDebugApplicationNode* ppdanRoot) GetRootApplicationNode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteDebug32 self, ref IActiveScriptErrorDebug pErrorDebug, out IntBool pfEnterDebugger, out IntBool pfCallOnScriptErrorWhenContinuing) OnScriptErrorDebug;
			}
		}
		[CRepr]
		public struct IActiveScriptSiteDebug64 : IUnknown
		{
			public const new Guid IID = .(0xd6b96b0a, 0x7463, 0x402c, 0x92, 0xac, 0x89, 0x98, 0x42, 0x26, 0x94, 0x2f);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDocumentContextFromPosition(uint64 dwSourceContext, uint32 uCharacterOffset, uint32 uNumChars, out IDebugDocumentContext* ppsc) mut => VT.GetDocumentContextFromPosition(ref this, dwSourceContext, uCharacterOffset, uNumChars, out ppsc);
			public HResult GetApplication(out IDebugApplication64* ppda) mut => VT.GetApplication(ref this, out ppda);
			public HResult GetRootApplicationNode(out IDebugApplicationNode* ppdanRoot) mut => VT.GetRootApplicationNode(ref this, out ppdanRoot);
			public HResult OnScriptErrorDebug(ref IActiveScriptErrorDebug pErrorDebug, out IntBool pfEnterDebugger, out IntBool pfCallOnScriptErrorWhenContinuing) mut => VT.OnScriptErrorDebug(ref this, ref pErrorDebug, out pfEnterDebugger, out pfCallOnScriptErrorWhenContinuing);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteDebug64 self, uint64 dwSourceContext, uint32 uCharacterOffset, uint32 uNumChars, out IDebugDocumentContext* ppsc) GetDocumentContextFromPosition;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteDebug64 self, out IDebugApplication64* ppda) GetApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteDebug64 self, out IDebugApplicationNode* ppdanRoot) GetRootApplicationNode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteDebug64 self, ref IActiveScriptErrorDebug pErrorDebug, out IntBool pfEnterDebugger, out IntBool pfCallOnScriptErrorWhenContinuing) OnScriptErrorDebug;
			}
		}
		[CRepr]
		public struct IActiveScriptSiteDebugEx : IUnknown
		{
			public const new Guid IID = .(0xbb722ccb, 0x6ad2, 0x41c6, 0xb7, 0x80, 0xaf, 0x9c, 0x03, 0xee, 0x69, 0xf5);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult OnCanNotJITScriptErrorDebug(ref IActiveScriptErrorDebug pErrorDebug, out IntBool pfCallOnScriptErrorWhenContinuing) mut => VT.OnCanNotJITScriptErrorDebug(ref this, ref pErrorDebug, out pfCallOnScriptErrorWhenContinuing);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptSiteDebugEx self, ref IActiveScriptErrorDebug pErrorDebug, out IntBool pfCallOnScriptErrorWhenContinuing) OnCanNotJITScriptErrorDebug;
			}
		}
		[CRepr]
		public struct IActiveScriptErrorDebug : IActiveScriptError
		{
			public const new Guid IID = .(0x51973c12, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDocumentContext(out IDebugDocumentContext* ppssc) mut => VT.GetDocumentContext(ref this, out ppssc);
			public HResult GetStackFrame(out IDebugStackFrame* ppdsf) mut => VT.GetStackFrame(ref this, out ppdsf);

			[CRepr]
			public struct VTable : IActiveScriptError.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptErrorDebug self, out IDebugDocumentContext* ppssc) GetDocumentContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptErrorDebug self, out IDebugStackFrame* ppdsf) GetStackFrame;
			}
		}
		[CRepr]
		public struct IDebugCodeContext : IUnknown
		{
			public const new Guid IID = .(0x51973c13, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDocumentContext(out IDebugDocumentContext* ppsc) mut => VT.GetDocumentContext(ref this, out ppsc);
			public HResult SetBreakPoint(BREAKPOINT_STATE bps) mut => VT.SetBreakPoint(ref this, bps);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugCodeContext self, out IDebugDocumentContext* ppsc) GetDocumentContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugCodeContext self, BREAKPOINT_STATE bps) SetBreakPoint;
			}
		}
		[CRepr]
		public struct IDebugExpression : IUnknown
		{
			public const new Guid IID = .(0x51973c14, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Start(ref IDebugExpressionCallBack pdecb) mut => VT.Start(ref this, ref pdecb);
			public HResult Abort() mut => VT.Abort(ref this);
			public HResult QueryIsComplete() mut => VT.QueryIsComplete(ref this);
			public HResult GetResultAsString(out HResult phrResult, out char16* pbstrResult) mut => VT.GetResultAsString(ref this, out phrResult, out pbstrResult);
			public HResult GetResultAsDebugProperty(out HResult phrResult, out IDebugProperty* ppdp) mut => VT.GetResultAsDebugProperty(ref this, out phrResult, out ppdp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExpression self, ref IDebugExpressionCallBack pdecb) Start;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExpression self) Abort;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExpression self) QueryIsComplete;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExpression self, out HResult phrResult, out char16* pbstrResult) GetResultAsString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExpression self, out HResult phrResult, out IDebugProperty* ppdp) GetResultAsDebugProperty;
			}
		}
		[CRepr]
		public struct IDebugExpressionContext : IUnknown
		{
			public const new Guid IID = .(0x51973c15, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ParseLanguageText(char16* pstrCode, uint32 nRadix, char16* pstrDelimiter, uint32 dwFlags, out IDebugExpression* ppe) mut => VT.ParseLanguageText(ref this, pstrCode, nRadix, pstrDelimiter, dwFlags, out ppe);
			public HResult GetLanguageInfo(out char16* pbstrLanguageName, out Guid pLanguageID) mut => VT.GetLanguageInfo(ref this, out pbstrLanguageName, out pLanguageID);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExpressionContext self, char16* pstrCode, uint32 nRadix, char16* pstrDelimiter, uint32 dwFlags, out IDebugExpression* ppe) ParseLanguageText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExpressionContext self, out char16* pbstrLanguageName, out Guid pLanguageID) GetLanguageInfo;
			}
		}
		[CRepr]
		public struct IDebugExpressionCallBack : IUnknown
		{
			public const new Guid IID = .(0x51973c16, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult onComplete() mut => VT.onComplete(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugExpressionCallBack self) onComplete;
			}
		}
		[CRepr]
		public struct IDebugStackFrame : IUnknown
		{
			public const new Guid IID = .(0x51973c17, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetCodeContext(out IDebugCodeContext* ppcc) mut => VT.GetCodeContext(ref this, out ppcc);
			public HResult GetDescriptionString(IntBool fLong, out char16* pbstrDescription) mut => VT.GetDescriptionString(ref this, fLong, out pbstrDescription);
			public HResult GetLanguageString(IntBool fLong, out char16* pbstrLanguage) mut => VT.GetLanguageString(ref this, fLong, out pbstrLanguage);
			public HResult GetThread(out IDebugApplicationThread* ppat) mut => VT.GetThread(ref this, out ppat);
			public HResult GetDebugProperty(out IDebugProperty* ppDebugProp) mut => VT.GetDebugProperty(ref this, out ppDebugProp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrame self, out IDebugCodeContext* ppcc) GetCodeContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrame self, IntBool fLong, out char16* pbstrDescription) GetDescriptionString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrame self, IntBool fLong, out char16* pbstrLanguage) GetLanguageString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrame self, out IDebugApplicationThread* ppat) GetThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrame self, out IDebugProperty* ppDebugProp) GetDebugProperty;
			}
		}
		[CRepr]
		public struct IDebugStackFrameSniffer : IUnknown
		{
			public const new Guid IID = .(0x51973c18, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EnumStackFrames(out IEnumDebugStackFrames* ppedsf) mut => VT.EnumStackFrames(ref this, out ppedsf);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrameSniffer self, out IEnumDebugStackFrames* ppedsf) EnumStackFrames;
			}
		}
		[CRepr]
		public struct IDebugStackFrameSnifferEx32 : IDebugStackFrameSniffer
		{
			public const new Guid IID = .(0x51973c19, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EnumStackFramesEx32(uint32 dwSpMin, out IEnumDebugStackFrames* ppedsf) mut => VT.EnumStackFramesEx32(ref this, dwSpMin, out ppedsf);

			[CRepr]
			public struct VTable : IDebugStackFrameSniffer.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrameSnifferEx32 self, uint32 dwSpMin, out IEnumDebugStackFrames* ppedsf) EnumStackFramesEx32;
			}
		}
		[CRepr]
		public struct IDebugStackFrameSnifferEx64 : IDebugStackFrameSniffer
		{
			public const new Guid IID = .(0x8cd12af4, 0x49c1, 0x4d52, 0x8d, 0x8a, 0xc1, 0x46, 0xf4, 0x75, 0x81, 0xaa);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EnumStackFramesEx64(uint64 dwSpMin, out IEnumDebugStackFrames64* ppedsf) mut => VT.EnumStackFramesEx64(ref this, dwSpMin, out ppedsf);

			[CRepr]
			public struct VTable : IDebugStackFrameSniffer.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrameSnifferEx64 self, uint64 dwSpMin, out IEnumDebugStackFrames64* ppedsf) EnumStackFramesEx64;
			}
		}
		[CRepr]
		public struct IDebugSyncOperation : IUnknown
		{
			public const new Guid IID = .(0x51973c1a, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetTargetThread(out IDebugApplicationThread* ppatTarget) mut => VT.GetTargetThread(ref this, out ppatTarget);
			public HResult Execute(out IUnknown* ppunkResult) mut => VT.Execute(ref this, out ppunkResult);
			public HResult InProgressAbort() mut => VT.InProgressAbort(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSyncOperation self, out IDebugApplicationThread* ppatTarget) GetTargetThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSyncOperation self, out IUnknown* ppunkResult) Execute;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSyncOperation self) InProgressAbort;
			}
		}
		[CRepr]
		public struct IDebugAsyncOperation : IUnknown
		{
			public const new Guid IID = .(0x51973c1b, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSyncDebugOperation(out IDebugSyncOperation* ppsdo) mut => VT.GetSyncDebugOperation(ref this, out ppsdo);
			public HResult Start(ref IDebugAsyncOperationCallBack padocb) mut => VT.Start(ref this, ref padocb);
			public HResult Abort() mut => VT.Abort(ref this);
			public HResult QueryIsComplete() mut => VT.QueryIsComplete(ref this);
			public HResult GetResult(out HResult phrResult, out IUnknown* ppunkResult) mut => VT.GetResult(ref this, out phrResult, out ppunkResult);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAsyncOperation self, out IDebugSyncOperation* ppsdo) GetSyncDebugOperation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAsyncOperation self, ref IDebugAsyncOperationCallBack padocb) Start;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAsyncOperation self) Abort;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAsyncOperation self) QueryIsComplete;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAsyncOperation self, out HResult phrResult, out IUnknown* ppunkResult) GetResult;
			}
		}
		[CRepr]
		public struct IDebugAsyncOperationCallBack : IUnknown
		{
			public const new Guid IID = .(0x51973c1c, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult onComplete() mut => VT.onComplete(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugAsyncOperationCallBack self) onComplete;
			}
		}
		[CRepr]
		public struct IEnumDebugCodeContexts : IUnknown
		{
			public const new Guid IID = .(0x51973c1d, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 celt, out IDebugCodeContext* pscc, out uint32 pceltFetched) mut => VT.Next(ref this, celt, out pscc, out pceltFetched);
			public HResult Skip(uint32 celt) mut => VT.Skip(ref this, celt);
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult Clone(out IEnumDebugCodeContexts* ppescc) mut => VT.Clone(ref this, out ppescc);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugCodeContexts self, uint32 celt, out IDebugCodeContext* pscc, out uint32 pceltFetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugCodeContexts self, uint32 celt) Skip;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugCodeContexts self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugCodeContexts self, out IEnumDebugCodeContexts* ppescc) Clone;
			}
		}
		[CRepr]
		public struct IEnumDebugStackFrames : IUnknown
		{
			public const new Guid IID = .(0x51973c1e, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 celt, out DebugStackFrameDescriptor prgdsfd, out uint32 pceltFetched) mut => VT.Next(ref this, celt, out prgdsfd, out pceltFetched);
			public HResult Skip(uint32 celt) mut => VT.Skip(ref this, celt);
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult Clone(out IEnumDebugStackFrames* ppedsf) mut => VT.Clone(ref this, out ppedsf);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugStackFrames self, uint32 celt, out DebugStackFrameDescriptor prgdsfd, out uint32 pceltFetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugStackFrames self, uint32 celt) Skip;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugStackFrames self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugStackFrames self, out IEnumDebugStackFrames* ppedsf) Clone;
			}
		}
		[CRepr]
		public struct IEnumDebugStackFrames64 : IEnumDebugStackFrames
		{
			public const new Guid IID = .(0x0dc38853, 0xc1b0, 0x4176, 0xa9, 0x84, 0xb2, 0x98, 0x36, 0x10, 0x27, 0xaf);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next64(uint32 celt, out DebugStackFrameDescriptor64 prgdsfd, out uint32 pceltFetched) mut => VT.Next64(ref this, celt, out prgdsfd, out pceltFetched);

			[CRepr]
			public struct VTable : IEnumDebugStackFrames.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugStackFrames64 self, uint32 celt, out DebugStackFrameDescriptor64 prgdsfd, out uint32 pceltFetched) Next64;
			}
		}
		[CRepr]
		public struct IDebugDocumentInfo : IUnknown
		{
			public const new Guid IID = .(0x51973c1f, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetName(DOCUMENTNAMETYPE dnt, out char16* pbstrName) mut => VT.GetName(ref this, dnt, out pbstrName);
			public HResult GetDocumentClassId(out Guid pclsidDocument) mut => VT.GetDocumentClassId(ref this, out pclsidDocument);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentInfo self, DOCUMENTNAMETYPE dnt, out char16* pbstrName) GetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentInfo self, out Guid pclsidDocument) GetDocumentClassId;
			}
		}
		[CRepr]
		public struct IDebugDocumentProvider : IDebugDocumentInfo
		{
			public const new Guid IID = .(0x51973c20, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDocument(out IDebugDocument* ppssd) mut => VT.GetDocument(ref this, out ppssd);

			[CRepr]
			public struct VTable : IDebugDocumentInfo.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentProvider self, out IDebugDocument* ppssd) GetDocument;
			}
		}
		[CRepr]
		public struct IDebugDocument : IDebugDocumentInfo
		{
			public const new Guid IID = .(0x51973c21, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			[CRepr]
			public struct VTable : IDebugDocumentInfo.VTable {}
		}
		[CRepr]
		public struct IDebugDocumentText : IDebugDocument
		{
			public const new Guid IID = .(0x51973c22, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDocumentAttributes(out uint32 ptextdocattr) mut => VT.GetDocumentAttributes(ref this, out ptextdocattr);
			public HResult GetSize(out uint32 pcNumLines, out uint32 pcNumChars) mut => VT.GetSize(ref this, out pcNumLines, out pcNumChars);
			public HResult GetPositionOfLine(uint32 cLineNumber, out uint32 pcCharacterPosition) mut => VT.GetPositionOfLine(ref this, cLineNumber, out pcCharacterPosition);
			public HResult GetLineOfPosition(uint32 cCharacterPosition, out uint32 pcLineNumber, out uint32 pcCharacterOffsetInLine) mut => VT.GetLineOfPosition(ref this, cCharacterPosition, out pcLineNumber, out pcCharacterOffsetInLine);
			public HResult GetText(uint32 cCharacterPosition, char16* pcharText, uint16* pstaTextAttr, out uint32 pcNumChars, uint32 cMaxChars) mut => VT.GetText(ref this, cCharacterPosition, pcharText, pstaTextAttr, out pcNumChars, cMaxChars);
			public HResult GetPositionOfContext(ref IDebugDocumentContext psc, out uint32 pcCharacterPosition, out uint32 cNumChars) mut => VT.GetPositionOfContext(ref this, ref psc, out pcCharacterPosition, out cNumChars);
			public HResult GetContextOfPosition(uint32 cCharacterPosition, uint32 cNumChars, out IDebugDocumentContext* ppsc) mut => VT.GetContextOfPosition(ref this, cCharacterPosition, cNumChars, out ppsc);

			[CRepr]
			public struct VTable : IDebugDocument.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentText self, out uint32 ptextdocattr) GetDocumentAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentText self, out uint32 pcNumLines, out uint32 pcNumChars) GetSize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentText self, uint32 cLineNumber, out uint32 pcCharacterPosition) GetPositionOfLine;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentText self, uint32 cCharacterPosition, out uint32 pcLineNumber, out uint32 pcCharacterOffsetInLine) GetLineOfPosition;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentText self, uint32 cCharacterPosition, char16* pcharText, uint16* pstaTextAttr, out uint32 pcNumChars, uint32 cMaxChars) GetText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentText self, ref IDebugDocumentContext psc, out uint32 pcCharacterPosition, out uint32 cNumChars) GetPositionOfContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentText self, uint32 cCharacterPosition, uint32 cNumChars, out IDebugDocumentContext* ppsc) GetContextOfPosition;
			}
		}
		[CRepr]
		public struct IDebugDocumentTextEvents : IUnknown
		{
			public const new Guid IID = .(0x51973c23, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult onDestroy() mut => VT.onDestroy(ref this);
			public HResult onInsertText(uint32 cCharacterPosition, uint32 cNumToInsert) mut => VT.onInsertText(ref this, cCharacterPosition, cNumToInsert);
			public HResult onRemoveText(uint32 cCharacterPosition, uint32 cNumToRemove) mut => VT.onRemoveText(ref this, cCharacterPosition, cNumToRemove);
			public HResult onReplaceText(uint32 cCharacterPosition, uint32 cNumToReplace) mut => VT.onReplaceText(ref this, cCharacterPosition, cNumToReplace);
			public HResult onUpdateTextAttributes(uint32 cCharacterPosition, uint32 cNumToUpdate) mut => VT.onUpdateTextAttributes(ref this, cCharacterPosition, cNumToUpdate);
			public HResult onUpdateDocumentAttributes(uint32 textdocattr) mut => VT.onUpdateDocumentAttributes(ref this, textdocattr);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextEvents self) onDestroy;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextEvents self, uint32 cCharacterPosition, uint32 cNumToInsert) onInsertText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextEvents self, uint32 cCharacterPosition, uint32 cNumToRemove) onRemoveText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextEvents self, uint32 cCharacterPosition, uint32 cNumToReplace) onReplaceText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextEvents self, uint32 cCharacterPosition, uint32 cNumToUpdate) onUpdateTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextEvents self, uint32 textdocattr) onUpdateDocumentAttributes;
			}
		}
		[CRepr]
		public struct IDebugDocumentTextAuthor : IDebugDocumentText
		{
			public const new Guid IID = .(0x51973c24, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult InsertText(uint32 cCharacterPosition, uint32 cNumToInsert, char16* pcharText) mut => VT.InsertText(ref this, cCharacterPosition, cNumToInsert, pcharText);
			public HResult RemoveText(uint32 cCharacterPosition, uint32 cNumToRemove) mut => VT.RemoveText(ref this, cCharacterPosition, cNumToRemove);
			public HResult ReplaceText(uint32 cCharacterPosition, uint32 cNumToReplace, char16* pcharText) mut => VT.ReplaceText(ref this, cCharacterPosition, cNumToReplace, pcharText);

			[CRepr]
			public struct VTable : IDebugDocumentText.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextAuthor self, uint32 cCharacterPosition, uint32 cNumToInsert, char16* pcharText) InsertText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextAuthor self, uint32 cCharacterPosition, uint32 cNumToRemove) RemoveText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextAuthor self, uint32 cCharacterPosition, uint32 cNumToReplace, char16* pcharText) ReplaceText;
			}
		}
		[CRepr]
		public struct IDebugDocumentTextExternalAuthor : IUnknown
		{
			public const new Guid IID = .(0x51973c25, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetPathName(out char16* pbstrLongName, out IntBool pfIsOriginalFile) mut => VT.GetPathName(ref this, out pbstrLongName, out pfIsOriginalFile);
			public HResult GetFileName(out char16* pbstrShortName) mut => VT.GetFileName(ref this, out pbstrShortName);
			public HResult NotifyChanged() mut => VT.NotifyChanged(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextExternalAuthor self, out char16* pbstrLongName, out IntBool pfIsOriginalFile) GetPathName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextExternalAuthor self, out char16* pbstrShortName) GetFileName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentTextExternalAuthor self) NotifyChanged;
			}
		}
		[CRepr]
		public struct IDebugDocumentHelper32 : IUnknown
		{
			public const new Guid IID = .(0x51973c26, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Init(ref IDebugApplication32 pda, char16* pszShortName, char16* pszLongName, uint32 docAttr) mut => VT.Init(ref this, ref pda, pszShortName, pszLongName, docAttr);
			public HResult Attach(ref IDebugDocumentHelper32 pddhParent) mut => VT.Attach(ref this, ref pddhParent);
			public HResult Detach() mut => VT.Detach(ref this);
			public HResult AddUnicodeText(char16* pszText) mut => VT.AddUnicodeText(ref this, pszText);
			public HResult AddDBCSText(char8* pszText) mut => VT.AddDBCSText(ref this, pszText);
			public HResult SetDebugDocumentHost(ref IDebugDocumentHost pddh) mut => VT.SetDebugDocumentHost(ref this, ref pddh);
			public HResult AddDeferredText(uint32 cChars, uint32 dwTextStartCookie) mut => VT.AddDeferredText(ref this, cChars, dwTextStartCookie);
			public HResult DefineScriptBlock(uint32 ulCharOffset, uint32 cChars, ref IActiveScript pas, IntBool fScriptlet, out uint32 pdwSourceContext) mut => VT.DefineScriptBlock(ref this, ulCharOffset, cChars, ref pas, fScriptlet, out pdwSourceContext);
			public HResult SetDefaultTextAttr(uint16 staTextAttr) mut => VT.SetDefaultTextAttr(ref this, staTextAttr);
			public HResult SetTextAttributes(uint32 ulCharOffset, uint32 cChars, uint16* pstaTextAttr) mut => VT.SetTextAttributes(ref this, ulCharOffset, cChars, pstaTextAttr);
			public HResult SetLongName(char16* pszLongName) mut => VT.SetLongName(ref this, pszLongName);
			public HResult SetShortName(char16* pszShortName) mut => VT.SetShortName(ref this, pszShortName);
			public HResult SetDocumentAttr(uint32 pszAttributes) mut => VT.SetDocumentAttr(ref this, pszAttributes);
			public HResult GetDebugApplicationNode(out IDebugApplicationNode* ppdan) mut => VT.GetDebugApplicationNode(ref this, out ppdan);
			public HResult GetScriptBlockInfo(uint32 dwSourceContext, out IActiveScript* ppasd, out uint32 piCharPos, out uint32 pcChars) mut => VT.GetScriptBlockInfo(ref this, dwSourceContext, out ppasd, out piCharPos, out pcChars);
			public HResult CreateDebugDocumentContext(uint32 iCharPos, uint32 cChars, out IDebugDocumentContext* ppddc) mut => VT.CreateDebugDocumentContext(ref this, iCharPos, cChars, out ppddc);
			public HResult BringDocumentToTop() mut => VT.BringDocumentToTop(ref this);
			public HResult BringDocumentContextToTop(IDebugDocumentContext* pddc) mut => VT.BringDocumentContextToTop(ref this, pddc);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, ref IDebugApplication32 pda, char16* pszShortName, char16* pszLongName, uint32 docAttr) Init;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, ref IDebugDocumentHelper32 pddhParent) Attach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self) Detach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, char16* pszText) AddUnicodeText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, char8* pszText) AddDBCSText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, ref IDebugDocumentHost pddh) SetDebugDocumentHost;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, uint32 cChars, uint32 dwTextStartCookie) AddDeferredText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, uint32 ulCharOffset, uint32 cChars, ref IActiveScript pas, IntBool fScriptlet, out uint32 pdwSourceContext) DefineScriptBlock;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, uint16 staTextAttr) SetDefaultTextAttr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, uint32 ulCharOffset, uint32 cChars, uint16* pstaTextAttr) SetTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, char16* pszLongName) SetLongName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, char16* pszShortName) SetShortName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, uint32 pszAttributes) SetDocumentAttr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, out IDebugApplicationNode* ppdan) GetDebugApplicationNode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, uint32 dwSourceContext, out IActiveScript* ppasd, out uint32 piCharPos, out uint32 pcChars) GetScriptBlockInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, uint32 iCharPos, uint32 cChars, out IDebugDocumentContext* ppddc) CreateDebugDocumentContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self) BringDocumentToTop;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper32 self, IDebugDocumentContext* pddc) BringDocumentContextToTop;
			}
		}
		[CRepr]
		public struct IDebugDocumentHelper64 : IUnknown
		{
			public const new Guid IID = .(0xc4c7363c, 0x20fd, 0x47f9, 0xbd, 0x82, 0x48, 0x55, 0xe0, 0x15, 0x08, 0x71);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Init(ref IDebugApplication64 pda, char16* pszShortName, char16* pszLongName, uint32 docAttr) mut => VT.Init(ref this, ref pda, pszShortName, pszLongName, docAttr);
			public HResult Attach(ref IDebugDocumentHelper64 pddhParent) mut => VT.Attach(ref this, ref pddhParent);
			public HResult Detach() mut => VT.Detach(ref this);
			public HResult AddUnicodeText(char16* pszText) mut => VT.AddUnicodeText(ref this, pszText);
			public HResult AddDBCSText(char8* pszText) mut => VT.AddDBCSText(ref this, pszText);
			public HResult SetDebugDocumentHost(ref IDebugDocumentHost pddh) mut => VT.SetDebugDocumentHost(ref this, ref pddh);
			public HResult AddDeferredText(uint32 cChars, uint32 dwTextStartCookie) mut => VT.AddDeferredText(ref this, cChars, dwTextStartCookie);
			public HResult DefineScriptBlock(uint32 ulCharOffset, uint32 cChars, ref IActiveScript pas, IntBool fScriptlet, out uint64 pdwSourceContext) mut => VT.DefineScriptBlock(ref this, ulCharOffset, cChars, ref pas, fScriptlet, out pdwSourceContext);
			public HResult SetDefaultTextAttr(uint16 staTextAttr) mut => VT.SetDefaultTextAttr(ref this, staTextAttr);
			public HResult SetTextAttributes(uint32 ulCharOffset, uint32 cChars, uint16* pstaTextAttr) mut => VT.SetTextAttributes(ref this, ulCharOffset, cChars, pstaTextAttr);
			public HResult SetLongName(char16* pszLongName) mut => VT.SetLongName(ref this, pszLongName);
			public HResult SetShortName(char16* pszShortName) mut => VT.SetShortName(ref this, pszShortName);
			public HResult SetDocumentAttr(uint32 pszAttributes) mut => VT.SetDocumentAttr(ref this, pszAttributes);
			public HResult GetDebugApplicationNode(out IDebugApplicationNode* ppdan) mut => VT.GetDebugApplicationNode(ref this, out ppdan);
			public HResult GetScriptBlockInfo(uint64 dwSourceContext, out IActiveScript* ppasd, out uint32 piCharPos, out uint32 pcChars) mut => VT.GetScriptBlockInfo(ref this, dwSourceContext, out ppasd, out piCharPos, out pcChars);
			public HResult CreateDebugDocumentContext(uint32 iCharPos, uint32 cChars, out IDebugDocumentContext* ppddc) mut => VT.CreateDebugDocumentContext(ref this, iCharPos, cChars, out ppddc);
			public HResult BringDocumentToTop() mut => VT.BringDocumentToTop(ref this);
			public HResult BringDocumentContextToTop(IDebugDocumentContext* pddc) mut => VT.BringDocumentContextToTop(ref this, pddc);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, ref IDebugApplication64 pda, char16* pszShortName, char16* pszLongName, uint32 docAttr) Init;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, ref IDebugDocumentHelper64 pddhParent) Attach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self) Detach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, char16* pszText) AddUnicodeText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, char8* pszText) AddDBCSText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, ref IDebugDocumentHost pddh) SetDebugDocumentHost;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, uint32 cChars, uint32 dwTextStartCookie) AddDeferredText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, uint32 ulCharOffset, uint32 cChars, ref IActiveScript pas, IntBool fScriptlet, out uint64 pdwSourceContext) DefineScriptBlock;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, uint16 staTextAttr) SetDefaultTextAttr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, uint32 ulCharOffset, uint32 cChars, uint16* pstaTextAttr) SetTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, char16* pszLongName) SetLongName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, char16* pszShortName) SetShortName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, uint32 pszAttributes) SetDocumentAttr;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, out IDebugApplicationNode* ppdan) GetDebugApplicationNode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, uint64 dwSourceContext, out IActiveScript* ppasd, out uint32 piCharPos, out uint32 pcChars) GetScriptBlockInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, uint32 iCharPos, uint32 cChars, out IDebugDocumentContext* ppddc) CreateDebugDocumentContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self) BringDocumentToTop;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHelper64 self, IDebugDocumentContext* pddc) BringDocumentContextToTop;
			}
		}
		[CRepr]
		public struct IDebugDocumentHost : IUnknown
		{
			public const new Guid IID = .(0x51973c27, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDeferredText(uint32 dwTextStartCookie, char16* pcharText, uint16* pstaTextAttr, out uint32 pcNumChars, uint32 cMaxChars) mut => VT.GetDeferredText(ref this, dwTextStartCookie, pcharText, pstaTextAttr, out pcNumChars, cMaxChars);
			public HResult GetScriptTextAttributes(char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) mut => VT.GetScriptTextAttributes(ref this, pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
			public HResult OnCreateDocumentContext(out IUnknown* ppunkOuter) mut => VT.OnCreateDocumentContext(ref this, out ppunkOuter);
			public HResult GetPathName(out char16* pbstrLongName, out IntBool pfIsOriginalFile) mut => VT.GetPathName(ref this, out pbstrLongName, out pfIsOriginalFile);
			public HResult GetFileName(out char16* pbstrShortName) mut => VT.GetFileName(ref this, out pbstrShortName);
			public HResult NotifyChanged() mut => VT.NotifyChanged(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHost self, uint32 dwTextStartCookie, char16* pcharText, uint16* pstaTextAttr, out uint32 pcNumChars, uint32 cMaxChars) GetDeferredText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHost self, char16* pstrCode, uint32 uNumCodeChars, char16* pstrDelimiter, uint32 dwFlags, uint16* pattr) GetScriptTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHost self, out IUnknown* ppunkOuter) OnCreateDocumentContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHost self, out char16* pbstrLongName, out IntBool pfIsOriginalFile) GetPathName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHost self, out char16* pbstrShortName) GetFileName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentHost self) NotifyChanged;
			}
		}
		[CRepr]
		public struct IDebugDocumentContext : IUnknown
		{
			public const new Guid IID = .(0x51973c28, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetDocument(out IDebugDocument* ppsd) mut => VT.GetDocument(ref this, out ppsd);
			public HResult EnumCodeContexts(out IEnumDebugCodeContexts* ppescc) mut => VT.EnumCodeContexts(ref this, out ppescc);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentContext self, out IDebugDocument* ppsd) GetDocument;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugDocumentContext self, out IEnumDebugCodeContexts* ppescc) EnumCodeContexts;
			}
		}
		[CRepr]
		public struct IDebugSessionProvider : IUnknown
		{
			public const new Guid IID = .(0x51973c29, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult StartDebugSession(ref IRemoteDebugApplication pda) mut => VT.StartDebugSession(ref this, ref pda);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugSessionProvider self, ref IRemoteDebugApplication pda) StartDebugSession;
			}
		}
		[CRepr]
		public struct IApplicationDebugger : IUnknown
		{
			public const new Guid IID = .(0x51973c2a, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult QueryAlive() mut => VT.QueryAlive(ref this);
			public HResult CreateInstanceAtDebugger(in Guid rclsid, ref IUnknown pUnkOuter, uint32 dwClsContext, in Guid riid, out IUnknown* ppvObject) mut => VT.CreateInstanceAtDebugger(ref this, rclsid, ref pUnkOuter, dwClsContext, riid, out ppvObject);
			public HResult onDebugOutput(char16* pstr) mut => VT.onDebugOutput(ref this, pstr);
			public HResult onHandleBreakPoint(ref IRemoteDebugApplicationThread prpt, BREAKREASON br, ref IActiveScriptErrorDebug pError) mut => VT.onHandleBreakPoint(ref this, ref prpt, br, ref pError);
			public HResult onClose() mut => VT.onClose(ref this);
			public HResult onDebuggerEvent(in Guid riid, ref IUnknown punk) mut => VT.onDebuggerEvent(ref this, riid, ref punk);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IApplicationDebugger self) QueryAlive;
				public new function [CallingConvention(.Stdcall)] HResult(ref IApplicationDebugger self, in Guid rclsid, ref IUnknown pUnkOuter, uint32 dwClsContext, in Guid riid, out IUnknown* ppvObject) CreateInstanceAtDebugger;
				public new function [CallingConvention(.Stdcall)] HResult(ref IApplicationDebugger self, char16* pstr) onDebugOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IApplicationDebugger self, ref IRemoteDebugApplicationThread prpt, BREAKREASON br, ref IActiveScriptErrorDebug pError) onHandleBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IApplicationDebugger self) onClose;
				public new function [CallingConvention(.Stdcall)] HResult(ref IApplicationDebugger self, in Guid riid, ref IUnknown punk) onDebuggerEvent;
			}
		}
		[CRepr]
		public struct IApplicationDebuggerUI : IUnknown
		{
			public const new Guid IID = .(0x51973c2b, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult BringDocumentToTop(ref IDebugDocumentText pddt) mut => VT.BringDocumentToTop(ref this, ref pddt);
			public HResult BringDocumentContextToTop(ref IDebugDocumentContext pddc) mut => VT.BringDocumentContextToTop(ref this, ref pddc);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IApplicationDebuggerUI self, ref IDebugDocumentText pddt) BringDocumentToTop;
				public new function [CallingConvention(.Stdcall)] HResult(ref IApplicationDebuggerUI self, ref IDebugDocumentContext pddc) BringDocumentContextToTop;
			}
		}
		[CRepr]
		public struct IMachineDebugManager : IUnknown
		{
			public const new Guid IID = .(0x51973c2c, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AddApplication(ref IRemoteDebugApplication pda, out uint32 pdwAppCookie) mut => VT.AddApplication(ref this, ref pda, out pdwAppCookie);
			public HResult RemoveApplication(uint32 dwAppCookie) mut => VT.RemoveApplication(ref this, dwAppCookie);
			public HResult EnumApplications(out IEnumRemoteDebugApplications* ppeda) mut => VT.EnumApplications(ref this, out ppeda);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IMachineDebugManager self, ref IRemoteDebugApplication pda, out uint32 pdwAppCookie) AddApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IMachineDebugManager self, uint32 dwAppCookie) RemoveApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IMachineDebugManager self, out IEnumRemoteDebugApplications* ppeda) EnumApplications;
			}
		}
		[CRepr]
		public struct IMachineDebugManagerCookie : IUnknown
		{
			public const new Guid IID = .(0x51973c2d, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AddApplication(ref IRemoteDebugApplication pda, uint32 dwDebugAppCookie, out uint32 pdwAppCookie) mut => VT.AddApplication(ref this, ref pda, dwDebugAppCookie, out pdwAppCookie);
			public HResult RemoveApplication(uint32 dwDebugAppCookie, uint32 dwAppCookie) mut => VT.RemoveApplication(ref this, dwDebugAppCookie, dwAppCookie);
			public HResult EnumApplications(out IEnumRemoteDebugApplications* ppeda) mut => VT.EnumApplications(ref this, out ppeda);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IMachineDebugManagerCookie self, ref IRemoteDebugApplication pda, uint32 dwDebugAppCookie, out uint32 pdwAppCookie) AddApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IMachineDebugManagerCookie self, uint32 dwDebugAppCookie, uint32 dwAppCookie) RemoveApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IMachineDebugManagerCookie self, out IEnumRemoteDebugApplications* ppeda) EnumApplications;
			}
		}
		[CRepr]
		public struct IMachineDebugManagerEvents : IUnknown
		{
			public const new Guid IID = .(0x51973c2e, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult onAddApplication(ref IRemoteDebugApplication pda, uint32 dwAppCookie) mut => VT.onAddApplication(ref this, ref pda, dwAppCookie);
			public HResult onRemoveApplication(ref IRemoteDebugApplication pda, uint32 dwAppCookie) mut => VT.onRemoveApplication(ref this, ref pda, dwAppCookie);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IMachineDebugManagerEvents self, ref IRemoteDebugApplication pda, uint32 dwAppCookie) onAddApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IMachineDebugManagerEvents self, ref IRemoteDebugApplication pda, uint32 dwAppCookie) onRemoveApplication;
			}
		}
		[CRepr]
		public struct IProcessDebugManager32 : IUnknown
		{
			public const new Guid IID = .(0x51973c2f, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CreateApplication(out IDebugApplication32* ppda) mut => VT.CreateApplication(ref this, out ppda);
			public HResult GetDefaultApplication(out IDebugApplication32* ppda) mut => VT.GetDefaultApplication(ref this, out ppda);
			public HResult AddApplication(ref IDebugApplication32 pda, out uint32 pdwAppCookie) mut => VT.AddApplication(ref this, ref pda, out pdwAppCookie);
			public HResult RemoveApplication(uint32 dwAppCookie) mut => VT.RemoveApplication(ref this, dwAppCookie);
			public HResult CreateDebugDocumentHelper(ref IUnknown punkOuter, out IDebugDocumentHelper32* pddh) mut => VT.CreateDebugDocumentHelper(ref this, ref punkOuter, out pddh);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager32 self, out IDebugApplication32* ppda) CreateApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager32 self, out IDebugApplication32* ppda) GetDefaultApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager32 self, ref IDebugApplication32 pda, out uint32 pdwAppCookie) AddApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager32 self, uint32 dwAppCookie) RemoveApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager32 self, ref IUnknown punkOuter, out IDebugDocumentHelper32* pddh) CreateDebugDocumentHelper;
			}
		}
		[CRepr]
		public struct IProcessDebugManager64 : IUnknown
		{
			public const new Guid IID = .(0x56b9fc1c, 0x63a9, 0x4cc1, 0xac, 0x21, 0x08, 0x7d, 0x69, 0xa1, 0x7f, 0xab);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CreateApplication(out IDebugApplication64* ppda) mut => VT.CreateApplication(ref this, out ppda);
			public HResult GetDefaultApplication(out IDebugApplication64* ppda) mut => VT.GetDefaultApplication(ref this, out ppda);
			public HResult AddApplication(ref IDebugApplication64 pda, out uint32 pdwAppCookie) mut => VT.AddApplication(ref this, ref pda, out pdwAppCookie);
			public HResult RemoveApplication(uint32 dwAppCookie) mut => VT.RemoveApplication(ref this, dwAppCookie);
			public HResult CreateDebugDocumentHelper(ref IUnknown punkOuter, out IDebugDocumentHelper64* pddh) mut => VT.CreateDebugDocumentHelper(ref this, ref punkOuter, out pddh);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager64 self, out IDebugApplication64* ppda) CreateApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager64 self, out IDebugApplication64* ppda) GetDefaultApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager64 self, ref IDebugApplication64 pda, out uint32 pdwAppCookie) AddApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager64 self, uint32 dwAppCookie) RemoveApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IProcessDebugManager64 self, ref IUnknown punkOuter, out IDebugDocumentHelper64* pddh) CreateDebugDocumentHelper;
			}
		}
		[CRepr]
		public struct IRemoteDebugApplication : IUnknown
		{
			public const new Guid IID = .(0x51973c30, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ResumeFromBreakPoint(ref IRemoteDebugApplicationThread prptFocus, BREAKRESUME_ACTION bra, ERRORRESUMEACTION era) mut => VT.ResumeFromBreakPoint(ref this, ref prptFocus, bra, era);
			public HResult CauseBreak() mut => VT.CauseBreak(ref this);
			public HResult ConnectDebugger(ref IApplicationDebugger pad) mut => VT.ConnectDebugger(ref this, ref pad);
			public HResult DisconnectDebugger() mut => VT.DisconnectDebugger(ref this);
			public HResult GetDebugger(out IApplicationDebugger* pad) mut => VT.GetDebugger(ref this, out pad);
			public HResult CreateInstanceAtApplication(in Guid rclsid, ref IUnknown pUnkOuter, uint32 dwClsContext, in Guid riid, out IUnknown* ppvObject) mut => VT.CreateInstanceAtApplication(ref this, rclsid, ref pUnkOuter, dwClsContext, riid, out ppvObject);
			public HResult QueryAlive() mut => VT.QueryAlive(ref this);
			public HResult EnumThreads(out IEnumRemoteDebugApplicationThreads* pperdat) mut => VT.EnumThreads(ref this, out pperdat);
			public HResult GetName(out char16* pbstrName) mut => VT.GetName(ref this, out pbstrName);
			public HResult GetRootNode(out IDebugApplicationNode* ppdanRoot) mut => VT.GetRootNode(ref this, out ppdanRoot);
			public HResult EnumGlobalExpressionContexts(out IEnumDebugExpressionContexts* ppedec) mut => VT.EnumGlobalExpressionContexts(ref this, out ppedec);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self, ref IRemoteDebugApplicationThread prptFocus, BREAKRESUME_ACTION bra, ERRORRESUMEACTION era) ResumeFromBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self) CauseBreak;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self, ref IApplicationDebugger pad) ConnectDebugger;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self) DisconnectDebugger;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self, out IApplicationDebugger* pad) GetDebugger;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self, in Guid rclsid, ref IUnknown pUnkOuter, uint32 dwClsContext, in Guid riid, out IUnknown* ppvObject) CreateInstanceAtApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self) QueryAlive;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self, out IEnumRemoteDebugApplicationThreads* pperdat) EnumThreads;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self, out char16* pbstrName) GetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self, out IDebugApplicationNode* ppdanRoot) GetRootNode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication self, out IEnumDebugExpressionContexts* ppedec) EnumGlobalExpressionContexts;
			}
		}
		[CRepr]
		public struct IDebugApplication32 : IRemoteDebugApplication
		{
			public const new Guid IID = .(0x51973c32, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SetName(char16* pstrName) mut => VT.SetName(ref this, pstrName);
			public HResult StepOutComplete() mut => VT.StepOutComplete(ref this);
			public HResult DebugOutput(char16* pstr) mut => VT.DebugOutput(ref this, pstr);
			public HResult StartDebugSession() mut => VT.StartDebugSession(ref this);
			public HResult HandleBreakPoint(BREAKREASON br, out BREAKRESUME_ACTION pbra) mut => VT.HandleBreakPoint(ref this, br, out pbra);
			public HResult Close() mut => VT.Close(ref this);
			public HResult GetBreakFlags(out uint32 pabf, out IRemoteDebugApplicationThread* pprdatSteppingThread) mut => VT.GetBreakFlags(ref this, out pabf, out pprdatSteppingThread);
			public HResult GetCurrentThread(out IDebugApplicationThread* pat) mut => VT._GetCurrentThread(ref this, out pat);
			public HResult CreateAsyncDebugOperation(ref IDebugSyncOperation psdo, out IDebugAsyncOperation* ppado) mut => VT.CreateAsyncDebugOperation(ref this, ref psdo, out ppado);
			public HResult AddStackFrameSniffer(ref IDebugStackFrameSniffer pdsfs, out uint32 pdwCookie) mut => VT.AddStackFrameSniffer(ref this, ref pdsfs, out pdwCookie);
			public HResult RemoveStackFrameSniffer(uint32 dwCookie) mut => VT.RemoveStackFrameSniffer(ref this, dwCookie);
			public HResult QueryCurrentThreadIsDebuggerThread() mut => VT.QueryCurrentThreadIsDebuggerThread(ref this);
			public HResult SynchronousCallInDebuggerThread(ref IDebugThreadCall32 pptc, uint32 dwParam1, uint32 dwParam2, uint32 dwParam3) mut => VT.SynchronousCallInDebuggerThread(ref this, ref pptc, dwParam1, dwParam2, dwParam3);
			public HResult CreateApplicationNode(out IDebugApplicationNode* ppdanNew) mut => VT.CreateApplicationNode(ref this, out ppdanNew);
			public HResult FireDebuggerEvent(in Guid riid, ref IUnknown punk) mut => VT.FireDebuggerEvent(ref this, riid, ref punk);
			public HResult HandleRuntimeError(ref IActiveScriptErrorDebug pErrorDebug, ref IActiveScriptSite pScriptSite, out BREAKRESUME_ACTION pbra, out ERRORRESUMEACTION perra, out IntBool pfCallOnScriptError) mut => VT.HandleRuntimeError(ref this, ref pErrorDebug, ref pScriptSite, out pbra, out perra, out pfCallOnScriptError);
			public IntBool FCanJitDebug() mut => VT.FCanJitDebug(ref this);
			public IntBool FIsAutoJitDebugEnabled() mut => VT.FIsAutoJitDebugEnabled(ref this);
			public HResult AddGlobalExpressionContextProvider(ref IProvideExpressionContexts pdsfs, out uint32 pdwCookie) mut => VT.AddGlobalExpressionContextProvider(ref this, ref pdsfs, out pdwCookie);
			public HResult RemoveGlobalExpressionContextProvider(uint32 dwCookie) mut => VT.RemoveGlobalExpressionContextProvider(ref this, dwCookie);

			[CRepr]
			public struct VTable : IRemoteDebugApplication.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, char16* pstrName) SetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self) StepOutComplete;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, char16* pstr) DebugOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self) StartDebugSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, BREAKREASON br, out BREAKRESUME_ACTION pbra) HandleBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self) Close;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, out uint32 pabf, out IRemoteDebugApplicationThread* pprdatSteppingThread) GetBreakFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, out IDebugApplicationThread* pat) _GetCurrentThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, ref IDebugSyncOperation psdo, out IDebugAsyncOperation* ppado) CreateAsyncDebugOperation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, ref IDebugStackFrameSniffer pdsfs, out uint32 pdwCookie) AddStackFrameSniffer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, uint32 dwCookie) RemoveStackFrameSniffer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self) QueryCurrentThreadIsDebuggerThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, ref IDebugThreadCall32 pptc, uint32 dwParam1, uint32 dwParam2, uint32 dwParam3) SynchronousCallInDebuggerThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, out IDebugApplicationNode* ppdanNew) CreateApplicationNode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, in Guid riid, ref IUnknown punk) FireDebuggerEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, ref IActiveScriptErrorDebug pErrorDebug, ref IActiveScriptSite pScriptSite, out BREAKRESUME_ACTION pbra, out ERRORRESUMEACTION perra, out IntBool pfCallOnScriptError) HandleRuntimeError;
				public new function [CallingConvention(.Stdcall)] IntBool(ref IDebugApplication32 self) FCanJitDebug;
				public new function [CallingConvention(.Stdcall)] IntBool(ref IDebugApplication32 self) FIsAutoJitDebugEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, ref IProvideExpressionContexts pdsfs, out uint32 pdwCookie) AddGlobalExpressionContextProvider;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication32 self, uint32 dwCookie) RemoveGlobalExpressionContextProvider;
			}
		}
		[CRepr]
		public struct IDebugApplication64 : IRemoteDebugApplication
		{
			public const new Guid IID = .(0x4dedc754, 0x04c7, 0x4f10, 0x9e, 0x60, 0x16, 0xa3, 0x90, 0xfe, 0x6e, 0x62);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SetName(char16* pstrName) mut => VT.SetName(ref this, pstrName);
			public HResult StepOutComplete() mut => VT.StepOutComplete(ref this);
			public HResult DebugOutput(char16* pstr) mut => VT.DebugOutput(ref this, pstr);
			public HResult StartDebugSession() mut => VT.StartDebugSession(ref this);
			public HResult HandleBreakPoint(BREAKREASON br, out BREAKRESUME_ACTION pbra) mut => VT.HandleBreakPoint(ref this, br, out pbra);
			public HResult Close() mut => VT.Close(ref this);
			public HResult GetBreakFlags(out uint32 pabf, out IRemoteDebugApplicationThread* pprdatSteppingThread) mut => VT.GetBreakFlags(ref this, out pabf, out pprdatSteppingThread);
			public HResult GetCurrentThread(out IDebugApplicationThread* pat) mut => VT._GetCurrentThread(ref this, out pat);
			public HResult CreateAsyncDebugOperation(ref IDebugSyncOperation psdo, out IDebugAsyncOperation* ppado) mut => VT.CreateAsyncDebugOperation(ref this, ref psdo, out ppado);
			public HResult AddStackFrameSniffer(ref IDebugStackFrameSniffer pdsfs, out uint32 pdwCookie) mut => VT.AddStackFrameSniffer(ref this, ref pdsfs, out pdwCookie);
			public HResult RemoveStackFrameSniffer(uint32 dwCookie) mut => VT.RemoveStackFrameSniffer(ref this, dwCookie);
			public HResult QueryCurrentThreadIsDebuggerThread() mut => VT.QueryCurrentThreadIsDebuggerThread(ref this);
			public HResult SynchronousCallInDebuggerThread(ref IDebugThreadCall64 pptc, uint64 dwParam1, uint64 dwParam2, uint64 dwParam3) mut => VT.SynchronousCallInDebuggerThread(ref this, ref pptc, dwParam1, dwParam2, dwParam3);
			public HResult CreateApplicationNode(out IDebugApplicationNode* ppdanNew) mut => VT.CreateApplicationNode(ref this, out ppdanNew);
			public HResult FireDebuggerEvent(in Guid riid, ref IUnknown punk) mut => VT.FireDebuggerEvent(ref this, riid, ref punk);
			public HResult HandleRuntimeError(ref IActiveScriptErrorDebug pErrorDebug, ref IActiveScriptSite pScriptSite, out BREAKRESUME_ACTION pbra, out ERRORRESUMEACTION perra, out IntBool pfCallOnScriptError) mut => VT.HandleRuntimeError(ref this, ref pErrorDebug, ref pScriptSite, out pbra, out perra, out pfCallOnScriptError);
			public IntBool FCanJitDebug() mut => VT.FCanJitDebug(ref this);
			public IntBool FIsAutoJitDebugEnabled() mut => VT.FIsAutoJitDebugEnabled(ref this);
			public HResult AddGlobalExpressionContextProvider(ref IProvideExpressionContexts pdsfs, out uint64 pdwCookie) mut => VT.AddGlobalExpressionContextProvider(ref this, ref pdsfs, out pdwCookie);
			public HResult RemoveGlobalExpressionContextProvider(uint64 dwCookie) mut => VT.RemoveGlobalExpressionContextProvider(ref this, dwCookie);

			[CRepr]
			public struct VTable : IRemoteDebugApplication.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, char16* pstrName) SetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self) StepOutComplete;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, char16* pstr) DebugOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self) StartDebugSession;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, BREAKREASON br, out BREAKRESUME_ACTION pbra) HandleBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self) Close;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, out uint32 pabf, out IRemoteDebugApplicationThread* pprdatSteppingThread) GetBreakFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, out IDebugApplicationThread* pat) _GetCurrentThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, ref IDebugSyncOperation psdo, out IDebugAsyncOperation* ppado) CreateAsyncDebugOperation;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, ref IDebugStackFrameSniffer pdsfs, out uint32 pdwCookie) AddStackFrameSniffer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, uint32 dwCookie) RemoveStackFrameSniffer;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self) QueryCurrentThreadIsDebuggerThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, ref IDebugThreadCall64 pptc, uint64 dwParam1, uint64 dwParam2, uint64 dwParam3) SynchronousCallInDebuggerThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, out IDebugApplicationNode* ppdanNew) CreateApplicationNode;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, in Guid riid, ref IUnknown punk) FireDebuggerEvent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, ref IActiveScriptErrorDebug pErrorDebug, ref IActiveScriptSite pScriptSite, out BREAKRESUME_ACTION pbra, out ERRORRESUMEACTION perra, out IntBool pfCallOnScriptError) HandleRuntimeError;
				public new function [CallingConvention(.Stdcall)] IntBool(ref IDebugApplication64 self) FCanJitDebug;
				public new function [CallingConvention(.Stdcall)] IntBool(ref IDebugApplication64 self) FIsAutoJitDebugEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, ref IProvideExpressionContexts pdsfs, out uint64 pdwCookie) AddGlobalExpressionContextProvider;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication64 self, uint64 dwCookie) RemoveGlobalExpressionContextProvider;
			}
		}
		[CRepr]
		public struct IRemoteDebugApplicationEvents : IUnknown
		{
			public const new Guid IID = .(0x51973c33, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult OnConnectDebugger(ref IApplicationDebugger pad) mut => VT.OnConnectDebugger(ref this, ref pad);
			public HResult OnDisconnectDebugger() mut => VT.OnDisconnectDebugger(ref this);
			public HResult OnSetName(char16* pstrName) mut => VT.OnSetName(ref this, pstrName);
			public HResult OnDebugOutput(char16* pstr) mut => VT.OnDebugOutput(ref this, pstr);
			public HResult OnClose() mut => VT.OnClose(ref this);
			public HResult OnEnterBreakPoint(ref IRemoteDebugApplicationThread prdat) mut => VT.OnEnterBreakPoint(ref this, ref prdat);
			public HResult OnLeaveBreakPoint(ref IRemoteDebugApplicationThread prdat) mut => VT.OnLeaveBreakPoint(ref this, ref prdat);
			public HResult OnCreateThread(ref IRemoteDebugApplicationThread prdat) mut => VT.OnCreateThread(ref this, ref prdat);
			public HResult OnDestroyThread(ref IRemoteDebugApplicationThread prdat) mut => VT.OnDestroyThread(ref this, ref prdat);
			public HResult OnBreakFlagChange(uint32 abf, ref IRemoteDebugApplicationThread prdatSteppingThread) mut => VT.OnBreakFlagChange(ref this, abf, ref prdatSteppingThread);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self, ref IApplicationDebugger pad) OnConnectDebugger;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self) OnDisconnectDebugger;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self, char16* pstrName) OnSetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self, char16* pstr) OnDebugOutput;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self) OnClose;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self, ref IRemoteDebugApplicationThread prdat) OnEnterBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self, ref IRemoteDebugApplicationThread prdat) OnLeaveBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self, ref IRemoteDebugApplicationThread prdat) OnCreateThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self, ref IRemoteDebugApplicationThread prdat) OnDestroyThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationEvents self, uint32 abf, ref IRemoteDebugApplicationThread prdatSteppingThread) OnBreakFlagChange;
			}
		}
		[CRepr]
		public struct IDebugApplicationNode : IDebugDocumentProvider
		{
			public const new Guid IID = .(0x51973c34, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EnumChildren(out IEnumDebugApplicationNodes* pperddp) mut => VT.EnumChildren(ref this, out pperddp);
			public HResult GetParent(out IDebugApplicationNode* pprddp) mut => VT._GetParent(ref this, out pprddp);
			public HResult SetDocumentProvider(ref IDebugDocumentProvider pddp) mut => VT.SetDocumentProvider(ref this, ref pddp);
			public HResult Close() mut => VT.Close(ref this);
			public HResult Attach(ref IDebugApplicationNode pdanParent) mut => VT.Attach(ref this, ref pdanParent);
			public HResult Detach() mut => VT.Detach(ref this);

			[CRepr]
			public struct VTable : IDebugDocumentProvider.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNode self, out IEnumDebugApplicationNodes* pperddp) EnumChildren;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNode self, out IDebugApplicationNode* pprddp) _GetParent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNode self, ref IDebugDocumentProvider pddp) SetDocumentProvider;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNode self) Close;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNode self, ref IDebugApplicationNode pdanParent) Attach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNode self) Detach;
			}
		}
		[CRepr]
		public struct IDebugApplicationNodeEvents : IUnknown
		{
			public const new Guid IID = .(0x51973c35, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult onAddChild(ref IDebugApplicationNode prddpChild) mut => VT.onAddChild(ref this, ref prddpChild);
			public HResult onRemoveChild(ref IDebugApplicationNode prddpChild) mut => VT.onRemoveChild(ref this, ref prddpChild);
			public HResult onDetach() mut => VT.onDetach(ref this);
			public HResult onAttach(ref IDebugApplicationNode prddpParent) mut => VT.onAttach(ref this, ref prddpParent);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNodeEvents self, ref IDebugApplicationNode prddpChild) onAddChild;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNodeEvents self, ref IDebugApplicationNode prddpChild) onRemoveChild;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNodeEvents self) onDetach;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNodeEvents self, ref IDebugApplicationNode prddpParent) onAttach;
			}
		}
		[CRepr]
		public struct AsyncIDebugApplicationNodeEvents : IUnknown
		{
			public const new Guid IID = .(0xa2e3aa3b, 0xaa8d, 0x4ebf, 0x84, 0xcd, 0x64, 0x8b, 0x73, 0x7b, 0x8c, 0x13);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Begin_onAddChild(ref IDebugApplicationNode prddpChild) mut => VT.Begin_onAddChild(ref this, ref prddpChild);
			public HResult Finish_onAddChild() mut => VT.Finish_onAddChild(ref this);
			public HResult Begin_onRemoveChild(ref IDebugApplicationNode prddpChild) mut => VT.Begin_onRemoveChild(ref this, ref prddpChild);
			public HResult Finish_onRemoveChild() mut => VT.Finish_onRemoveChild(ref this);
			public HResult Begin_onDetach() mut => VT.Begin_onDetach(ref this);
			public HResult Finish_onDetach() mut => VT.Finish_onDetach(ref this);
			public HResult Begin_onAttach(ref IDebugApplicationNode prddpParent) mut => VT.Begin_onAttach(ref this, ref prddpParent);
			public HResult Finish_onAttach() mut => VT.Finish_onAttach(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref AsyncIDebugApplicationNodeEvents self, ref IDebugApplicationNode prddpChild) Begin_onAddChild;
				public new function [CallingConvention(.Stdcall)] HResult(ref AsyncIDebugApplicationNodeEvents self) Finish_onAddChild;
				public new function [CallingConvention(.Stdcall)] HResult(ref AsyncIDebugApplicationNodeEvents self, ref IDebugApplicationNode prddpChild) Begin_onRemoveChild;
				public new function [CallingConvention(.Stdcall)] HResult(ref AsyncIDebugApplicationNodeEvents self) Finish_onRemoveChild;
				public new function [CallingConvention(.Stdcall)] HResult(ref AsyncIDebugApplicationNodeEvents self) Begin_onDetach;
				public new function [CallingConvention(.Stdcall)] HResult(ref AsyncIDebugApplicationNodeEvents self) Finish_onDetach;
				public new function [CallingConvention(.Stdcall)] HResult(ref AsyncIDebugApplicationNodeEvents self, ref IDebugApplicationNode prddpParent) Begin_onAttach;
				public new function [CallingConvention(.Stdcall)] HResult(ref AsyncIDebugApplicationNodeEvents self) Finish_onAttach;
			}
		}
		[CRepr]
		public struct IDebugThreadCall32 : IUnknown
		{
			public const new Guid IID = .(0x51973c36, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ThreadCallHandler(uint32 dwParam1, uint32 dwParam2, uint32 dwParam3) mut => VT.ThreadCallHandler(ref this, dwParam1, dwParam2, dwParam3);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugThreadCall32 self, uint32 dwParam1, uint32 dwParam2, uint32 dwParam3) ThreadCallHandler;
			}
		}
		[CRepr]
		public struct IDebugThreadCall64 : IUnknown
		{
			public const new Guid IID = .(0xcb3fa335, 0xe979, 0x42fd, 0x9f, 0xcf, 0xa7, 0x54, 0x6a, 0x0f, 0x39, 0x05);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ThreadCallHandler(uint64 dwParam1, uint64 dwParam2, uint64 dwParam3) mut => VT.ThreadCallHandler(ref this, dwParam1, dwParam2, dwParam3);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugThreadCall64 self, uint64 dwParam1, uint64 dwParam2, uint64 dwParam3) ThreadCallHandler;
			}
		}
		[CRepr]
		public struct IRemoteDebugApplicationThread : IUnknown
		{
			public const new Guid IID = .(0x51973c37, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSystemThreadId(out uint32 dwThreadId) mut => VT.GetSystemThreadId(ref this, out dwThreadId);
			public HResult GetApplication(out IRemoteDebugApplication* pprda) mut => VT.GetApplication(ref this, out pprda);
			public HResult EnumStackFrames(out IEnumDebugStackFrames* ppedsf) mut => VT.EnumStackFrames(ref this, out ppedsf);
			public HResult GetDescription(out char16* pbstrDescription, out char16* pbstrState) mut => VT.GetDescription(ref this, out pbstrDescription, out pbstrState);
			public HResult SetNextStatement(ref IDebugStackFrame pStackFrame, ref IDebugCodeContext pCodeContext) mut => VT.SetNextStatement(ref this, ref pStackFrame, ref pCodeContext);
			public HResult GetState(out uint32 pState) mut => VT.GetState(ref this, out pState);
			public HResult Suspend(out uint32 pdwCount) mut => VT.Suspend(ref this, out pdwCount);
			public HResult Resume(out uint32 pdwCount) mut => VT.Resume(ref this, out pdwCount);
			public HResult GetSuspendCount(out uint32 pdwCount) mut => VT.GetSuspendCount(ref this, out pdwCount);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationThread self, out uint32 dwThreadId) GetSystemThreadId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationThread self, out IRemoteDebugApplication* pprda) GetApplication;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationThread self, out IEnumDebugStackFrames* ppedsf) EnumStackFrames;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationThread self, out char16* pbstrDescription, out char16* pbstrState) GetDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationThread self, ref IDebugStackFrame pStackFrame, ref IDebugCodeContext pCodeContext) SetNextStatement;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationThread self, out uint32 pState) GetState;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationThread self, out uint32 pdwCount) Suspend;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationThread self, out uint32 pdwCount) Resume;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplicationThread self, out uint32 pdwCount) GetSuspendCount;
			}
		}
		[CRepr]
		public struct IDebugApplicationThread : IRemoteDebugApplicationThread
		{
			public const new Guid IID = .(0x51973c38, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SynchronousCallIntoThread32(ref IDebugThreadCall32 pstcb, uint32 dwParam1, uint32 dwParam2, uint32 dwParam3) mut => VT.SynchronousCallIntoThread32(ref this, ref pstcb, dwParam1, dwParam2, dwParam3);
			public HResult QueryIsCurrentThread() mut => VT.QueryIsCurrentThread(ref this);
			public HResult QueryIsDebuggerThread() mut => VT.QueryIsDebuggerThread(ref this);
			public HResult SetDescription(char16* pstrDescription) mut => VT.SetDescription(ref this, pstrDescription);
			public HResult SetStateString(char16* pstrState) mut => VT.SetStateString(ref this, pstrState);

			[CRepr]
			public struct VTable : IRemoteDebugApplicationThread.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread self, ref IDebugThreadCall32 pstcb, uint32 dwParam1, uint32 dwParam2, uint32 dwParam3) SynchronousCallIntoThread32;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread self) QueryIsCurrentThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread self) QueryIsDebuggerThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread self, char16* pstrDescription) SetDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread self, char16* pstrState) SetStateString;
			}
		}
		[CRepr]
		public struct IDebugApplicationThread64 : IDebugApplicationThread
		{
			public const new Guid IID = .(0x9dac5886, 0xdbad, 0x456d, 0x9d, 0xee, 0x5d, 0xec, 0x39, 0xab, 0x3d, 0xda);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SynchronousCallIntoThread64(ref IDebugThreadCall64 pstcb, uint64 dwParam1, uint64 dwParam2, uint64 dwParam3) mut => VT.SynchronousCallIntoThread64(ref this, ref pstcb, dwParam1, dwParam2, dwParam3);

			[CRepr]
			public struct VTable : IDebugApplicationThread.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread64 self, ref IDebugThreadCall64 pstcb, uint64 dwParam1, uint64 dwParam2, uint64 dwParam3) SynchronousCallIntoThread64;
			}
		}
		[CRepr]
		public struct IDebugCookie : IUnknown
		{
			public const new Guid IID = .(0x51973c39, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SetDebugCookie(uint32 dwDebugAppCookie) mut => VT.SetDebugCookie(ref this, dwDebugAppCookie);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugCookie self, uint32 dwDebugAppCookie) SetDebugCookie;
			}
		}
		[CRepr]
		public struct IEnumDebugApplicationNodes : IUnknown
		{
			public const new Guid IID = .(0x51973c3a, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 celt, out IDebugApplicationNode* pprddp, out uint32 pceltFetched) mut => VT.Next(ref this, celt, out pprddp, out pceltFetched);
			public HResult Skip(uint32 celt) mut => VT.Skip(ref this, celt);
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult Clone(out IEnumDebugApplicationNodes* pperddp) mut => VT.Clone(ref this, out pperddp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugApplicationNodes self, uint32 celt, out IDebugApplicationNode* pprddp, out uint32 pceltFetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugApplicationNodes self, uint32 celt) Skip;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugApplicationNodes self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugApplicationNodes self, out IEnumDebugApplicationNodes* pperddp) Clone;
			}
		}
		[CRepr]
		public struct IEnumRemoteDebugApplications : IUnknown
		{
			public const new Guid IID = .(0x51973c3b, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 celt, out IRemoteDebugApplication* ppda, out uint32 pceltFetched) mut => VT.Next(ref this, celt, out ppda, out pceltFetched);
			public HResult Skip(uint32 celt) mut => VT.Skip(ref this, celt);
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult Clone(out IEnumRemoteDebugApplications* ppessd) mut => VT.Clone(ref this, out ppessd);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumRemoteDebugApplications self, uint32 celt, out IRemoteDebugApplication* ppda, out uint32 pceltFetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumRemoteDebugApplications self, uint32 celt) Skip;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumRemoteDebugApplications self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumRemoteDebugApplications self, out IEnumRemoteDebugApplications* ppessd) Clone;
			}
		}
		[CRepr]
		public struct IEnumRemoteDebugApplicationThreads : IUnknown
		{
			public const new Guid IID = .(0x51973c3c, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 celt, out IRemoteDebugApplicationThread* pprdat, out uint32 pceltFetched) mut => VT.Next(ref this, celt, out pprdat, out pceltFetched);
			public HResult Skip(uint32 celt) mut => VT.Skip(ref this, celt);
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult Clone(out IEnumRemoteDebugApplicationThreads* pperdat) mut => VT.Clone(ref this, out pperdat);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumRemoteDebugApplicationThreads self, uint32 celt, out IRemoteDebugApplicationThread* pprdat, out uint32 pceltFetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumRemoteDebugApplicationThreads self, uint32 celt) Skip;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumRemoteDebugApplicationThreads self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumRemoteDebugApplicationThreads self, out IEnumRemoteDebugApplicationThreads* pperdat) Clone;
			}
		}
		[CRepr]
		public struct IDebugFormatter : IUnknown
		{
			public const new Guid IID = .(0x51973c05, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetStringForVariant(ref VARIANT pvar, uint32 nRadix, out char16* pbstrValue) mut => VT.GetStringForVariant(ref this, ref pvar, nRadix, out pbstrValue);
			public HResult GetVariantForString(char16* pwstrValue, out VARIANT pvar) mut => VT.GetVariantForString(ref this, pwstrValue, out pvar);
			public HResult GetStringForVarType(uint16 vt, ref TYPEDESC ptdescArrayType, out char16* pbstr) mut => VT.GetStringForVarType(ref this, vt, ref ptdescArrayType, out pbstr);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugFormatter self, ref VARIANT pvar, uint32 nRadix, out char16* pbstrValue) GetStringForVariant;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugFormatter self, char16* pwstrValue, out VARIANT pvar) GetVariantForString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugFormatter self, uint16 vt, ref TYPEDESC ptdescArrayType, out char16* pbstr) GetStringForVarType;
			}
		}
		[CRepr]
		public struct ISimpleConnectionPoint : IUnknown
		{
			public const new Guid IID = .(0x51973c3e, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetEventCount(out uint32 pulCount) mut => VT.GetEventCount(ref this, out pulCount);
			public HResult DescribeEvents(uint32 iEvent, uint32 cEvents, int32* prgid, char16** prgbstr, out uint32 pcEventsFetched) mut => VT.DescribeEvents(ref this, iEvent, cEvents, prgid, prgbstr, out pcEventsFetched);
			public HResult Advise(ref IDispatch pdisp, out uint32 pdwCookie) mut => VT.Advise(ref this, ref pdisp, out pdwCookie);
			public HResult Unadvise(uint32 dwCookie) mut => VT.Unadvise(ref this, dwCookie);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref ISimpleConnectionPoint self, out uint32 pulCount) GetEventCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref ISimpleConnectionPoint self, uint32 iEvent, uint32 cEvents, int32* prgid, char16** prgbstr, out uint32 pcEventsFetched) DescribeEvents;
				public new function [CallingConvention(.Stdcall)] HResult(ref ISimpleConnectionPoint self, ref IDispatch pdisp, out uint32 pdwCookie) Advise;
				public new function [CallingConvention(.Stdcall)] HResult(ref ISimpleConnectionPoint self, uint32 dwCookie) Unadvise;
			}
		}
		[CRepr]
		public struct IDebugHelper : IUnknown
		{
			public const new Guid IID = .(0x51973c3f, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CreatePropertyBrowser(ref VARIANT pvar, char16* bstrName, ref IDebugApplicationThread pdat, out IDebugProperty* ppdob) mut => VT.CreatePropertyBrowser(ref this, ref pvar, bstrName, ref pdat, out ppdob);
			public HResult CreatePropertyBrowserEx(ref VARIANT pvar, char16* bstrName, ref IDebugApplicationThread pdat, ref IDebugFormatter pdf, out IDebugProperty* ppdob) mut => VT.CreatePropertyBrowserEx(ref this, ref pvar, bstrName, ref pdat, ref pdf, out ppdob);
			public HResult CreateSimpleConnectionPoint(ref IDispatch pdisp, out ISimpleConnectionPoint* ppscp) mut => VT.CreateSimpleConnectionPoint(ref this, ref pdisp, out ppscp);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHelper self, ref VARIANT pvar, char16* bstrName, ref IDebugApplicationThread pdat, out IDebugProperty* ppdob) CreatePropertyBrowser;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHelper self, ref VARIANT pvar, char16* bstrName, ref IDebugApplicationThread pdat, ref IDebugFormatter pdf, out IDebugProperty* ppdob) CreatePropertyBrowserEx;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugHelper self, ref IDispatch pdisp, out ISimpleConnectionPoint* ppscp) CreateSimpleConnectionPoint;
			}
		}
		[CRepr]
		public struct IEnumDebugExpressionContexts : IUnknown
		{
			public const new Guid IID = .(0x51973c40, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 celt, out IDebugExpressionContext* ppdec, out uint32 pceltFetched) mut => VT.Next(ref this, celt, out ppdec, out pceltFetched);
			public HResult Skip(uint32 celt) mut => VT.Skip(ref this, celt);
			public HResult Reset() mut => VT.Reset(ref this);
			public HResult Clone(out IEnumDebugExpressionContexts* ppedec) mut => VT.Clone(ref this, out ppedec);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugExpressionContexts self, uint32 celt, out IDebugExpressionContext* ppdec, out uint32 pceltFetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugExpressionContexts self, uint32 celt) Skip;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugExpressionContexts self) Reset;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumDebugExpressionContexts self, out IEnumDebugExpressionContexts* ppedec) Clone;
			}
		}
		[CRepr]
		public struct IProvideExpressionContexts : IUnknown
		{
			public const new Guid IID = .(0x51973c41, 0xcb0c, 0x11d0, 0xb5, 0xc9, 0x00, 0xa0, 0x24, 0x4a, 0x0e, 0x7a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EnumExpressionContexts(out IEnumDebugExpressionContexts* ppedec) mut => VT.EnumExpressionContexts(ref this, out ppedec);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IProvideExpressionContexts self, out IEnumDebugExpressionContexts* ppedec) EnumExpressionContexts;
			}
		}
		[CRepr]
		public struct IActiveScriptProfilerControl : IUnknown
		{
			public const new Guid IID = .(0x784b5ff0, 0x69b0, 0x47d1, 0xa7, 0xdc, 0x25, 0x18, 0xf4, 0x23, 0x0e, 0x90);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult StartProfiling(in Guid clsidProfilerObject, uint32 dwEventMask, uint32 dwContext) mut => VT.StartProfiling(ref this, clsidProfilerObject, dwEventMask, dwContext);
			public HResult SetProfilerEventMask(uint32 dwEventMask) mut => VT.SetProfilerEventMask(ref this, dwEventMask);
			public HResult StopProfiling(HResult hrShutdownReason) mut => VT.StopProfiling(ref this, hrShutdownReason);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerControl self, in Guid clsidProfilerObject, uint32 dwEventMask, uint32 dwContext) StartProfiling;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerControl self, uint32 dwEventMask) SetProfilerEventMask;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerControl self, HResult hrShutdownReason) StopProfiling;
			}
		}
		[CRepr]
		public struct IActiveScriptProfilerControl2 : IActiveScriptProfilerControl
		{
			public const new Guid IID = .(0x47810165, 0x498f, 0x40be, 0x94, 0xf1, 0x65, 0x35, 0x57, 0xe9, 0xe7, 0xda);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CompleteProfilerStart() mut => VT.CompleteProfilerStart(ref this);
			public HResult PrepareProfilerStop() mut => VT.PrepareProfilerStop(ref this);

			[CRepr]
			public struct VTable : IActiveScriptProfilerControl.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerControl2 self) CompleteProfilerStart;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerControl2 self) PrepareProfilerStop;
			}
		}
		[CRepr]
		public struct IActiveScriptProfilerHeapEnum : IUnknown
		{
			public const new Guid IID = .(0x32e4694e, 0x0d37, 0x419b, 0xb9, 0x3d, 0xfa, 0x20, 0xde, 0xd6, 0xe8, 0xea);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 celt, PROFILER_HEAP_OBJECT** heapObjects, out uint32 pceltFetched) mut => VT.Next(ref this, celt, heapObjects, out pceltFetched);
			public HResult GetOptionalInfo(ref PROFILER_HEAP_OBJECT heapObject, uint32 celt, PROFILER_HEAP_OBJECT_OPTIONAL_INFO* optionalInfo) mut => VT.GetOptionalInfo(ref this, ref heapObject, celt, optionalInfo);
			public HResult FreeObjectAndOptionalInfo(uint32 celt, PROFILER_HEAP_OBJECT** heapObjects) mut => VT.FreeObjectAndOptionalInfo(ref this, celt, heapObjects);
			public HResult GetNameIdMap(char16**** pNameList, out uint32 pcelt) mut => VT.GetNameIdMap(ref this, pNameList, out pcelt);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerHeapEnum self, uint32 celt, PROFILER_HEAP_OBJECT** heapObjects, out uint32 pceltFetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerHeapEnum self, ref PROFILER_HEAP_OBJECT heapObject, uint32 celt, PROFILER_HEAP_OBJECT_OPTIONAL_INFO* optionalInfo) GetOptionalInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerHeapEnum self, uint32 celt, PROFILER_HEAP_OBJECT** heapObjects) FreeObjectAndOptionalInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerHeapEnum self, char16**** pNameList, out uint32 pcelt) GetNameIdMap;
			}
		}
		[CRepr]
		public struct IActiveScriptProfilerControl3 : IActiveScriptProfilerControl2
		{
			public const new Guid IID = .(0x0b403015, 0xf381, 0x4023, 0xa5, 0xd0, 0x6f, 0xed, 0x07, 0x6d, 0xe7, 0x16);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EnumHeap(out IActiveScriptProfilerHeapEnum* ppEnum) mut => VT.EnumHeap(ref this, out ppEnum);

			[CRepr]
			public struct VTable : IActiveScriptProfilerControl2.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerControl3 self, out IActiveScriptProfilerHeapEnum* ppEnum) EnumHeap;
			}
		}
		[CRepr]
		public struct IActiveScriptProfilerControl4 : IActiveScriptProfilerControl3
		{
			public const new Guid IID = .(0x160f94fd, 0x9dbc, 0x40d4, 0x9e, 0xac, 0x2b, 0x71, 0xdb, 0x31, 0x32, 0xf4);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SummarizeHeap(out PROFILER_HEAP_SUMMARY heapSummary) mut => VT.SummarizeHeap(ref this, out heapSummary);

			[CRepr]
			public struct VTable : IActiveScriptProfilerControl3.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerControl4 self, out PROFILER_HEAP_SUMMARY heapSummary) SummarizeHeap;
			}
		}
		[CRepr]
		public struct IActiveScriptProfilerControl5 : IActiveScriptProfilerControl4
		{
			public const new Guid IID = .(0x1c01a2d1, 0x8f0f, 0x46a5, 0x97, 0x20, 0x0d, 0x7e, 0xd2, 0xc6, 0x2f, 0x0a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult EnumHeap2(PROFILER_HEAP_ENUM_FLAGS enumFlags, out IActiveScriptProfilerHeapEnum* ppEnum) mut => VT.EnumHeap2(ref this, enumFlags, out ppEnum);

			[CRepr]
			public struct VTable : IActiveScriptProfilerControl4.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerControl5 self, PROFILER_HEAP_ENUM_FLAGS enumFlags, out IActiveScriptProfilerHeapEnum* ppEnum) EnumHeap2;
			}
		}
		[CRepr]
		public struct IActiveScriptProfilerCallback : IUnknown
		{
			public const new Guid IID = .(0x740eca23, 0x7d9d, 0x42e5, 0xba, 0x9d, 0xf8, 0xb2, 0x4b, 0x1c, 0x7a, 0x9b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Initialize(uint32 dwContext) mut => VT.Initialize(ref this, dwContext);
			public HResult Shutdown(HResult hrReason) mut => VT.Shutdown(ref this, hrReason);
			public HResult ScriptCompiled(int32 scriptId, PROFILER_SCRIPT_TYPE type, ref IUnknown pIDebugDocumentContext) mut => VT.ScriptCompiled(ref this, scriptId, type, ref pIDebugDocumentContext);
			public HResult FunctionCompiled(int32 functionId, int32 scriptId, char16* pwszFunctionName, char16* pwszFunctionNameHint, ref IUnknown pIDebugDocumentContext) mut => VT.FunctionCompiled(ref this, functionId, scriptId, pwszFunctionName, pwszFunctionNameHint, ref pIDebugDocumentContext);
			public HResult OnFunctionEnter(int32 scriptId, int32 functionId) mut => VT.OnFunctionEnter(ref this, scriptId, functionId);
			public HResult OnFunctionExit(int32 scriptId, int32 functionId) mut => VT.OnFunctionExit(ref this, scriptId, functionId);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerCallback self, uint32 dwContext) Initialize;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerCallback self, HResult hrReason) Shutdown;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerCallback self, int32 scriptId, PROFILER_SCRIPT_TYPE type, ref IUnknown pIDebugDocumentContext) ScriptCompiled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerCallback self, int32 functionId, int32 scriptId, char16* pwszFunctionName, char16* pwszFunctionNameHint, ref IUnknown pIDebugDocumentContext) FunctionCompiled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerCallback self, int32 scriptId, int32 functionId) OnFunctionEnter;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerCallback self, int32 scriptId, int32 functionId) OnFunctionExit;
			}
		}
		[CRepr]
		public struct IActiveScriptProfilerCallback2 : IActiveScriptProfilerCallback
		{
			public const new Guid IID = .(0x31b7f8ad, 0xa637, 0x409c, 0xb2, 0x2f, 0x04, 0x09, 0x95, 0xb6, 0x10, 0x3d);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult OnFunctionEnterByName(char16* pwszFunctionName, PROFILER_SCRIPT_TYPE type) mut => VT.OnFunctionEnterByName(ref this, pwszFunctionName, type);
			public HResult OnFunctionExitByName(char16* pwszFunctionName, PROFILER_SCRIPT_TYPE type) mut => VT.OnFunctionExitByName(ref this, pwszFunctionName, type);

			[CRepr]
			public struct VTable : IActiveScriptProfilerCallback.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerCallback2 self, char16* pwszFunctionName, PROFILER_SCRIPT_TYPE type) OnFunctionEnterByName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerCallback2 self, char16* pwszFunctionName, PROFILER_SCRIPT_TYPE type) OnFunctionExitByName;
			}
		}
		[CRepr]
		public struct IActiveScriptProfilerCallback3 : IActiveScriptProfilerCallback2
		{
			public const new Guid IID = .(0x6ac5ad25, 0x2037, 0x4687, 0x91, 0xdf, 0xb5, 0x99, 0x79, 0xd9, 0x3d, 0x73);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SetWebWorkerId(uint32 webWorkerId) mut => VT.SetWebWorkerId(ref this, webWorkerId);

			[CRepr]
			public struct VTable : IActiveScriptProfilerCallback2.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptProfilerCallback3 self, uint32 webWorkerId) SetWebWorkerId;
			}
		}
		[CRepr]
		public struct IScriptNode : IUnknown
		{
			public const new Guid IID = .(0x0aee2a94, 0xbcbb, 0x11d0, 0x8c, 0x72, 0x00, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Alive() mut => VT.Alive(ref this);
			public HResult Delete() mut => VT.Delete(ref this);
			public HResult GetParent(out IScriptNode* ppsnParent) mut => VT._GetParent(ref this, out ppsnParent);
			public HResult GetIndexInParent(out uint32 pisn) mut => VT.GetIndexInParent(ref this, out pisn);
			public HResult GetCookie(out uint32 pdwCookie) mut => VT.GetCookie(ref this, out pdwCookie);
			public HResult GetNumberOfChildren(out uint32 pcsn) mut => VT.GetNumberOfChildren(ref this, out pcsn);
			public HResult GetChild(uint32 isn, out IScriptNode* ppsn) mut => VT.GetChild(ref this, isn, out ppsn);
			public HResult GetLanguage(out char16* pbstr) mut => VT.GetLanguage(ref this, out pbstr);
			public HResult CreateChildEntry(uint32 isn, uint32 dwCookie, char16* pszDelimiter, out IScriptEntry* ppse) mut => VT.CreateChildEntry(ref this, isn, dwCookie, pszDelimiter, out ppse);
			public HResult CreateChildHandler(char16* pszDefaultName, char16** prgpszNames, uint32 cpszNames, char16* pszEvent, char16* pszDelimiter, ref ITypeInfo ptiSignature, uint32 iMethodSignature, uint32 isn, uint32 dwCookie, out IScriptEntry* ppse) mut => VT.CreateChildHandler(ref this, pszDefaultName, prgpszNames, cpszNames, pszEvent, pszDelimiter, ref ptiSignature, iMethodSignature, isn, dwCookie, out ppse);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self) Alive;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self) Delete;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self, out IScriptNode* ppsnParent) _GetParent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self, out uint32 pisn) GetIndexInParent;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self, out uint32 pdwCookie) GetCookie;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self, out uint32 pcsn) GetNumberOfChildren;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self, uint32 isn, out IScriptNode* ppsn) GetChild;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self, out char16* pbstr) GetLanguage;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self, uint32 isn, uint32 dwCookie, char16* pszDelimiter, out IScriptEntry* ppse) CreateChildEntry;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptNode self, char16* pszDefaultName, char16** prgpszNames, uint32 cpszNames, char16* pszEvent, char16* pszDelimiter, ref ITypeInfo ptiSignature, uint32 iMethodSignature, uint32 isn, uint32 dwCookie, out IScriptEntry* ppse) CreateChildHandler;
			}
		}
		[CRepr]
		public struct IScriptEntry : IScriptNode
		{
			public const new Guid IID = .(0x0aee2a95, 0xbcbb, 0x11d0, 0x8c, 0x72, 0x00, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetText(out char16* pbstr) mut => VT.GetText(ref this, out pbstr);
			public HResult SetText(char16* psz) mut => VT.SetText(ref this, psz);
			public HResult GetBody(out char16* pbstr) mut => VT.GetBody(ref this, out pbstr);
			public HResult SetBody(char16* psz) mut => VT.SetBody(ref this, psz);
			public HResult GetName(out char16* pbstr) mut => VT.GetName(ref this, out pbstr);
			public HResult SetName(char16* psz) mut => VT.SetName(ref this, psz);
			public HResult GetItemName(out char16* pbstr) mut => VT.GetItemName(ref this, out pbstr);
			public HResult SetItemName(char16* psz) mut => VT.SetItemName(ref this, psz);
			public HResult GetSignature(out ITypeInfo* ppti, out uint32 piMethod) mut => VT.GetSignature(ref this, out ppti, out piMethod);
			public HResult SetSignature(ref ITypeInfo pti, uint32 iMethod) mut => VT.SetSignature(ref this, ref pti, iMethod);
			public HResult GetRange(out uint32 pichMin, out uint32 pcch) mut => VT.GetRange(ref this, out pichMin, out pcch);

			[CRepr]
			public struct VTable : IScriptNode.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, out char16* pbstr) GetText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, char16* psz) SetText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, out char16* pbstr) GetBody;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, char16* psz) SetBody;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, out char16* pbstr) GetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, char16* psz) SetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, out char16* pbstr) GetItemName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, char16* psz) SetItemName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, out ITypeInfo* ppti, out uint32 piMethod) GetSignature;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, ref ITypeInfo pti, uint32 iMethod) SetSignature;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptEntry self, out uint32 pichMin, out uint32 pcch) GetRange;
			}
		}
		[CRepr]
		public struct IScriptScriptlet : IScriptEntry
		{
			public const new Guid IID = .(0x0aee2a96, 0xbcbb, 0x11d0, 0x8c, 0x72, 0x00, 0xc0, 0x4f, 0xc2, 0xb0, 0x85);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetSubItemName(out char16* pbstr) mut => VT.GetSubItemName(ref this, out pbstr);
			public HResult SetSubItemName(char16* psz) mut => VT.SetSubItemName(ref this, psz);
			public HResult GetEventName(out char16* pbstr) mut => VT.GetEventName(ref this, out pbstr);
			public HResult SetEventName(char16* psz) mut => VT.SetEventName(ref this, psz);
			public HResult GetSimpleEventName(out char16* pbstr) mut => VT.GetSimpleEventName(ref this, out pbstr);
			public HResult SetSimpleEventName(char16* psz) mut => VT.SetSimpleEventName(ref this, psz);

			[CRepr]
			public struct VTable : IScriptEntry.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptScriptlet self, out char16* pbstr) GetSubItemName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptScriptlet self, char16* psz) SetSubItemName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptScriptlet self, out char16* pbstr) GetEventName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptScriptlet self, char16* psz) SetEventName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptScriptlet self, out char16* pbstr) GetSimpleEventName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptScriptlet self, char16* psz) SetSimpleEventName;
			}
		}
		[CRepr]
		public struct IActiveScriptAuthor : IUnknown
		{
			public const new Guid IID = .(0x9c109da0, 0x7006, 0x11d1, 0xb3, 0x6c, 0x00, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult AddNamedItem(char16* pszName, uint32 dwFlags, ref IDispatch pdisp) mut => VT.AddNamedItem(ref this, pszName, dwFlags, ref pdisp);
			public HResult AddScriptlet(char16* pszDefaultName, char16* pszCode, char16* pszItemName, char16* pszSubItemName, char16* pszEventName, char16* pszDelimiter, uint32 dwCookie, uint32 dwFlags) mut => VT.AddScriptlet(ref this, pszDefaultName, pszCode, pszItemName, pszSubItemName, pszEventName, pszDelimiter, dwCookie, dwFlags);
			public HResult ParseScriptText(char16* pszCode, char16* pszItemName, char16* pszDelimiter, uint32 dwCookie, uint32 dwFlags) mut => VT.ParseScriptText(ref this, pszCode, pszItemName, pszDelimiter, dwCookie, dwFlags);
			public HResult GetScriptTextAttributes(char16* pszCode, uint32 cch, char16* pszDelimiter, uint32 dwFlags, uint16* pattr) mut => VT.GetScriptTextAttributes(ref this, pszCode, cch, pszDelimiter, dwFlags, pattr);
			public HResult GetScriptletTextAttributes(char16* pszCode, uint32 cch, char16* pszDelimiter, uint32 dwFlags, uint16* pattr) mut => VT.GetScriptletTextAttributes(ref this, pszCode, cch, pszDelimiter, dwFlags, pattr);
			public HResult GetRoot(out IScriptNode* ppsp) mut => VT.GetRoot(ref this, out ppsp);
			public HResult GetLanguageFlags(out uint32 pgrfasa) mut => VT.GetLanguageFlags(ref this, out pgrfasa);
			public HResult GetEventHandler(ref IDispatch pdisp, char16* pszItem, char16* pszSubItem, char16* pszEvent, out IScriptEntry* ppse) mut => VT.GetEventHandler(ref this, ref pdisp, pszItem, pszSubItem, pszEvent, out ppse);
			public HResult RemoveNamedItem(char16* pszName) mut => VT.RemoveNamedItem(ref this, pszName);
			public HResult AddTypeLib(in Guid rguidTypeLib, uint32 dwMajor, uint32 dwMinor, uint32 dwFlags) mut => VT.AddTypeLib(ref this, rguidTypeLib, dwMajor, dwMinor, dwFlags);
			public HResult RemoveTypeLib(in Guid rguidTypeLib, uint32 dwMajor, uint32 dwMinor) mut => VT.RemoveTypeLib(ref this, rguidTypeLib, dwMajor, dwMinor);
			public HResult GetChars(uint32 fRequestedList, out char16* pbstrChars) mut => VT.GetChars(ref this, fRequestedList, out pbstrChars);
			public HResult GetInfoFromContext(char16* pszCode, uint32 cchCode, uint32 ichCurrentPosition, uint32 dwListTypesRequested, out uint32 pdwListTypesProvided, out uint32 pichListAnchorPosition, out uint32 pichFuncAnchorPosition, out int32 pmemid, out int32 piCurrentParameter, out IUnknown* ppunk) mut => VT.GetInfoFromContext(ref this, pszCode, cchCode, ichCurrentPosition, dwListTypesRequested, out pdwListTypesProvided, out pichListAnchorPosition, out pichFuncAnchorPosition, out pmemid, out piCurrentParameter, out ppunk);
			public HResult IsCommitChar(char16 ch, out IntBool pfcommit) mut => VT.IsCommitChar(ref this, ch, out pfcommit);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, char16* pszName, uint32 dwFlags, ref IDispatch pdisp) AddNamedItem;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, char16* pszDefaultName, char16* pszCode, char16* pszItemName, char16* pszSubItemName, char16* pszEventName, char16* pszDelimiter, uint32 dwCookie, uint32 dwFlags) AddScriptlet;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, char16* pszCode, char16* pszItemName, char16* pszDelimiter, uint32 dwCookie, uint32 dwFlags) ParseScriptText;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, char16* pszCode, uint32 cch, char16* pszDelimiter, uint32 dwFlags, uint16* pattr) GetScriptTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, char16* pszCode, uint32 cch, char16* pszDelimiter, uint32 dwFlags, uint16* pattr) GetScriptletTextAttributes;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, out IScriptNode* ppsp) GetRoot;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, out uint32 pgrfasa) GetLanguageFlags;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, ref IDispatch pdisp, char16* pszItem, char16* pszSubItem, char16* pszEvent, out IScriptEntry* ppse) GetEventHandler;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, char16* pszName) RemoveNamedItem;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, in Guid rguidTypeLib, uint32 dwMajor, uint32 dwMinor, uint32 dwFlags) AddTypeLib;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, in Guid rguidTypeLib, uint32 dwMajor, uint32 dwMinor) RemoveTypeLib;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, uint32 fRequestedList, out char16* pbstrChars) GetChars;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, char16* pszCode, uint32 cchCode, uint32 ichCurrentPosition, uint32 dwListTypesRequested, out uint32 pdwListTypesProvided, out uint32 pichListAnchorPosition, out uint32 pichFuncAnchorPosition, out int32 pmemid, out int32 piCurrentParameter, out IUnknown* ppunk) GetInfoFromContext;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthor self, char16 ch, out IntBool pfcommit) IsCommitChar;
			}
		}
		[CRepr]
		public struct IActiveScriptAuthorProcedure : IUnknown
		{
			public const new Guid IID = .(0x7e2d4b70, 0xbd9a, 0x11d0, 0x93, 0x36, 0x00, 0xa0, 0xc9, 0x0d, 0xca, 0xa9);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ParseProcedureText(char16* pszCode, char16* pszFormalParams, char16* pszProcedureName, char16* pszItemName, char16* pszDelimiter, uint32 dwCookie, uint32 dwFlags, ref IDispatch pdispFor) mut => VT.ParseProcedureText(ref this, pszCode, pszFormalParams, pszProcedureName, pszItemName, pszDelimiter, dwCookie, dwFlags, ref pdispFor);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptAuthorProcedure self, char16* pszCode, char16* pszFormalParams, char16* pszProcedureName, char16* pszItemName, char16* pszDelimiter, uint32 dwCookie, uint32 dwFlags, ref IDispatch pdispFor) ParseProcedureText;
			}
		}
		[CRepr]
		public struct IDebugApplicationNode100 : IUnknown
		{
			public const new Guid IID = .(0x90a7734e, 0x841b, 0x4f77, 0x93, 0x84, 0xa2, 0x89, 0x1e, 0x76, 0xe7, 0xe2);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SetFilterForEventSink(uint32 dwCookie, APPLICATION_NODE_EVENT_FILTER filter) mut => VT.SetFilterForEventSink(ref this, dwCookie, filter);
			public HResult GetExcludedDocuments(APPLICATION_NODE_EVENT_FILTER filter, out TEXT_DOCUMENT_ARRAY pDocuments) mut => VT.GetExcludedDocuments(ref this, filter, out pDocuments);
			public HResult QueryIsChildNode(ref IDebugDocument pSearchKey) mut => VT.QueryIsChildNode(ref this, ref pSearchKey);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNode100 self, uint32 dwCookie, APPLICATION_NODE_EVENT_FILTER filter) SetFilterForEventSink;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNode100 self, APPLICATION_NODE_EVENT_FILTER filter, out TEXT_DOCUMENT_ARRAY pDocuments) GetExcludedDocuments;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationNode100 self, ref IDebugDocument pSearchKey) QueryIsChildNode;
			}
		}
		[CRepr]
		public struct IWebAppDiagnosticsSetup : IUnknown
		{
			public const new Guid IID = .(0x379bfbe1, 0xc6c9, 0x432a, 0x93, 0xe1, 0x6d, 0x17, 0x65, 0x6c, 0x53, 0x8c);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult DiagnosticsSupported(out int16 pRetVal) mut => VT.DiagnosticsSupported(ref this, out pRetVal);
			public HResult CreateObjectWithSiteAtWebApp(in Guid rclsid, uint32 dwClsContext, in Guid riid, uint hPassToObject) mut => VT.CreateObjectWithSiteAtWebApp(ref this, rclsid, dwClsContext, riid, hPassToObject);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IWebAppDiagnosticsSetup self, out int16 pRetVal) DiagnosticsSupported;
				public new function [CallingConvention(.Stdcall)] HResult(ref IWebAppDiagnosticsSetup self, in Guid rclsid, uint32 dwClsContext, in Guid riid, uint hPassToObject) CreateObjectWithSiteAtWebApp;
			}
		}
		[CRepr]
		public struct IRemoteDebugApplication110 : IUnknown
		{
			public const new Guid IID = .(0xd5fe005b, 0x2836, 0x485e, 0xb1, 0xf9, 0x89, 0xd9, 0x1a, 0xa2, 0x4f, 0xd4);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SetDebuggerOptions(SCRIPT_DEBUGGER_OPTIONS mask, SCRIPT_DEBUGGER_OPTIONS value) mut => VT.SetDebuggerOptions(ref this, mask, value);
			public HResult GetCurrentDebuggerOptions(out SCRIPT_DEBUGGER_OPTIONS pCurrentOptions) mut => VT.GetCurrentDebuggerOptions(ref this, out pCurrentOptions);
			public HResult GetMainThread(out IRemoteDebugApplicationThread* ppThread) mut => VT.GetMainThread(ref this, out ppThread);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication110 self, SCRIPT_DEBUGGER_OPTIONS mask, SCRIPT_DEBUGGER_OPTIONS value) SetDebuggerOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication110 self, out SCRIPT_DEBUGGER_OPTIONS pCurrentOptions) GetCurrentDebuggerOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugApplication110 self, out IRemoteDebugApplicationThread* ppThread) GetMainThread;
			}
		}
		[CRepr]
		public struct IDebugApplication11032 : IRemoteDebugApplication110
		{
			public const new Guid IID = .(0xbdb3b5de, 0x89f2, 0x4e11, 0x84, 0xa5, 0x97, 0x44, 0x5f, 0x94, 0x1c, 0x7d);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SynchronousCallInMainThread(ref IDebugThreadCall32 pptc, uint dwParam1, uint dwParam2, uint dwParam3) mut => VT.SynchronousCallInMainThread(ref this, ref pptc, dwParam1, dwParam2, dwParam3);
			public HResult AsynchronousCallInMainThread(ref IDebugThreadCall32 pptc, uint dwParam1, uint dwParam2, uint dwParam3) mut => VT.AsynchronousCallInMainThread(ref this, ref pptc, dwParam1, dwParam2, dwParam3);
			public HResult CallableWaitForHandles(uint32 handleCount, Handle* pHandles, out uint32 pIndex) mut => VT.CallableWaitForHandles(ref this, handleCount, pHandles, out pIndex);

			[CRepr]
			public struct VTable : IRemoteDebugApplication110.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication11032 self, ref IDebugThreadCall32 pptc, uint dwParam1, uint dwParam2, uint dwParam3) SynchronousCallInMainThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication11032 self, ref IDebugThreadCall32 pptc, uint dwParam1, uint dwParam2, uint dwParam3) AsynchronousCallInMainThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication11032 self, uint32 handleCount, Handle* pHandles, out uint32 pIndex) CallableWaitForHandles;
			}
		}
		[CRepr]
		public struct IDebugApplication11064 : IRemoteDebugApplication110
		{
			public const new Guid IID = .(0x2039d958, 0x4eeb, 0x496a, 0x87, 0xbb, 0x2e, 0x52, 0x01, 0xea, 0xde, 0xef);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult SynchronousCallInMainThread(ref IDebugThreadCall64 pptc, uint dwParam1, uint dwParam2, uint dwParam3) mut => VT.SynchronousCallInMainThread(ref this, ref pptc, dwParam1, dwParam2, dwParam3);
			public HResult AsynchronousCallInMainThread(ref IDebugThreadCall64 pptc, uint dwParam1, uint dwParam2, uint dwParam3) mut => VT.AsynchronousCallInMainThread(ref this, ref pptc, dwParam1, dwParam2, dwParam3);
			public HResult CallableWaitForHandles(uint32 handleCount, Handle* pHandles, out uint32 pIndex) mut => VT.CallableWaitForHandles(ref this, handleCount, pHandles, out pIndex);

			[CRepr]
			public struct VTable : IRemoteDebugApplication110.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication11064 self, ref IDebugThreadCall64 pptc, uint dwParam1, uint dwParam2, uint dwParam3) SynchronousCallInMainThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication11064 self, ref IDebugThreadCall64 pptc, uint dwParam1, uint dwParam2, uint dwParam3) AsynchronousCallInMainThread;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplication11064 self, uint32 handleCount, Handle* pHandles, out uint32 pIndex) CallableWaitForHandles;
			}
		}
		[CRepr]
		public struct IWebAppDiagnosticsObjectInitialization : IUnknown
		{
			public const new Guid IID = .(0x16ff3a42, 0xa5f5, 0x432b, 0xb6, 0x25, 0x8e, 0x8e, 0x16, 0xf5, 0x7e, 0x15);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Initialize(HANDLE_PTR hPassedHandle, ref IUnknown pDebugApplication) mut => VT.Initialize(ref this, hPassedHandle, ref pDebugApplication);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IWebAppDiagnosticsObjectInitialization self, HANDLE_PTR hPassedHandle, ref IUnknown pDebugApplication) Initialize;
			}
		}
		[CRepr]
		public struct IActiveScriptWinRTErrorDebug : IActiveScriptError
		{
			public const new Guid IID = .(0x73a3f82a, 0x0fe9, 0x4b33, 0xba, 0x3b, 0xfe, 0x09, 0x5f, 0x69, 0x7e, 0x0a);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetRestrictedErrorString(out char16* errorString) mut => VT.GetRestrictedErrorString(ref this, out errorString);
			public HResult GetRestrictedErrorReference(out char16* referenceString) mut => VT.GetRestrictedErrorReference(ref this, out referenceString);
			public HResult GetCapabilitySid(out char16* capabilitySid) mut => VT.GetCapabilitySid(ref this, out capabilitySid);

			[CRepr]
			public struct VTable : IActiveScriptError.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptWinRTErrorDebug self, out char16* errorString) GetRestrictedErrorString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptWinRTErrorDebug self, out char16* referenceString) GetRestrictedErrorReference;
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptWinRTErrorDebug self, out char16* capabilitySid) GetCapabilitySid;
			}
		}
		[CRepr]
		public struct IActiveScriptErrorDebug110 : IUnknown
		{
			public const new Guid IID = .(0x516e42b6, 0x89a8, 0x4530, 0x93, 0x7b, 0x5f, 0x07, 0x08, 0x43, 0x14, 0x42);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetExceptionThrownKind(out SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND pExceptionKind) mut => VT.GetExceptionThrownKind(ref this, out pExceptionKind);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IActiveScriptErrorDebug110 self, out SCRIPT_ERROR_DEBUG_EXCEPTION_THROWN_KIND pExceptionKind) GetExceptionThrownKind;
			}
		}
		[CRepr]
		public struct IDebugApplicationThreadEvents110 : IUnknown
		{
			public const new Guid IID = .(0x84e5e468, 0xd5da, 0x48a8, 0x83, 0xf4, 0x40, 0x36, 0x64, 0x29, 0x00, 0x7b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult OnSuspendForBreakPoint() mut => VT.OnSuspendForBreakPoint(ref this);
			public HResult OnResumeFromBreakPoint() mut => VT.OnResumeFromBreakPoint(ref this);
			public HResult OnThreadRequestComplete() mut => VT.OnThreadRequestComplete(ref this);
			public HResult OnBeginThreadRequest() mut => VT.OnBeginThreadRequest(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThreadEvents110 self) OnSuspendForBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThreadEvents110 self) OnResumeFromBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThreadEvents110 self) OnThreadRequestComplete;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThreadEvents110 self) OnBeginThreadRequest;
			}
		}
		[CRepr]
		public struct IDebugApplicationThread11032 : IUnknown
		{
			public const new Guid IID = .(0x2194ac5c, 0x6561, 0x404a, 0xa2, 0xe9, 0xf5, 0x7d, 0x72, 0xde, 0x37, 0x02);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetActiveThreadRequestCount(out uint32 puiThreadRequests) mut => VT.GetActiveThreadRequestCount(ref this, out puiThreadRequests);
			public HResult IsSuspendedForBreakPoint(out IntBool pfIsSuspended) mut => VT.IsSuspendedForBreakPoint(ref this, out pfIsSuspended);
			public HResult IsThreadCallable(out IntBool pfIsCallable) mut => VT.IsThreadCallable(ref this, out pfIsCallable);
			public HResult AsynchronousCallIntoThread(ref IDebugThreadCall32 pptc, uint dwParam1, uint dwParam2, uint dwParam3) mut => VT.AsynchronousCallIntoThread(ref this, ref pptc, dwParam1, dwParam2, dwParam3);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread11032 self, out uint32 puiThreadRequests) GetActiveThreadRequestCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread11032 self, out IntBool pfIsSuspended) IsSuspendedForBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread11032 self, out IntBool pfIsCallable) IsThreadCallable;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread11032 self, ref IDebugThreadCall32 pptc, uint dwParam1, uint dwParam2, uint dwParam3) AsynchronousCallIntoThread;
			}
		}
		[CRepr]
		public struct IDebugApplicationThread11064 : IUnknown
		{
			public const new Guid IID = .(0x420aa4cc, 0xefd8, 0x4dac, 0x98, 0x3b, 0x47, 0x12, 0x78, 0x26, 0x91, 0x7d);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetActiveThreadRequestCount(out uint32 puiThreadRequests) mut => VT.GetActiveThreadRequestCount(ref this, out puiThreadRequests);
			public HResult IsSuspendedForBreakPoint(out IntBool pfIsSuspended) mut => VT.IsSuspendedForBreakPoint(ref this, out pfIsSuspended);
			public HResult IsThreadCallable(out IntBool pfIsCallable) mut => VT.IsThreadCallable(ref this, out pfIsCallable);
			public HResult AsynchronousCallIntoThread(ref IDebugThreadCall64 pptc, uint dwParam1, uint dwParam2, uint dwParam3) mut => VT.AsynchronousCallIntoThread(ref this, ref pptc, dwParam1, dwParam2, dwParam3);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread11064 self, out uint32 puiThreadRequests) GetActiveThreadRequestCount;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread11064 self, out IntBool pfIsSuspended) IsSuspendedForBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread11064 self, out IntBool pfIsCallable) IsThreadCallable;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugApplicationThread11064 self, ref IDebugThreadCall64 pptc, uint dwParam1, uint dwParam2, uint dwParam3) AsynchronousCallIntoThread;
			}
		}
		[CRepr]
		public struct IRemoteDebugCriticalErrorEvent110 : IUnknown
		{
			public const new Guid IID = .(0x2f69c611, 0x6b14, 0x47e8, 0x92, 0x60, 0x4b, 0xb7, 0xc5, 0x2f, 0x50, 0x4b);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetErrorInfo(out char16* pbstrSource, out int32 pMessageId, out char16* pbstrMessage, out IDebugDocumentContext* ppLocation) mut => VT._GetErrorInfo(ref this, out pbstrSource, out pMessageId, out pbstrMessage, out ppLocation);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugCriticalErrorEvent110 self, out char16* pbstrSource, out int32 pMessageId, out char16* pbstrMessage, out IDebugDocumentContext* ppLocation) _GetErrorInfo;
			}
		}
		[CRepr]
		public struct IScriptInvocationContext : IUnknown
		{
			public const new Guid IID = .(0x5d7741b7, 0xaf7e, 0x4a2a, 0x85, 0xe5, 0xc7, 0x7f, 0x4d, 0x06, 0x59, 0xfb);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetContextType(out SCRIPT_INVOCATION_CONTEXT_TYPE pInvocationContextType) mut => VT.GetContextType(ref this, out pInvocationContextType);
			public HResult GetContextDescription(out char16* pDescription) mut => VT.GetContextDescription(ref this, out pDescription);
			public HResult GetContextObject(out IUnknown* ppContextObject) mut => VT.GetContextObject(ref this, out ppContextObject);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptInvocationContext self, out SCRIPT_INVOCATION_CONTEXT_TYPE pInvocationContextType) GetContextType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptInvocationContext self, out char16* pDescription) GetContextDescription;
				public new function [CallingConvention(.Stdcall)] HResult(ref IScriptInvocationContext self, out IUnknown* ppContextObject) GetContextObject;
			}
		}
		[CRepr]
		public struct IDebugStackFrame110 : IDebugStackFrame
		{
			public const new Guid IID = .(0x4b509611, 0xb6ea, 0x4b24, 0xad, 0xcb, 0xd0, 0xcc, 0xfd, 0x1a, 0x7e, 0x33);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetStackFrameType(out DEBUG_STACKFRAME_TYPE pStackFrameKind) mut => VT.GetStackFrameType(ref this, out pStackFrameKind);
			public HResult GetScriptInvocationContext(out IScriptInvocationContext* ppInvocationContext) mut => VT.GetScriptInvocationContext(ref this, out ppInvocationContext);

			[CRepr]
			public struct VTable : IDebugStackFrame.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrame110 self, out DEBUG_STACKFRAME_TYPE pStackFrameKind) GetStackFrameType;
				public new function [CallingConvention(.Stdcall)] HResult(ref IDebugStackFrame110 self, out IScriptInvocationContext* ppInvocationContext) GetScriptInvocationContext;
			}
		}
		[CRepr]
		public struct IRemoteDebugInfoEvent110 : IUnknown
		{
			public const new Guid IID = .(0x9ff56bb6, 0xeb89, 0x4c0f, 0x88, 0x23, 0xcc, 0x2a, 0x4c, 0x0b, 0x7f, 0x26);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetEventInfo(out DEBUG_EVENT_INFO_TYPE pMessageType, out char16* pbstrMessage, out char16* pbstrUrl, out IDebugDocumentContext* ppLocation) mut => VT.GetEventInfo(ref this, out pMessageType, out pbstrMessage, out pbstrUrl, out ppLocation);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IRemoteDebugInfoEvent110 self, out DEBUG_EVENT_INFO_TYPE pMessageType, out char16* pbstrMessage, out char16* pbstrUrl, out IDebugDocumentContext* ppLocation) GetEventInfo;
			}
		}
		[CRepr]
		public struct IJsDebug : IUnknown
		{
			public const new Guid IID = .(0xbe0e89da, 0x2ac5, 0x4c04, 0xac, 0x5e, 0x59, 0x95, 0x6a, 0xae, 0x36, 0x13);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult OpenVirtualProcess(uint32 processId, uint64 runtimeJsBaseAddress, ref IJsDebugDataTarget pDataTarget, out IJsDebugProcess* ppProcess) mut => VT.OpenVirtualProcess(ref this, processId, runtimeJsBaseAddress, ref pDataTarget, out ppProcess);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebug self, uint32 processId, uint64 runtimeJsBaseAddress, ref IJsDebugDataTarget pDataTarget, out IJsDebugProcess* ppProcess) OpenVirtualProcess;
			}
		}
		[CRepr]
		public struct IJsDebugProcess : IUnknown
		{
			public const new Guid IID = .(0x3d587168, 0x6a2d, 0x4041, 0xbd, 0x3b, 0x0d, 0xe6, 0x74, 0x50, 0x28, 0x62);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult CreateStackWalker(uint32 threadId, out IJsDebugStackWalker* ppStackWalker) mut => VT.CreateStackWalker(ref this, threadId, out ppStackWalker);
			public HResult CreateBreakPoint(uint64 documentId, uint32 characterOffset, uint32 characterCount, IntBool isEnabled, out IJsDebugBreakPoint* ppDebugBreakPoint) mut => VT.CreateBreakPoint(ref this, documentId, characterOffset, characterCount, isEnabled, out ppDebugBreakPoint);
			public HResult PerformAsyncBreak(uint32 threadId) mut => VT.PerformAsyncBreak(ref this, threadId);
			public HResult GetExternalStepAddress(out uint64 pCodeAddress) mut => VT.GetExternalStepAddress(ref this, out pCodeAddress);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugProcess self, uint32 threadId, out IJsDebugStackWalker* ppStackWalker) CreateStackWalker;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugProcess self, uint64 documentId, uint32 characterOffset, uint32 characterCount, IntBool isEnabled, out IJsDebugBreakPoint* ppDebugBreakPoint) CreateBreakPoint;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugProcess self, uint32 threadId) PerformAsyncBreak;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugProcess self, out uint64 pCodeAddress) GetExternalStepAddress;
			}
		}
		[CRepr]
		public struct IJsDebugStackWalker : IUnknown
		{
			public const new Guid IID = .(0xdb24b094, 0x73c4, 0x456c, 0xa4, 0xec, 0xe9, 0x0e, 0xa0, 0x0b, 0xdf, 0xe3);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetNext(out IJsDebugFrame* ppFrame) mut => VT.GetNext(ref this, out ppFrame);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugStackWalker self, out IJsDebugFrame* ppFrame) GetNext;
			}
		}
		[CRepr]
		public struct IJsDebugFrame : IUnknown
		{
			public const new Guid IID = .(0xc9196637, 0xab9d, 0x44b2, 0xba, 0xd2, 0x13, 0xb9, 0x5b, 0x3f, 0x39, 0x0e);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetStackRange(out uint64 pStart, out uint64 pEnd) mut => VT.GetStackRange(ref this, out pStart, out pEnd);
			public HResult GetName(out char16* pName) mut => VT.GetName(ref this, out pName);
			public HResult GetDocumentPositionWithId(out uint64 pDocumentId, out uint32 pCharacterOffset, out uint32 pStatementCharCount) mut => VT.GetDocumentPositionWithId(ref this, out pDocumentId, out pCharacterOffset, out pStatementCharCount);
			public HResult GetDocumentPositionWithName(out char16* pDocumentName, out uint32 pLine, out uint32 pColumn) mut => VT.GetDocumentPositionWithName(ref this, out pDocumentName, out pLine, out pColumn);
			public HResult GetDebugProperty(out IJsDebugProperty* ppDebugProperty) mut => VT.GetDebugProperty(ref this, out ppDebugProperty);
			public HResult GetReturnAddress(out uint64 pReturnAddress) mut => VT.GetReturnAddress(ref this, out pReturnAddress);
			public HResult Evaluate(char16* pExpressionText, out IJsDebugProperty* ppDebugProperty, out char16* pError) mut => VT.Evaluate(ref this, pExpressionText, out ppDebugProperty, out pError);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugFrame self, out uint64 pStart, out uint64 pEnd) GetStackRange;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugFrame self, out char16* pName) GetName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugFrame self, out uint64 pDocumentId, out uint32 pCharacterOffset, out uint32 pStatementCharCount) GetDocumentPositionWithId;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugFrame self, out char16* pDocumentName, out uint32 pLine, out uint32 pColumn) GetDocumentPositionWithName;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugFrame self, out IJsDebugProperty* ppDebugProperty) GetDebugProperty;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugFrame self, out uint64 pReturnAddress) GetReturnAddress;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugFrame self, char16* pExpressionText, out IJsDebugProperty* ppDebugProperty, out char16* pError) Evaluate;
			}
		}
		[CRepr]
		public struct IJsDebugProperty : IUnknown
		{
			public const new Guid IID = .(0xf8ffcf2b, 0x3aa4, 0x4320, 0x85, 0xc3, 0x52, 0xa3, 0x12, 0xba, 0x96, 0x33);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetPropertyInfo(uint32 nRadix, out JsDebugPropertyInfo pPropertyInfo) mut => VT.GetPropertyInfo(ref this, nRadix, out pPropertyInfo);
			public HResult GetMembers(JS_PROPERTY_MEMBERS members, out IJsEnumDebugProperty* ppEnum) mut => VT.GetMembers(ref this, members, out ppEnum);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugProperty self, uint32 nRadix, out JsDebugPropertyInfo pPropertyInfo) GetPropertyInfo;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugProperty self, JS_PROPERTY_MEMBERS members, out IJsEnumDebugProperty* ppEnum) GetMembers;
			}
		}
		[CRepr]
		public struct IJsEnumDebugProperty : IUnknown
		{
			public const new Guid IID = .(0x4092432f, 0x2f0f, 0x4fe1, 0xb6, 0x38, 0x5b, 0x74, 0xa5, 0x2c, 0xdc, 0xbe);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 count, IJsDebugProperty** ppDebugProperty, out uint32 pActualCount) mut => VT.Next(ref this, count, ppDebugProperty, out pActualCount);
			public HResult GetCount(out uint32 pCount) mut => VT.GetCount(ref this, out pCount);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsEnumDebugProperty self, uint32 count, IJsDebugProperty** ppDebugProperty, out uint32 pActualCount) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsEnumDebugProperty self, out uint32 pCount) GetCount;
			}
		}
		[CRepr]
		public struct IJsDebugBreakPoint : IUnknown
		{
			public const new Guid IID = .(0xdf6773e3, 0xed8d, 0x488b, 0x8a, 0x3e, 0x58, 0x12, 0x57, 0x7d, 0x15, 0x42);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult IsEnabled(out IntBool pIsEnabled) mut => VT.IsEnabled(ref this, out pIsEnabled);
			public HResult Enable() mut => VT.Enable(ref this);
			public HResult Disable() mut => VT.Disable(ref this);
			public HResult Delete() mut => VT.Delete(ref this);
			public HResult GetDocumentPosition(out uint64 pDocumentId, out uint32 pCharacterOffset, out uint32 pStatementCharCount) mut => VT.GetDocumentPosition(ref this, out pDocumentId, out pCharacterOffset, out pStatementCharCount);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugBreakPoint self, out IntBool pIsEnabled) IsEnabled;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugBreakPoint self) Enable;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugBreakPoint self) Disable;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugBreakPoint self) Delete;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugBreakPoint self, out uint64 pDocumentId, out uint32 pCharacterOffset, out uint32 pStatementCharCount) GetDocumentPosition;
			}
		}
		[CRepr]
		public struct IEnumJsStackFrames : IUnknown
		{
			public const new Guid IID = .(0x5e7da34b, 0xfb51, 0x4791, 0xab, 0xe7, 0xcb, 0x5b, 0xdf, 0x41, 0x97, 0x55);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult Next(uint32 cFrameCount, __MIDL___MIDL_itf_jscript9diag_0000_0007_0001* pFrames, out uint32 pcFetched) mut => VT.Next(ref this, cFrameCount, pFrames, out pcFetched);
			public HResult Reset() mut => VT.Reset(ref this);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumJsStackFrames self, uint32 cFrameCount, __MIDL___MIDL_itf_jscript9diag_0000_0007_0001* pFrames, out uint32 pcFetched) Next;
				public new function [CallingConvention(.Stdcall)] HResult(ref IEnumJsStackFrames self) Reset;
			}
		}
		[CRepr]
		public struct IJsDebugDataTarget : IUnknown
		{
			public const new Guid IID = .(0x53b28977, 0x53a1, 0x48e5, 0x90, 0x00, 0x5d, 0x0d, 0xfa, 0x89, 0x39, 0x31);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult ReadMemory(uint64 address, JsDebugReadMemoryFlags flags, uint8* pBuffer, uint32 size, out uint32 pBytesRead) mut => VT.ReadMemory(ref this, address, flags, pBuffer, size, out pBytesRead);
			public HResult WriteMemory(uint64 address, uint8* pMemory, uint32 size) mut => VT.WriteMemory(ref this, address, pMemory, size);
			public HResult AllocateVirtualMemory(uint64 address, uint32 size, uint32 allocationType, uint32 pageProtection, out uint64 pAllocatedAddress) mut => VT.AllocateVirtualMemory(ref this, address, size, allocationType, pageProtection, out pAllocatedAddress);
			public HResult FreeVirtualMemory(uint64 address, uint32 size, uint32 freeType) mut => VT.FreeVirtualMemory(ref this, address, size, freeType);
			public HResult GetTlsValue(uint32 threadId, uint32 tlsIndex, out uint64 pValue) mut => VT.GetTlsValue(ref this, threadId, tlsIndex, out pValue);
			public HResult ReadBSTR(uint64 address, out char16* pString) mut => VT.ReadBSTR(ref this, address, out pString);
			public HResult ReadNullTerminatedString(uint64 address, uint16 characterSize, uint32 maxCharacters, out char16* pString) mut => VT.ReadNullTerminatedString(ref this, address, characterSize, maxCharacters, out pString);
			public HResult CreateStackFrameEnumerator(uint32 threadId, out IEnumJsStackFrames* ppEnumerator) mut => VT.CreateStackFrameEnumerator(ref this, threadId, out ppEnumerator);
			public HResult GetThreadContext(uint32 threadId, uint32 contextFlags, uint32 contextSize, void* pContext) mut => VT.GetThreadContext(ref this, threadId, contextFlags, contextSize, pContext);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugDataTarget self, uint64 address, JsDebugReadMemoryFlags flags, uint8* pBuffer, uint32 size, out uint32 pBytesRead) ReadMemory;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugDataTarget self, uint64 address, uint8* pMemory, uint32 size) WriteMemory;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugDataTarget self, uint64 address, uint32 size, uint32 allocationType, uint32 pageProtection, out uint64 pAllocatedAddress) AllocateVirtualMemory;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugDataTarget self, uint64 address, uint32 size, uint32 freeType) FreeVirtualMemory;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugDataTarget self, uint32 threadId, uint32 tlsIndex, out uint64 pValue) GetTlsValue;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugDataTarget self, uint64 address, out char16* pString) ReadBSTR;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugDataTarget self, uint64 address, uint16 characterSize, uint32 maxCharacters, out char16* pString) ReadNullTerminatedString;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugDataTarget self, uint32 threadId, out IEnumJsStackFrames* ppEnumerator) CreateStackFrameEnumerator;
				public new function [CallingConvention(.Stdcall)] HResult(ref IJsDebugDataTarget self, uint32 threadId, uint32 contextFlags, uint32 contextSize, void* pContext) GetThreadContext;
			}
		}
		[CRepr]
		public struct IObjectSafety : IUnknown
		{
			public const new Guid IID = .(0xcb5bdc81, 0x93c1, 0x11cf, 0x8f, 0x20, 0x00, 0x80, 0x5f, 0x2c, 0xd0, 0x64);
			
			public new VTable* VT { get => (.)vt; }
			
			public HResult GetInterfaceSafetyOptions(in Guid riid, out uint32 pdwSupportedOptions, out uint32 pdwEnabledOptions) mut => VT.GetInterfaceSafetyOptions(ref this, riid, out pdwSupportedOptions, out pdwEnabledOptions);
			public HResult SetInterfaceSafetyOptions(in Guid riid, uint32 dwOptionSetMask, uint32 dwEnabledOptions) mut => VT.SetInterfaceSafetyOptions(ref this, riid, dwOptionSetMask, dwEnabledOptions);

			[CRepr]
			public struct VTable : IUnknown.VTable
			{
				public new function [CallingConvention(.Stdcall)] HResult(ref IObjectSafety self, in Guid riid, out uint32 pdwSupportedOptions, out uint32 pdwEnabledOptions) GetInterfaceSafetyOptions;
				public new function [CallingConvention(.Stdcall)] HResult(ref IObjectSafety self, in Guid riid, uint32 dwOptionSetMask, uint32 dwEnabledOptions) SetInterfaceSafetyOptions;
			}
		}
		
		// --- Functions ---
		
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern bool RtlAddFunctionTable(IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* FunctionTable, uint32 EntryCount, uint BaseAddress);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern bool RtlDeleteFunctionTable(ref IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY FunctionTable);
		[Import("ntdll.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 RtlAddGrowableFunctionTable(void** DynamicTable, IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* FunctionTable, uint32 EntryCount, uint32 MaximumEntryCount, uint RangeBase, uint RangeEnd);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY* RtlLookupFunctionEntry(uint ControlPc, out uint ImageBase, UNWIND_HISTORY_TABLE* HistoryTable);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern EXCEPTION_ROUTINE RtlVirtualUnwind(RTL_VIRTUAL_UNWIND_HANDLER_TYPE HandlerType, uint ImageBase, uint ControlPc, ref IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY FunctionEntry, out CONTEXT ContextRecord, void** HandlerData, out uint EstablisherFrame, KNONVOLATILE_CONTEXT_POINTERS_ARM64* ContextPointers);
		[Import("dbgeng.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern HResult DebugConnect(char8* RemoteOptions, in Guid InterfaceId, void** Interface);
		[Import("dbgeng.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern HResult DebugConnectWide(char16* RemoteOptions, in Guid InterfaceId, void** Interface);
		[Import("dbgeng.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern HResult DebugCreate(in Guid InterfaceId, void** Interface);
		[Import("dbgeng.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern HResult DebugCreateEx(in Guid InterfaceId, uint32 DbgEngOptions, void** Interface);
		[Import("dbgmodel.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern HResult CreateDataModelManager(ref IDebugHost debugHost, out IDataModelManager* manager);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ReadProcessMemory(Handle hProcess, void* lpBaseAddress, void* lpBuffer, uint nSize, uint* lpNumberOfBytesRead);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool WriteProcessMemory(Handle hProcess, void* lpBaseAddress, void* lpBuffer, uint nSize, uint* lpNumberOfBytesWritten);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool GetThreadContext(Handle hThread, out CONTEXT lpContext);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SetThreadContext(Handle hThread, in CONTEXT lpContext);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool FlushInstructionCache(Handle hProcess, void* lpBaseAddress, uint dwSize);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool Wow64GetThreadContext(Handle hThread, out WOW64_CONTEXT lpContext);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool Wow64SetThreadContext(Handle hThread, in WOW64_CONTEXT lpContext);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern uint16 RtlCaptureStackBackTrace(uint32 FramesToSkip, uint32 FramesToCapture, void** BackTrace, uint32* BackTraceHash);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void RtlCaptureContext(out CONTEXT ContextRecord);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void RtlCaptureContext2(out CONTEXT ContextRecord);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void RtlUnwind(void* TargetFrame, void* TargetIp, EXCEPTION_RECORD* ExceptionRecord, void* ReturnValue);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern bool RtlInstallFunctionTableCallback(uint64 TableIdentifier, uint64 BaseAddress, uint32 Length, PGET_RUNTIME_FUNCTION_CALLBACK Callback, void* Context, char16* OutOfProcessCallbackDll);
		[Import("ntdll.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void RtlGrowFunctionTable(void* DynamicTable, uint32 NewEntryCount);
		[Import("ntdll.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void RtlDeleteGrowableFunctionTable(void* DynamicTable);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void RtlRestoreContext(ref CONTEXT ContextRecord, EXCEPTION_RECORD* ExceptionRecord);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void RtlUnwindEx(void* TargetFrame, void* TargetIp, EXCEPTION_RECORD* ExceptionRecord, void* ReturnValue, ref CONTEXT ContextRecord, UNWIND_HISTORY_TABLE* HistoryTable);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void RtlRaiseException(ref EXCEPTION_RECORD ExceptionRecord);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void* RtlPcToFileHeader(void* PcValue, void** BaseOfImage);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool IsDebuggerPresent();
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void DebugBreak();
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void OutputDebugStringA(char8* lpOutputString);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void OutputDebugStringW(char16* lpOutputString);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ContinueDebugEvent(uint32 dwProcessId, uint32 dwThreadId, uint32 dwContinueStatus);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool WaitForDebugEvent(out DEBUG_EVENT lpDebugEvent, uint32 dwMilliseconds);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool DebugActiveProcess(uint32 dwProcessId);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool DebugActiveProcessStop(uint32 dwProcessId);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool CheckRemoteDebuggerPresent(Handle hProcess, out IntBool pbDebuggerPresent);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool WaitForDebugEventEx(out DEBUG_EVENT lpDebugEvent, uint32 dwMilliseconds);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void* EncodePointer(void* Ptr);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void* DecodePointer(void* Ptr);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void* EncodeSystemPointer(void* Ptr);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void* DecodeSystemPointer(void* Ptr);
		[Import("api-ms-win-core-util-l1-1-1.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern HResult EncodeRemotePointer(Handle ProcessHandle, void* Ptr, void** EncodedPtr);
		[Import("api-ms-win-core-util-l1-1-1.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern HResult DecodeRemotePointer(Handle ProcessHandle, void* Ptr, void** DecodedPtr);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool Beep(uint32 dwFreq, uint32 dwDuration);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void RaiseException(uint32 dwExceptionCode, uint32 dwExceptionFlags, uint32 nNumberOfArguments, uint* lpArguments);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern int32 UnhandledExceptionFilter(ref EXCEPTION_POINTERS ExceptionInfo);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern LPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 GetErrorMode();
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 SetErrorMode(THREAD_ERROR_MODE uMode);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void* AddVectoredExceptionHandler(uint32 First, PVECTORED_EXCEPTION_HANDLER Handler);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 RemoveVectoredExceptionHandler(void* Handle);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void* AddVectoredContinueHandler(uint32 First, PVECTORED_EXCEPTION_HANDLER Handler);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 RemoveVectoredContinueHandler(void* Handle);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void RaiseFailFastException(EXCEPTION_RECORD* pExceptionRecord, CONTEXT* pContextRecord, uint32 dwFlags);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void FatalAppExitA(uint32 uAction, char8* lpMessageText);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void FatalAppExitW(uint32 uAction, char16* lpMessageText);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 GetThreadErrorMode();
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SetThreadErrorMode(THREAD_ERROR_MODE dwNewMode, THREAD_ERROR_MODE* lpOldMode);
		[Import("api-ms-win-core-errorhandling-l1-1-3.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void TerminateProcessOnMemoryExhaustion(uint FailedAllocationSize);
		[Import("advapi32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void* OpenThreadWaitChainSession(OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS Flags, PWAITCHAINCALLBACK callback);
		[Import("advapi32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void CloseThreadWaitChainSession(void* WctHandle);
		[Import("advapi32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool GetThreadWaitChain(void* WctHandle, uint Context, WAIT_CHAIN_THREAD_OPTIONS Flags, uint32 ThreadId, out uint32 NodeCount, WAITCHAIN_NODE_INFO* NodeInfoArray, out int32 IsCycle);
		[Import("advapi32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void RegisterWaitChainCOMCallback(PCOGETCALLSTATE CallStateCallback, PCOGETACTIVATIONSTATE ActivationStateCallback);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool MiniDumpWriteDump(Handle hProcess, uint32 ProcessId, Handle hFile, MINIDUMP_TYPE DumpType, MINIDUMP_EXCEPTION_INFORMATION* ExceptionParam, MINIDUMP_USER_STREAM_INFORMATION* UserStreamParam, MINIDUMP_CALLBACK_INFORMATION* CallbackParam);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool MiniDumpReadDumpStream(void* BaseOfDump, uint32 StreamNumber, MINIDUMP_DIRECTORY** Dir, void** StreamPointer, uint32* StreamSize);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool BindImage(char8* ImageName, char8* DllPath, char8* SymbolPath);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool BindImageEx(uint32 Flags, char8* ImageName, char8* DllPath, char8* SymbolPath, PIMAGEHLP_STATUS_ROUTINE StatusRoutine);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ReBaseImage(char8* CurrentImageName, char8* SymbolPath, IntBool fReBase, IntBool fRebaseSysfileOk, IntBool fGoingDown, uint32 CheckImageSize, out uint32 OldImageSize, out uint OldImageBase, out uint32 NewImageSize, out uint NewImageBase, uint32 TimeStamp);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ReBaseImage64(char8* CurrentImageName, char8* SymbolPath, IntBool fReBase, IntBool fRebaseSysfileOk, IntBool fGoingDown, uint32 CheckImageSize, out uint32 OldImageSize, out uint64 OldImageBase, out uint32 NewImageSize, out uint64 NewImageBase, uint32 TimeStamp);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IMAGE_NT_HEADERS64* CheckSumMappedFile(void* BaseAddress, uint32 FileLength, out uint32 HeaderSum, out uint32 CheckSum);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 MapFileAndCheckSumA(char8* Filename, out uint32 HeaderSum, out uint32 CheckSum);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 MapFileAndCheckSumW(char16* Filename, out uint32 HeaderSum, out uint32 CheckSum);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool GetImageConfigInformation(ref LOADED_IMAGE LoadedImage, out IMAGE_LOAD_CONFIG_DIRECTORY64 ImageConfigInformation);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 GetImageUnusedHeaderBytes(ref LOADED_IMAGE LoadedImage, out uint32 SizeUnusedHeaderBytes);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SetImageConfigInformation(out LOADED_IMAGE LoadedImage, ref IMAGE_LOAD_CONFIG_DIRECTORY64 ImageConfigInformation);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ImageGetDigestStream(Handle FileHandle, uint32 DigestLevel, DIGEST_FUNCTION DigestFunction, void* DigestHandle);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ImageAddCertificate(Handle FileHandle, ref WIN_CERTIFICATE Certificate, out uint32 Index);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ImageRemoveCertificate(Handle FileHandle, uint32 Index);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ImageEnumerateCertificates(Handle FileHandle, uint16 TypeFilter, out uint32 CertificateCount, uint32* Indices, uint32 IndexCount);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ImageGetCertificateData(Handle FileHandle, uint32 CertificateIndex, out WIN_CERTIFICATE Certificate, out uint32 RequiredLength);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ImageGetCertificateHeader(Handle FileHandle, uint32 CertificateIndex, out WIN_CERTIFICATE Certificateheader);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern LOADED_IMAGE* ImageLoad(char8* DllName, char8* DllPath);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ImageUnload(out LOADED_IMAGE LoadedImage);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool MapAndLoad(char8* ImageName, char8* DllPath, out LOADED_IMAGE LoadedImage, IntBool DotDll, IntBool ReadOnly);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool UnMapAndLoad(out LOADED_IMAGE LoadedImage);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool TouchFileTimes(Handle FileHandle, SYSTEMTIME* pSystemTime);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool UpdateDebugInfoFile(char8* ImageFileName, char8* SymbolPath, char8* DebugFilePath, ref IMAGE_NT_HEADERS32 NtHeaders);
		[Import("imagehlp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool UpdateDebugInfoFileEx(char8* ImageFileName, char8* SymbolPath, char8* DebugFilePath, ref IMAGE_NT_HEADERS32 NtHeaders, uint32 OldCheckSum);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle SymFindDebugInfoFile(Handle hProcess, char8* FileName, char8* DebugFilePath, PFIND_DEBUG_FILE_CALLBACK Callback, void* CallerData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle SymFindDebugInfoFileW(Handle hProcess, char16* FileName, char16* DebugFilePath, PFIND_DEBUG_FILE_CALLBACKW Callback, void* CallerData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle FindDebugInfoFile(char8* FileName, char8* SymbolPath, char8* DebugFilePath);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle FindDebugInfoFileEx(char8* FileName, char8* SymbolPath, char8* DebugFilePath, PFIND_DEBUG_FILE_CALLBACK Callback, void* CallerData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle FindDebugInfoFileExW(char16* FileName, char16* SymbolPath, char16* DebugFilePath, PFIND_DEBUG_FILE_CALLBACKW Callback, void* CallerData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFindFileInPath(Handle hprocess, char8* SearchPathA, char8* FileName, void* id, uint32 two, uint32 three, SYM_FIND_ID_OPTION flags, char8* FoundFile, PFINDFILEINPATHCALLBACK callback, void* context);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFindFileInPathW(Handle hprocess, char16* SearchPathA, char16* FileName, void* id, uint32 two, uint32 three, SYM_FIND_ID_OPTION flags, char16* FoundFile, PFINDFILEINPATHCALLBACKW callback, void* context);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle SymFindExecutableImage(Handle hProcess, char8* FileName, char8* ImageFilePath, PFIND_EXE_FILE_CALLBACK Callback, void* CallerData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle SymFindExecutableImageW(Handle hProcess, char16* FileName, char16* ImageFilePath, PFIND_EXE_FILE_CALLBACKW Callback, void* CallerData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle FindExecutableImage(char8* FileName, char8* SymbolPath, char8* ImageFilePath);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle FindExecutableImageEx(char8* FileName, char8* SymbolPath, char8* ImageFilePath, PFIND_EXE_FILE_CALLBACK Callback, void* CallerData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern Handle FindExecutableImageExW(char16* FileName, char16* SymbolPath, char16* ImageFilePath, PFIND_EXE_FILE_CALLBACKW Callback, void* CallerData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IMAGE_NT_HEADERS64* ImageNtHeader(void* Base);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void* ImageDirectoryEntryToDataEx(void* Base, bool MappedAsImage, IMAGE_DIRECTORY_ENTRY DirectoryEntry, out uint32 Size, IMAGE_SECTION_HEADER** FoundHeader);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void* ImageDirectoryEntryToData(void* Base, bool MappedAsImage, IMAGE_DIRECTORY_ENTRY DirectoryEntry, out uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IMAGE_SECTION_HEADER* ImageRvaToSection(ref IMAGE_NT_HEADERS64 NtHeaders, void* Base, uint32 Rva);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void* ImageRvaToVa(ref IMAGE_NT_HEADERS64 NtHeaders, void* Base, uint32 Rva, IMAGE_SECTION_HEADER** LastRvaSection);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SearchTreeForFile(char8* RootPath, char8* InputPathName, char8* OutputPathBuffer);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SearchTreeForFileW(char16* RootPath, char16* InputPathName, char16* OutputPathBuffer);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool EnumDirTree(Handle hProcess, char8* RootPath, char8* InputPathName, char8* OutputPathBuffer, PENUMDIRTREE_CALLBACK cb, void* data);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool EnumDirTreeW(Handle hProcess, char16* RootPath, char16* InputPathName, char16* OutputPathBuffer, PENUMDIRTREE_CALLBACKW cb, void* data);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool MakeSureDirectoryPathExists(char8* DirPath);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 UnDecorateSymbolName(char8* name, uint8* outputString, uint32 maxStringLength, uint32 flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 UnDecorateSymbolNameW(char16* name, char16* outputString, uint32 maxStringLength, uint32 flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool StackWalk64(uint32 MachineType, Handle hProcess, Handle hThread, out STACKFRAME64 StackFrame, void* ContextRecord, PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine, PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine, PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine, PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool StackWalkEx(uint32 MachineType, Handle hProcess, Handle hThread, out STACKFRAME_EX StackFrame, void* ContextRecord, PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine, PFUNCTION_TABLE_ACCESS_ROUTINE64 FunctionTableAccessRoutine, PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine, PTRANSLATE_ADDRESS_ROUTINE64 TranslateAddress, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern API_VERSION* ImagehlpApiVersion();
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern API_VERSION* ImagehlpApiVersionEx(ref API_VERSION AppVersion);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 GetTimestampForLoadedLibrary(HInstance Module);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSetParentWindow(HWnd hwnd);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char8* SymSetHomeDirectory(Handle hProcess, char8* dir);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char16* SymSetHomeDirectoryW(Handle hProcess, char16* dir);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char8* SymGetHomeDirectory(IMAGEHLP_HD_TYPE type, uint8* dir, uint size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char16* SymGetHomeDirectoryW(IMAGEHLP_HD_TYPE type, char16* dir, uint size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetOmaps(Handle hProcess, uint64 BaseOfDll, out OMAP* OmapTo, out uint64 cOmapTo, out OMAP* OmapFrom, out uint64 cOmapFrom);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 SymSetOptions(uint32 SymOptions);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 SymGetOptions();
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymCleanup(Handle hProcess);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetExtendedOption(IMAGEHLP_EXTENDED_OPTIONS option);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSetExtendedOption(IMAGEHLP_EXTENDED_OPTIONS option, IntBool value);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymMatchString(char8* string, char8* expression, IntBool fCase);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymMatchStringA(char8* string, char8* expression, IntBool fCase);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymMatchStringW(char16* string, char16* expression, IntBool fCase);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSourceFiles(Handle hProcess, uint64 ModBase, char8* Mask, PSYM_ENUMSOURCEFILES_CALLBACK cbSrcFiles, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSourceFilesW(Handle hProcess, uint64 ModBase, char16* Mask, PSYM_ENUMSOURCEFILES_CALLBACKW cbSrcFiles, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumerateModules64(Handle hProcess, PSYM_ENUMMODULES_CALLBACK64 EnumModulesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumerateModulesW64(Handle hProcess, PSYM_ENUMMODULES_CALLBACKW64 EnumModulesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool EnumerateLoadedModulesEx(Handle hProcess, PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool EnumerateLoadedModulesExW(Handle hProcess, PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool EnumerateLoadedModules64(Handle hProcess, PENUMLOADED_MODULES_CALLBACK64 EnumLoadedModulesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool EnumerateLoadedModulesW64(Handle hProcess, PENUMLOADED_MODULES_CALLBACKW64 EnumLoadedModulesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void* SymFunctionTableAccess64(Handle hProcess, uint64 AddrBase);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void* SymFunctionTableAccess64AccessRoutines(Handle hProcess, uint64 AddrBase, PREAD_PROCESS_MEMORY_ROUTINE64 ReadMemoryRoutine, PGET_MODULE_BASE_ROUTINE64 GetModuleBaseRoutine);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetUnwindInfo(Handle hProcess, uint64 Address, void* Buffer, out uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetModuleInfo64(Handle hProcess, uint64 qwAddr, out IMAGEHLP_MODULE64 ModuleInfo);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetModuleInfoW64(Handle hProcess, uint64 qwAddr, out IMAGEHLP_MODULEW64 ModuleInfo);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint64 SymGetModuleBase64(Handle hProcess, uint64 qwAddr);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumLines(Handle hProcess, uint64 Base, char8* Obj, char8* File, PSYM_ENUMLINES_CALLBACK EnumLinesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumLinesW(Handle hProcess, uint64 Base, char16* Obj, char16* File, PSYM_ENUMLINES_CALLBACKW EnumLinesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineFromAddr64(Handle hProcess, uint64 qwAddr, out uint32 pdwDisplacement, out IMAGEHLP_LINE64 Line64);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineFromAddrW64(Handle hProcess, uint64 dwAddr, out uint32 pdwDisplacement, out IMAGEHLP_LINEW64 Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineFromInlineContext(Handle hProcess, uint64 qwAddr, uint32 InlineContext, uint64 qwModuleBaseAddress, out uint32 pdwDisplacement, out IMAGEHLP_LINE64 Line64);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineFromInlineContextW(Handle hProcess, uint64 dwAddr, uint32 InlineContext, uint64 qwModuleBaseAddress, out uint32 pdwDisplacement, out IMAGEHLP_LINEW64 Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSourceLines(Handle hProcess, uint64 Base, char8* Obj, char8* File, uint32 Line, uint32 Flags, PSYM_ENUMLINES_CALLBACK EnumLinesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSourceLinesW(Handle hProcess, uint64 Base, char16* Obj, char16* File, uint32 Line, uint32 Flags, PSYM_ENUMLINES_CALLBACKW EnumLinesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 SymAddrIncludeInlineTrace(Handle hProcess, uint64 Address);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 SymCompareInlineTrace(Handle hProcess, uint64 Address1, uint32 InlineContext1, uint64 RetAddress1, uint64 Address2, uint64 RetAddress2);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymQueryInlineTrace(Handle hProcess, uint64 StartAddress, uint32 StartContext, uint64 StartRetAddress, uint64 CurAddress, out uint32 CurContext, out uint32 CurFrameIndex);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineFromName64(Handle hProcess, char8* ModuleName, char8* FileName, uint32 dwLineNumber, out int32 plDisplacement, out IMAGEHLP_LINE64 Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineFromNameW64(Handle hProcess, char16* ModuleName, char16* FileName, uint32 dwLineNumber, out int32 plDisplacement, out IMAGEHLP_LINEW64 Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineNext64(Handle hProcess, out IMAGEHLP_LINE64 Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineNextW64(Handle hProcess, out IMAGEHLP_LINEW64 Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLinePrev64(Handle hProcess, out IMAGEHLP_LINE64 Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLinePrevW64(Handle hProcess, out IMAGEHLP_LINEW64 Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 SymGetFileLineOffsets64(Handle hProcess, char8* ModuleName, char8* FileName, uint64* Buffer, uint32 BufferLines);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymMatchFileName(char8* FileName, char8* Match, char8** FileNameStop, char8** MatchStop);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymMatchFileNameW(char16* FileName, char16* Match, char16** FileNameStop, char16** MatchStop);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFile(Handle hProcess, uint64 Base, char8* Params, char8* FileSpec, uint8* FilePath, uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileW(Handle hProcess, uint64 Base, char16* Params, char16* FileSpec, char16* FilePath, uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileToken(Handle hProcess, uint64 Base, char8* FileSpec, void** Token, out uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileTokenByTokenName(Handle hProcess, uint64 Base, char8* FileSpec, char8* TokenName, char8* TokenParameters, void** Token, out uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileChecksumW(Handle hProcess, uint64 Base, char16* FileSpec, out uint32 pCheckSumType, uint8* pChecksum, uint32 checksumSize, out uint32 pActualBytesWritten);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileChecksum(Handle hProcess, uint64 Base, char8* FileSpec, out uint32 pCheckSumType, uint8* pChecksum, uint32 checksumSize, out uint32 pActualBytesWritten);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileTokenW(Handle hProcess, uint64 Base, char16* FileSpec, void** Token, out uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileTokenByTokenNameW(Handle hProcess, uint64 Base, char16* FileSpec, char16* TokenName, char16* TokenParameters, void** Token, out uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileFromToken(Handle hProcess, void* Token, char8* Params, uint8* FilePath, uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileFromTokenByTokenName(Handle hProcess, void* Token, char8* TokenName, char8* Params, uint8* FilePath, uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileFromTokenW(Handle hProcess, void* Token, char16* Params, char16* FilePath, uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceFileFromTokenByTokenNameW(Handle hProcess, void* Token, char16* TokenName, char16* Params, char16* FilePath, uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceVarFromToken(Handle hProcess, void* Token, char8* Params, char8* VarName, uint8* Value, uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSourceVarFromTokenW(Handle hProcess, void* Token, char16* Params, char16* VarName, char16* Value, uint32 Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSourceFileTokens(Handle hProcess, uint64 Base, PENUMSOURCEFILETOKENSCALLBACK Callback);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymInitialize(Handle hProcess, char8* UserSearchPath, IntBool fInvadeProcess);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymInitializeW(Handle hProcess, char16* UserSearchPath, IntBool fInvadeProcess);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSearchPath(Handle hProcess, uint8* SearchPathA, uint32 SearchPathLength);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSearchPathW(Handle hProcess, char16* SearchPathA, uint32 SearchPathLength);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSetSearchPath(Handle hProcess, char8* SearchPathA);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSetSearchPathW(Handle hProcess, char16* SearchPathA);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint64 SymLoadModuleEx(Handle hProcess, Handle hFile, char8* ImageName, char8* ModuleName, uint64 BaseOfDll, uint32 DllSize, MODLOAD_DATA* Data, SYM_LOAD_FLAGS Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint64 SymLoadModuleExW(Handle hProcess, Handle hFile, char16* ImageName, char16* ModuleName, uint64 BaseOfDll, uint32 DllSize, MODLOAD_DATA* Data, SYM_LOAD_FLAGS Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymUnloadModule64(Handle hProcess, uint64 BaseOfDll);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymUnDName64(ref IMAGEHLP_SYMBOL64 sym, uint8* UnDecName, uint32 UnDecNameLength);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymRegisterCallback64(Handle hProcess, PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction, uint64 UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymRegisterCallbackW64(Handle hProcess, PSYMBOL_REGISTERED_CALLBACK64 CallbackFunction, uint64 UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymRegisterFunctionEntryCallback64(Handle hProcess, PSYMBOL_FUNCENTRY_CALLBACK64 CallbackFunction, uint64 UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSetContext(Handle hProcess, ref IMAGEHLP_STACK_FRAME StackFrame, void* Context);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSetScopeFromAddr(Handle hProcess, uint64 Address);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSetScopeFromInlineContext(Handle hProcess, uint64 Address, uint32 InlineContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSetScopeFromIndex(Handle hProcess, uint64 BaseOfDll, uint32 Index);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumProcesses(PSYM_ENUMPROCESSES_CALLBACK EnumProcessesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromAddr(Handle hProcess, uint64 Address, uint64* Displacement, out SYMBOL_INFO Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromAddrW(Handle hProcess, uint64 Address, uint64* Displacement, out SYMBOL_INFOW Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromInlineContext(Handle hProcess, uint64 Address, uint32 InlineContext, uint64* Displacement, out SYMBOL_INFO Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromInlineContextW(Handle hProcess, uint64 Address, uint32 InlineContext, uint64* Displacement, out SYMBOL_INFOW Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromToken(Handle hProcess, uint64 Base, uint32 Token, out SYMBOL_INFO Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromTokenW(Handle hProcess, uint64 Base, uint32 Token, out SYMBOL_INFOW Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymNext(Handle hProcess, out SYMBOL_INFO si);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymNextW(Handle hProcess, out SYMBOL_INFOW siw);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymPrev(Handle hProcess, out SYMBOL_INFO si);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymPrevW(Handle hProcess, out SYMBOL_INFOW siw);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromName(Handle hProcess, char8* Name, out SYMBOL_INFO Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromNameW(Handle hProcess, char16* Name, out SYMBOL_INFOW Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSymbols(Handle hProcess, uint64 BaseOfDll, char8* Mask, PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSymbolsEx(Handle hProcess, uint64 BaseOfDll, char8* Mask, PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback, void* UserContext, uint32 Options);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSymbolsW(Handle hProcess, uint64 BaseOfDll, char16* Mask, PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSymbolsExW(Handle hProcess, uint64 BaseOfDll, char16* Mask, PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback, void* UserContext, uint32 Options);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSymbolsForAddr(Handle hProcess, uint64 Address, PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSymbolsForAddrW(Handle hProcess, uint64 Address, PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSearch(Handle hProcess, uint64 BaseOfDll, uint32 Index, uint32 SymTag, char8* Mask, uint64 Address, PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback, void* UserContext, uint32 Options);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSearchW(Handle hProcess, uint64 BaseOfDll, uint32 Index, uint32 SymTag, char16* Mask, uint64 Address, PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback, void* UserContext, uint32 Options);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetScope(Handle hProcess, uint64 BaseOfDll, uint32 Index, out SYMBOL_INFO Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetScopeW(Handle hProcess, uint64 BaseOfDll, uint32 Index, out SYMBOL_INFOW Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromIndex(Handle hProcess, uint64 BaseOfDll, uint32 Index, out SYMBOL_INFO Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymFromIndexW(Handle hProcess, uint64 BaseOfDll, uint32 Index, out SYMBOL_INFOW Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetTypeInfo(Handle hProcess, uint64 ModBase, uint32 TypeId, IMAGEHLP_SYMBOL_TYPE_INFO GetType, void* pInfo);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetTypeInfoEx(Handle hProcess, uint64 ModBase, out IMAGEHLP_GET_TYPE_INFO_PARAMS Params);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumTypes(Handle hProcess, uint64 BaseOfDll, PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumTypesW(Handle hProcess, uint64 BaseOfDll, PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumTypesByName(Handle hProcess, uint64 BaseOfDll, char8* mask, PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumTypesByNameW(Handle hProcess, uint64 BaseOfDll, char16* mask, PSYM_ENUMERATESYMBOLS_CALLBACKW EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetTypeFromName(Handle hProcess, uint64 BaseOfDll, char8* Name, out SYMBOL_INFO Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetTypeFromNameW(Handle hProcess, uint64 BaseOfDll, char16* Name, out SYMBOL_INFOW Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymAddSymbol(Handle hProcess, uint64 BaseOfDll, char8* Name, uint64 Address, uint32 Size, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymAddSymbolW(Handle hProcess, uint64 BaseOfDll, char16* Name, uint64 Address, uint32 Size, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymDeleteSymbol(Handle hProcess, uint64 BaseOfDll, char8* Name, uint64 Address, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymDeleteSymbolW(Handle hProcess, uint64 BaseOfDll, char16* Name, uint64 Address, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymRefreshModuleList(Handle hProcess);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymAddSourceStream(Handle hProcess, uint64 Base, char8* StreamFile, uint8* Buffer, uint Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymAddSourceStreamA(Handle hProcess, uint64 Base, char8* StreamFile, uint8* Buffer, uint Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymAddSourceStreamW(Handle hProcess, uint64 Base, char16* FileSpec, uint8* Buffer, uint Size);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSrvIsStoreW(Handle hProcess, char16* path);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSrvIsStore(Handle hProcess, char8* path);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char8* SymSrvDeltaName(Handle hProcess, char8* SymPath, char8* Type, char8* File1, char8* File2);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char16* SymSrvDeltaNameW(Handle hProcess, char16* SymPath, char16* Type, char16* File1, char16* File2);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char8* SymSrvGetSupplement(Handle hProcess, char8* SymPath, char8* Node, char8* File);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char16* SymSrvGetSupplementW(Handle hProcess, char16* SymPath, char16* Node, char16* File);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSrvGetFileIndexes(char8* File, out Guid Id, out uint32 Val1, uint32* Val2, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSrvGetFileIndexesW(char16* File, out Guid Id, out uint32 Val1, uint32* Val2, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSrvGetFileIndexStringW(Handle hProcess, char16* SrvPath, char16* File, char16* Index, uint Size, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSrvGetFileIndexString(Handle hProcess, char8* SrvPath, char8* File, uint8* Index, uint Size, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSrvGetFileIndexInfo(char8* File, out SYMSRV_INDEX_INFO Info, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymSrvGetFileIndexInfoW(char16* File, out SYMSRV_INDEX_INFOW Info, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char8* SymSrvStoreSupplement(Handle hProcess, char8* SrvPath, char8* Node, char8* File, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char16* SymSrvStoreSupplementW(Handle hProcess, char16* SymPath, char16* Node, char16* File, uint32 Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char8* SymSrvStoreFile(Handle hProcess, char8* SrvPath, char8* File, SYM_SRV_STORE_FILE_FLAGS Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern char16* SymSrvStoreFileW(Handle hProcess, char16* SrvPath, char16* File, SYM_SRV_STORE_FILE_FLAGS Flags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymbolFile(Handle hProcess, char8* SymPath, char8* ImageFile, IMAGEHLP_SF_TYPE Type, uint8* SymbolFile, uint cSymbolFile, uint8* DbgFile, uint cDbgFile);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymbolFileW(Handle hProcess, char16* SymPath, char16* ImageFile, IMAGEHLP_SF_TYPE Type, char16* SymbolFile, uint cSymbolFile, char16* DbgFile, uint cDbgFile);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool DbgHelpCreateUserDump(char8* FileName, PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback, void* UserData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool DbgHelpCreateUserDumpW(char16* FileName, PDBGHELP_CREATE_USER_DUMP_CALLBACK Callback, void* UserData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymFromAddr64(Handle hProcess, uint64 qwAddr, uint64* pdwDisplacement, out IMAGEHLP_SYMBOL64 Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymFromName64(Handle hProcess, char8* Name, out IMAGEHLP_SYMBOL64 Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool FindFileInPath(Handle hprocess, char8* SearchPathA, char8* FileName, void* id, uint32 two, uint32 three, uint32 flags, char8* FilePath);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool FindFileInSearchPath(Handle hprocess, char8* SearchPathA, char8* FileName, uint32 one, uint32 two, uint32 three, char8* FilePath);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumSym(Handle hProcess, uint64 BaseOfDll, PSYM_ENUMERATESYMBOLS_CALLBACK EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumerateSymbols64(Handle hProcess, uint64 BaseOfDll, PSYM_ENUMSYMBOLS_CALLBACK64 EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumerateSymbolsW64(Handle hProcess, uint64 BaseOfDll, PSYM_ENUMSYMBOLS_CALLBACK64W EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint64 SymLoadModule64(Handle hProcess, Handle hFile, char8* ImageName, char8* ModuleName, uint64 BaseOfDll, uint32 SizeOfDll);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymNext64(Handle hProcess, out IMAGEHLP_SYMBOL64 Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymPrev64(Handle hProcess, out IMAGEHLP_SYMBOL64 Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void SetCheckUserInterruptShared(LPCALL_BACK_USER_INTERRUPT_ROUTINE lpStartAddress);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 GetSymLoadError();
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void SetSymLoadError(uint32 error);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool ReportSymbolLoadSummary(Handle hProcess, char16* pLoadModule, ref DBGHELP_DATA_REPORT_STRUCT pSymbolData);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void RemoveInvalidModuleList(Handle hProcess);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void* RangeMapCreate();
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void RangeMapFree(void* RmapHandle);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool RangeMapAddPeImageSections(void* RmapHandle, char16* ImageName, void* MappedImage, uint32 MappingBytes, uint64 ImageBase, uint64 UserTag, uint32 MappingFlags);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool RangeMapRemove(void* RmapHandle, uint64 UserTag);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool RangeMapRead(void* RmapHandle, uint64 Offset, void* Buffer, uint32 RequestBytes, uint32 Flags, uint32* DoneBytes);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool RangeMapWrite(void* RmapHandle, uint64 Offset, void* Buffer, uint32 RequestBytes, uint32 Flags, uint32* DoneBytes);
		[Import("user32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool MessageBeep(uint32 uType);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void FatalExit(int32 ExitCode);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool GetThreadSelectorEntry(Handle hThread, uint32 dwSelector, out LDT_ENTRY lpSelectorEntry);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool Wow64GetThreadSelectorEntry(Handle hThread, uint32 dwSelector, out WOW64_LDT_ENTRY lpSelectorEntry);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool DebugSetProcessKillOnExit(IntBool KillOnExit);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool DebugBreakProcess(Handle Process);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 FormatMessageA(FORMAT_MESSAGE_OPTIONS dwFlags, void* lpSource, uint32 dwMessageId, uint32 dwLanguageId, char8* lpBuffer, uint32 nSize, int8** Arguments);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 FormatMessageW(FORMAT_MESSAGE_OPTIONS dwFlags, void* lpSource, uint32 dwMessageId, uint32 dwLanguageId, char16* lpBuffer, uint32 nSize, int8** Arguments);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool CopyContext(out CONTEXT Destination, uint32 ContextFlags, ref CONTEXT Source);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool InitializeContext(void* Buffer, uint32 ContextFlags, out CONTEXT* Context, out uint32 ContextLength);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool InitializeContext2(void* Buffer, uint32 ContextFlags, out CONTEXT* Context, out uint32 ContextLength, uint64 XStateCompactionMask);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern uint64 GetEnabledXStateFeatures();
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool GetXStateFeaturesMask(ref CONTEXT Context, out uint64 FeatureMask);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern void* LocateXStateFeature(ref CONTEXT Context, uint32 FeatureId, uint32* Length);
		[Import("kernel32.lib"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SetXStateFeaturesMask(out CONTEXT Context, uint64 FeatureMask);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool StackWalk(uint32 MachineType, Handle hProcess, Handle hThread, out STACKFRAME StackFrame, void* ContextRecord, PREAD_PROCESS_MEMORY_ROUTINE ReadMemoryRoutine, PFUNCTION_TABLE_ACCESS_ROUTINE FunctionTableAccessRoutine, PGET_MODULE_BASE_ROUTINE GetModuleBaseRoutine, PTRANSLATE_ADDRESS_ROUTINE TranslateAddress);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumerateModules(Handle hProcess, PSYM_ENUMMODULES_CALLBACK EnumModulesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool EnumerateLoadedModules(Handle hProcess, PENUMLOADED_MODULES_CALLBACK EnumLoadedModulesCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern void* SymFunctionTableAccess(Handle hProcess, uint32 AddrBase);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetModuleInfo(Handle hProcess, uint32 dwAddr, out IMAGEHLP_MODULE ModuleInfo);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetModuleInfoW(Handle hProcess, uint32 dwAddr, out IMAGEHLP_MODULEW ModuleInfo);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 SymGetModuleBase(Handle hProcess, uint32 dwAddr);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineFromAddr(Handle hProcess, uint32 dwAddr, out uint32 pdwDisplacement, out IMAGEHLP_LINE Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineFromName(Handle hProcess, char8* ModuleName, char8* FileName, uint32 dwLineNumber, out int32 plDisplacement, out IMAGEHLP_LINE Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLineNext(Handle hProcess, out IMAGEHLP_LINE Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetLinePrev(Handle hProcess, out IMAGEHLP_LINE Line);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymUnloadModule(Handle hProcess, uint32 BaseOfDll);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymUnDName(ref IMAGEHLP_SYMBOL sym, uint8* UnDecName, uint32 UnDecNameLength);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymRegisterCallback(Handle hProcess, PSYMBOL_REGISTERED_CALLBACK CallbackFunction, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymRegisterFunctionEntryCallback(Handle hProcess, PSYMBOL_FUNCENTRY_CALLBACK CallbackFunction, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymFromAddr(Handle hProcess, uint32 dwAddr, uint32* pdwDisplacement, out IMAGEHLP_SYMBOL Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymFromName(Handle hProcess, char8* Name, out IMAGEHLP_SYMBOL Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumerateSymbols(Handle hProcess, uint32 BaseOfDll, PSYM_ENUMSYMBOLS_CALLBACK EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymEnumerateSymbolsW(Handle hProcess, uint32 BaseOfDll, PSYM_ENUMSYMBOLS_CALLBACKW EnumSymbolsCallback, void* UserContext);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern uint32 SymLoadModule(Handle hProcess, Handle hFile, char8* ImageName, char8* ModuleName, uint32 BaseOfDll, uint32 SizeOfDll);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymNext(Handle hProcess, out IMAGEHLP_SYMBOL Symbol);
		[Import("dbghelp.dll"), CLink, CallingConvention(.Stdcall)]
		public static extern IntBool SymGetSymPrev(Handle hProcess, out IMAGEHLP_SYMBOL Symbol);
	}
}
